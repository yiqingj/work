// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map.traffic.proto

#ifndef PROTOBUF_map_2etraffic_2eproto__INCLUDED
#define PROTOBUF_map_2etraffic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "common.pb.h"
#include "services.pb.h"
// @@protoc_insertion_point(includes)

namespace com {
namespace telenav {
namespace proto {
namespace map {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_map_2etraffic_2eproto();
void protobuf_AssignDesc_map_2etraffic_2eproto();
void protobuf_ShutdownFile_map_2etraffic_2eproto();

class TrafficRequest;
class ReportIncidentRequest;
class TileId;
class TrafficResponse;
class TrafficFlow;
class TrafficIncident;
class TrafficLevelDictionary;
class TrafficLevelPair;

enum TrafficRequest_Type {
  TrafficRequest_Type_TRAFFIC_IDS = 1,
  TrafficRequest_Type_TILE_ID = 2
};
bool TrafficRequest_Type_IsValid(int value);
const TrafficRequest_Type TrafficRequest_Type_Type_MIN = TrafficRequest_Type_TRAFFIC_IDS;
const TrafficRequest_Type TrafficRequest_Type_Type_MAX = TrafficRequest_Type_TILE_ID;
const int TrafficRequest_Type_Type_ARRAYSIZE = TrafficRequest_Type_Type_MAX + 1;

enum Severity {
  BLOCKER = -1,
  CRITICAL = 1,
  MAJOR = 2,
  MINOR = 3,
  LOW_IMPACT = 4
};
bool Severity_IsValid(int value);
const Severity Severity_MIN = BLOCKER;
const Severity Severity_MAX = LOW_IMPACT;
const int Severity_ARRAYSIZE = Severity_MAX + 1;

enum IncidentType {
  ACCIDENT = 1,
  CONSTRUCTION = 2,
  DISABLED_VEHICLE = 3,
  ROAD_HAZARD = 4
};
bool IncidentType_IsValid(int value);
const IncidentType IncidentType_MIN = ACCIDENT;
const IncidentType IncidentType_MAX = ROAD_HAZARD;
const int IncidentType_ARRAYSIZE = IncidentType_MAX + 1;

// ===================================================================

class TrafficRequest : public ::google::protobuf::MessageLite {
 public:
  TrafficRequest();
  virtual ~TrafficRequest();

  TrafficRequest(const TrafficRequest& from);

  inline TrafficRequest& operator=(const TrafficRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrafficRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrafficRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrafficRequest* other);

  // implements Message ----------------------------------------------

  TrafficRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrafficRequest& from);
  void MergeFrom(const TrafficRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TrafficRequest_Type Type;
  static const Type TRAFFIC_IDS = TrafficRequest_Type_TRAFFIC_IDS;
  static const Type TILE_ID = TrafficRequest_Type_TILE_ID;
  static inline bool Type_IsValid(int value) {
    return TrafficRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficRequest_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficRequest_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .com.telenav.proto.map.TrafficRequest.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::com::telenav::proto::map::TrafficRequest_Type type() const;
  inline void set_type(::com::telenav::proto::map::TrafficRequest_Type value);

  // repeated string traffic_id = 2;
  inline int traffic_id_size() const;
  inline void clear_traffic_id();
  static const int kTrafficIdFieldNumber = 2;
  inline const ::std::string& traffic_id(int index) const;
  inline ::std::string* mutable_traffic_id(int index);
  inline void set_traffic_id(int index, const ::std::string& value);
  inline void set_traffic_id(int index, const char* value);
  inline void set_traffic_id(int index, const char* value, size_t size);
  inline ::std::string* add_traffic_id();
  inline void add_traffic_id(const ::std::string& value);
  inline void add_traffic_id(const char* value);
  inline void add_traffic_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& traffic_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_traffic_id();

  // optional .com.telenav.proto.map.TileId tile_id = 3;
  inline bool has_tile_id() const;
  inline void clear_tile_id();
  static const int kTileIdFieldNumber = 3;
  inline const ::com::telenav::proto::map::TileId& tile_id() const;
  inline ::com::telenav::proto::map::TileId* mutable_tile_id();
  inline ::com::telenav::proto::map::TileId* release_tile_id();
  inline void set_allocated_tile_id(::com::telenav::proto::map::TileId* tile_id);

  // optional .com.telenav.proto.Context context = 4;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 4;
  inline const ::com::telenav::proto::Context& context() const;
  inline ::com::telenav::proto::Context* mutable_context();
  inline ::com::telenav::proto::Context* release_context();
  inline void set_allocated_context(::com::telenav::proto::Context* context);

  // optional string data_set = 5;
  inline bool has_data_set() const;
  inline void clear_data_set();
  static const int kDataSetFieldNumber = 5;
  inline const ::std::string& data_set() const;
  inline void set_data_set(const ::std::string& value);
  inline void set_data_set(const char* value);
  inline void set_data_set(const char* value, size_t size);
  inline ::std::string* mutable_data_set();
  inline ::std::string* release_data_set();
  inline void set_allocated_data_set(::std::string* data_set);

  // optional string flow_data_src = 6;
  inline bool has_flow_data_src() const;
  inline void clear_flow_data_src();
  static const int kFlowDataSrcFieldNumber = 6;
  inline const ::std::string& flow_data_src() const;
  inline void set_flow_data_src(const ::std::string& value);
  inline void set_flow_data_src(const char* value);
  inline void set_flow_data_src(const char* value, size_t size);
  inline ::std::string* mutable_flow_data_src();
  inline ::std::string* release_flow_data_src();
  inline void set_allocated_flow_data_src(::std::string* flow_data_src);

  // optional string alert_data_src = 7;
  inline bool has_alert_data_src() const;
  inline void clear_alert_data_src();
  static const int kAlertDataSrcFieldNumber = 7;
  inline const ::std::string& alert_data_src() const;
  inline void set_alert_data_src(const ::std::string& value);
  inline void set_alert_data_src(const char* value);
  inline void set_alert_data_src(const char* value, size_t size);
  inline ::std::string* mutable_alert_data_src();
  inline ::std::string* release_alert_data_src();
  inline void set_allocated_alert_data_src(::std::string* alert_data_src);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.TrafficRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_tile_id();
  inline void clear_has_tile_id();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_data_set();
  inline void clear_has_data_set();
  inline void set_has_flow_data_src();
  inline void clear_has_flow_data_src();
  inline void set_has_alert_data_src();
  inline void clear_has_alert_data_src();

  ::google::protobuf::RepeatedPtrField< ::std::string> traffic_id_;
  ::com::telenav::proto::map::TileId* tile_id_;
  ::com::telenav::proto::Context* context_;
  ::std::string* data_set_;
  ::std::string* flow_data_src_;
  ::std::string* alert_data_src_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2etraffic_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2etraffic_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2etraffic_2eproto();
  friend void protobuf_ShutdownFile_map_2etraffic_2eproto();

  void InitAsDefaultInstance();
  static TrafficRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReportIncidentRequest : public ::google::protobuf::MessageLite {
 public:
  ReportIncidentRequest();
  virtual ~ReportIncidentRequest();

  ReportIncidentRequest(const ReportIncidentRequest& from);

  inline ReportIncidentRequest& operator=(const ReportIncidentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReportIncidentRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReportIncidentRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReportIncidentRequest* other);

  // implements Message ----------------------------------------------

  ReportIncidentRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReportIncidentRequest& from);
  void MergeFrom(const ReportIncidentRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.Context context = 1;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 1;
  inline const ::com::telenav::proto::Context& context() const;
  inline ::com::telenav::proto::Context* mutable_context();
  inline ::com::telenav::proto::Context* release_context();
  inline void set_allocated_context(::com::telenav::proto::Context* context);

  // required string user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // required string data_set = 3;
  inline bool has_data_set() const;
  inline void clear_data_set();
  static const int kDataSetFieldNumber = 3;
  inline const ::std::string& data_set() const;
  inline void set_data_set(const ::std::string& value);
  inline void set_data_set(const char* value);
  inline void set_data_set(const char* value, size_t size);
  inline ::std::string* mutable_data_set();
  inline ::std::string* release_data_set();
  inline void set_allocated_data_set(::std::string* data_set);

  // optional int32 user_heading = 4;
  inline bool has_user_heading() const;
  inline void clear_user_heading();
  static const int kUserHeadingFieldNumber = 4;
  inline ::google::protobuf::int32 user_heading() const;
  inline void set_user_heading(::google::protobuf::int32 value);

  // optional int32 user_speed = 5;
  inline bool has_user_speed() const;
  inline void clear_user_speed();
  static const int kUserSpeedFieldNumber = 5;
  inline ::google::protobuf::int32 user_speed() const;
  inline void set_user_speed(::google::protobuf::int32 value);

  // required .com.telenav.proto.map.TrafficIncident traffic_incident = 6;
  inline bool has_traffic_incident() const;
  inline void clear_traffic_incident();
  static const int kTrafficIncidentFieldNumber = 6;
  inline const ::com::telenav::proto::map::TrafficIncident& traffic_incident() const;
  inline ::com::telenav::proto::map::TrafficIncident* mutable_traffic_incident();
  inline ::com::telenav::proto::map::TrafficIncident* release_traffic_incident();
  inline void set_allocated_traffic_incident(::com::telenav::proto::map::TrafficIncident* traffic_incident);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.ReportIncidentRequest)
 private:
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_data_set();
  inline void clear_has_data_set();
  inline void set_has_user_heading();
  inline void clear_has_user_heading();
  inline void set_has_user_speed();
  inline void clear_has_user_speed();
  inline void set_has_traffic_incident();
  inline void clear_has_traffic_incident();

  ::com::telenav::proto::Context* context_;
  ::std::string* user_id_;
  ::std::string* data_set_;
  ::google::protobuf::int32 user_heading_;
  ::google::protobuf::int32 user_speed_;
  ::com::telenav::proto::map::TrafficIncident* traffic_incident_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2etraffic_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2etraffic_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2etraffic_2eproto();
  friend void protobuf_ShutdownFile_map_2etraffic_2eproto();

  void InitAsDefaultInstance();
  static ReportIncidentRequest* default_instance_;
};
// -------------------------------------------------------------------

class TileId : public ::google::protobuf::MessageLite {
 public:
  TileId();
  virtual ~TileId();

  TileId(const TileId& from);

  inline TileId& operator=(const TileId& from) {
    CopyFrom(from);
    return *this;
  }

  static const TileId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TileId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TileId* other);

  // implements Message ----------------------------------------------

  TileId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TileId& from);
  void MergeFrom(const TileId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x_index = 1;
  inline bool has_x_index() const;
  inline void clear_x_index();
  static const int kXIndexFieldNumber = 1;
  inline ::google::protobuf::int32 x_index() const;
  inline void set_x_index(::google::protobuf::int32 value);

  // optional int32 y_index = 2;
  inline bool has_y_index() const;
  inline void clear_y_index();
  static const int kYIndexFieldNumber = 2;
  inline ::google::protobuf::int32 y_index() const;
  inline void set_y_index(::google::protobuf::int32 value);

  // optional int32 zoom_level = 3;
  inline bool has_zoom_level() const;
  inline void clear_zoom_level();
  static const int kZoomLevelFieldNumber = 3;
  inline ::google::protobuf::int32 zoom_level() const;
  inline void set_zoom_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.TileId)
 private:
  inline void set_has_x_index();
  inline void clear_has_x_index();
  inline void set_has_y_index();
  inline void clear_has_y_index();
  inline void set_has_zoom_level();
  inline void clear_has_zoom_level();

  ::google::protobuf::int32 x_index_;
  ::google::protobuf::int32 y_index_;
  ::google::protobuf::int32 zoom_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2etraffic_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2etraffic_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2etraffic_2eproto();
  friend void protobuf_ShutdownFile_map_2etraffic_2eproto();

  void InitAsDefaultInstance();
  static TileId* default_instance_;
};
// -------------------------------------------------------------------

class TrafficResponse : public ::google::protobuf::MessageLite {
 public:
  TrafficResponse();
  virtual ~TrafficResponse();

  TrafficResponse(const TrafficResponse& from);

  inline TrafficResponse& operator=(const TrafficResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrafficResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrafficResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrafficResponse* other);

  // implements Message ----------------------------------------------

  TrafficResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrafficResponse& from);
  void MergeFrom(const TrafficResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.ServiceStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::com::telenav::proto::ServiceStatus& status() const;
  inline ::com::telenav::proto::ServiceStatus* mutable_status();
  inline ::com::telenav::proto::ServiceStatus* release_status();
  inline void set_allocated_status(::com::telenav::proto::ServiceStatus* status);

  // repeated .com.telenav.proto.map.TrafficFlow traffic_flow = 2;
  inline int traffic_flow_size() const;
  inline void clear_traffic_flow();
  static const int kTrafficFlowFieldNumber = 2;
  inline const ::com::telenav::proto::map::TrafficFlow& traffic_flow(int index) const;
  inline ::com::telenav::proto::map::TrafficFlow* mutable_traffic_flow(int index);
  inline ::com::telenav::proto::map::TrafficFlow* add_traffic_flow();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficFlow >&
      traffic_flow() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficFlow >*
      mutable_traffic_flow();

  // repeated .com.telenav.proto.map.TrafficIncident traffic_incident = 3;
  inline int traffic_incident_size() const;
  inline void clear_traffic_incident();
  static const int kTrafficIncidentFieldNumber = 3;
  inline const ::com::telenav::proto::map::TrafficIncident& traffic_incident(int index) const;
  inline ::com::telenav::proto::map::TrafficIncident* mutable_traffic_incident(int index);
  inline ::com::telenav::proto::map::TrafficIncident* add_traffic_incident();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficIncident >&
      traffic_incident() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficIncident >*
      mutable_traffic_incident();

  // optional .com.telenav.proto.map.TileId tile_id = 4;
  inline bool has_tile_id() const;
  inline void clear_tile_id();
  static const int kTileIdFieldNumber = 4;
  inline const ::com::telenav::proto::map::TileId& tile_id() const;
  inline ::com::telenav::proto::map::TileId* mutable_tile_id();
  inline ::com::telenav::proto::map::TileId* release_tile_id();
  inline void set_allocated_tile_id(::com::telenav::proto::map::TileId* tile_id);

  // optional .com.telenav.proto.map.TrafficLevelDictionary dictionary = 5;
  inline bool has_dictionary() const;
  inline void clear_dictionary();
  static const int kDictionaryFieldNumber = 5;
  inline const ::com::telenav::proto::map::TrafficLevelDictionary& dictionary() const;
  inline ::com::telenav::proto::map::TrafficLevelDictionary* mutable_dictionary();
  inline ::com::telenav::proto::map::TrafficLevelDictionary* release_dictionary();
  inline void set_allocated_dictionary(::com::telenav::proto::map::TrafficLevelDictionary* dictionary);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.TrafficResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_tile_id();
  inline void clear_has_tile_id();
  inline void set_has_dictionary();
  inline void clear_has_dictionary();

  ::com::telenav::proto::ServiceStatus* status_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficFlow > traffic_flow_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficIncident > traffic_incident_;
  ::com::telenav::proto::map::TileId* tile_id_;
  ::com::telenav::proto::map::TrafficLevelDictionary* dictionary_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2etraffic_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2etraffic_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2etraffic_2eproto();
  friend void protobuf_ShutdownFile_map_2etraffic_2eproto();

  void InitAsDefaultInstance();
  static TrafficResponse* default_instance_;
};
// -------------------------------------------------------------------

class TrafficFlow : public ::google::protobuf::MessageLite {
 public:
  TrafficFlow();
  virtual ~TrafficFlow();

  TrafficFlow(const TrafficFlow& from);

  inline TrafficFlow& operator=(const TrafficFlow& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrafficFlow& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrafficFlow* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrafficFlow* other);

  // implements Message ----------------------------------------------

  TrafficFlow* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrafficFlow& from);
  void MergeFrom(const TrafficFlow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string traffic_id = 1;
  inline bool has_traffic_id() const;
  inline void clear_traffic_id();
  static const int kTrafficIdFieldNumber = 1;
  inline const ::std::string& traffic_id() const;
  inline void set_traffic_id(const ::std::string& value);
  inline void set_traffic_id(const char* value);
  inline void set_traffic_id(const char* value, size_t size);
  inline ::std::string* mutable_traffic_id();
  inline ::std::string* release_traffic_id();
  inline void set_allocated_traffic_id(::std::string* traffic_id);

  // optional double speed_in_mps = 2;
  inline bool has_speed_in_mps() const;
  inline void clear_speed_in_mps();
  static const int kSpeedInMpsFieldNumber = 2;
  inline double speed_in_mps() const;
  inline void set_speed_in_mps(double value);

  // optional int32 traffic_level = 3;
  inline bool has_traffic_level() const;
  inline void clear_traffic_level();
  static const int kTrafficLevelFieldNumber = 3;
  inline ::google::protobuf::int32 traffic_level() const;
  inline void set_traffic_level(::google::protobuf::int32 value);

  // optional int64 report_time = 4;
  inline bool has_report_time() const;
  inline void clear_report_time();
  static const int kReportTimeFieldNumber = 4;
  inline ::google::protobuf::int64 report_time() const;
  inline void set_report_time(::google::protobuf::int64 value);

  // optional double free_flow_speed_in_mps = 5;
  inline bool has_free_flow_speed_in_mps() const;
  inline void clear_free_flow_speed_in_mps();
  static const int kFreeFlowSpeedInMpsFieldNumber = 5;
  inline double free_flow_speed_in_mps() const;
  inline void set_free_flow_speed_in_mps(double value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.TrafficFlow)
 private:
  inline void set_has_traffic_id();
  inline void clear_has_traffic_id();
  inline void set_has_speed_in_mps();
  inline void clear_has_speed_in_mps();
  inline void set_has_traffic_level();
  inline void clear_has_traffic_level();
  inline void set_has_report_time();
  inline void clear_has_report_time();
  inline void set_has_free_flow_speed_in_mps();
  inline void clear_has_free_flow_speed_in_mps();

  ::std::string* traffic_id_;
  double speed_in_mps_;
  ::google::protobuf::int64 report_time_;
  double free_flow_speed_in_mps_;
  ::google::protobuf::int32 traffic_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2etraffic_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2etraffic_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2etraffic_2eproto();
  friend void protobuf_ShutdownFile_map_2etraffic_2eproto();

  void InitAsDefaultInstance();
  static TrafficFlow* default_instance_;
};
// -------------------------------------------------------------------

class TrafficIncident : public ::google::protobuf::MessageLite {
 public:
  TrafficIncident();
  virtual ~TrafficIncident();

  TrafficIncident(const TrafficIncident& from);

  inline TrafficIncident& operator=(const TrafficIncident& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrafficIncident& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrafficIncident* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrafficIncident* other);

  // implements Message ----------------------------------------------

  TrafficIncident* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrafficIncident& from);
  void MergeFrom(const TrafficIncident& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string traffic_id = 1;
  inline int traffic_id_size() const;
  inline void clear_traffic_id();
  static const int kTrafficIdFieldNumber = 1;
  inline const ::std::string& traffic_id(int index) const;
  inline ::std::string* mutable_traffic_id(int index);
  inline void set_traffic_id(int index, const ::std::string& value);
  inline void set_traffic_id(int index, const char* value);
  inline void set_traffic_id(int index, const char* value, size_t size);
  inline ::std::string* add_traffic_id();
  inline void add_traffic_id(const ::std::string& value);
  inline void add_traffic_id(const char* value);
  inline void add_traffic_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& traffic_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_traffic_id();

  // optional string incident_type = 2;
  inline bool has_incident_type() const;
  inline void clear_incident_type();
  static const int kIncidentTypeFieldNumber = 2;
  inline const ::std::string& incident_type() const;
  inline void set_incident_type(const ::std::string& value);
  inline void set_incident_type(const char* value);
  inline void set_incident_type(const char* value, size_t size);
  inline ::std::string* mutable_incident_type();
  inline ::std::string* release_incident_type();
  inline void set_allocated_incident_type(::std::string* incident_type);

  // optional .com.telenav.proto.map.Severity incident_severity = 3;
  inline bool has_incident_severity() const;
  inline void clear_incident_severity();
  static const int kIncidentSeverityFieldNumber = 3;
  inline ::com::telenav::proto::map::Severity incident_severity() const;
  inline void set_incident_severity(::com::telenav::proto::map::Severity value);

  // optional .com.telenav.proto.LatLon incident_location = 4;
  inline bool has_incident_location() const;
  inline void clear_incident_location();
  static const int kIncidentLocationFieldNumber = 4;
  inline const ::com::telenav::proto::LatLon& incident_location() const;
  inline ::com::telenav::proto::LatLon* mutable_incident_location();
  inline ::com::telenav::proto::LatLon* release_incident_location();
  inline void set_allocated_incident_location(::com::telenav::proto::LatLon* incident_location);

  // optional string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string street_name = 6;
  inline bool has_street_name() const;
  inline void clear_street_name();
  static const int kStreetNameFieldNumber = 6;
  inline const ::std::string& street_name() const;
  inline void set_street_name(const ::std::string& value);
  inline void set_street_name(const char* value);
  inline void set_street_name(const char* value, size_t size);
  inline ::std::string* mutable_street_name();
  inline ::std::string* release_street_name();
  inline void set_allocated_street_name(::std::string* street_name);

  // optional string first_cross_street = 7;
  inline bool has_first_cross_street() const;
  inline void clear_first_cross_street();
  static const int kFirstCrossStreetFieldNumber = 7;
  inline const ::std::string& first_cross_street() const;
  inline void set_first_cross_street(const ::std::string& value);
  inline void set_first_cross_street(const char* value);
  inline void set_first_cross_street(const char* value, size_t size);
  inline ::std::string* mutable_first_cross_street();
  inline ::std::string* release_first_cross_street();
  inline void set_allocated_first_cross_street(::std::string* first_cross_street);

  // optional string second_cross_street = 8;
  inline bool has_second_cross_street() const;
  inline void clear_second_cross_street();
  static const int kSecondCrossStreetFieldNumber = 8;
  inline const ::std::string& second_cross_street() const;
  inline void set_second_cross_street(const ::std::string& value);
  inline void set_second_cross_street(const char* value);
  inline void set_second_cross_street(const char* value, size_t size);
  inline ::std::string* mutable_second_cross_street();
  inline ::std::string* release_second_cross_street();
  inline void set_allocated_second_cross_street(::std::string* second_cross_street);

  // optional int32 event_code = 9;
  inline bool has_event_code() const;
  inline void clear_event_code();
  static const int kEventCodeFieldNumber = 9;
  inline ::google::protobuf::int32 event_code() const;
  inline void set_event_code(::google::protobuf::int32 value);

  // optional int64 end_time = 10;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 10;
  inline ::google::protobuf::int64 end_time() const;
  inline void set_end_time(::google::protobuf::int64 value);

  // optional int32 speed = 11;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 11;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional bool is_blocking = 12;
  inline bool has_is_blocking() const;
  inline void clear_is_blocking();
  static const int kIsBlockingFieldNumber = 12;
  inline bool is_blocking() const;
  inline void set_is_blocking(bool value);

  // repeated string edge_id = 14;
  inline int edge_id_size() const;
  inline void clear_edge_id();
  static const int kEdgeIdFieldNumber = 14;
  inline const ::std::string& edge_id(int index) const;
  inline ::std::string* mutable_edge_id(int index);
  inline void set_edge_id(int index, const ::std::string& value);
  inline void set_edge_id(int index, const char* value);
  inline void set_edge_id(int index, const char* value, size_t size);
  inline ::std::string* add_edge_id();
  inline void add_edge_id(const ::std::string& value);
  inline void add_edge_id(const char* value);
  inline void add_edge_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& edge_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_edge_id();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.TrafficIncident)
 private:
  inline void set_has_incident_type();
  inline void clear_has_incident_type();
  inline void set_has_incident_severity();
  inline void clear_has_incident_severity();
  inline void set_has_incident_location();
  inline void clear_has_incident_location();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_street_name();
  inline void clear_has_street_name();
  inline void set_has_first_cross_street();
  inline void clear_has_first_cross_street();
  inline void set_has_second_cross_street();
  inline void clear_has_second_cross_street();
  inline void set_has_event_code();
  inline void clear_has_event_code();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_is_blocking();
  inline void clear_has_is_blocking();

  ::google::protobuf::RepeatedPtrField< ::std::string> traffic_id_;
  ::std::string* incident_type_;
  ::com::telenav::proto::LatLon* incident_location_;
  ::std::string* description_;
  ::std::string* street_name_;
  int incident_severity_;
  ::google::protobuf::int32 event_code_;
  ::std::string* first_cross_street_;
  ::std::string* second_cross_street_;
  ::google::protobuf::int64 end_time_;
  ::google::protobuf::int32 speed_;
  bool is_blocking_;
  ::google::protobuf::RepeatedPtrField< ::std::string> edge_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2etraffic_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2etraffic_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2etraffic_2eproto();
  friend void protobuf_ShutdownFile_map_2etraffic_2eproto();

  void InitAsDefaultInstance();
  static TrafficIncident* default_instance_;
};
// -------------------------------------------------------------------

class TrafficLevelDictionary : public ::google::protobuf::MessageLite {
 public:
  TrafficLevelDictionary();
  virtual ~TrafficLevelDictionary();

  TrafficLevelDictionary(const TrafficLevelDictionary& from);

  inline TrafficLevelDictionary& operator=(const TrafficLevelDictionary& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrafficLevelDictionary& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrafficLevelDictionary* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrafficLevelDictionary* other);

  // implements Message ----------------------------------------------

  TrafficLevelDictionary* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrafficLevelDictionary& from);
  void MergeFrom(const TrafficLevelDictionary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.telenav.proto.map.TrafficLevelPair level_pairs = 1;
  inline int level_pairs_size() const;
  inline void clear_level_pairs();
  static const int kLevelPairsFieldNumber = 1;
  inline const ::com::telenav::proto::map::TrafficLevelPair& level_pairs(int index) const;
  inline ::com::telenav::proto::map::TrafficLevelPair* mutable_level_pairs(int index);
  inline ::com::telenav::proto::map::TrafficLevelPair* add_level_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficLevelPair >&
      level_pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficLevelPair >*
      mutable_level_pairs();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.TrafficLevelDictionary)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficLevelPair > level_pairs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2etraffic_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2etraffic_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2etraffic_2eproto();
  friend void protobuf_ShutdownFile_map_2etraffic_2eproto();

  void InitAsDefaultInstance();
  static TrafficLevelDictionary* default_instance_;
};
// -------------------------------------------------------------------

class TrafficLevelPair : public ::google::protobuf::MessageLite {
 public:
  TrafficLevelPair();
  virtual ~TrafficLevelPair();

  TrafficLevelPair(const TrafficLevelPair& from);

  inline TrafficLevelPair& operator=(const TrafficLevelPair& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrafficLevelPair& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrafficLevelPair* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrafficLevelPair* other);

  // implements Message ----------------------------------------------

  TrafficLevelPair* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrafficLevelPair& from);
  void MergeFrom(const TrafficLevelPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 traffic_level_id = 1;
  inline bool has_traffic_level_id() const;
  inline void clear_traffic_level_id();
  static const int kTrafficLevelIdFieldNumber = 1;
  inline ::google::protobuf::int32 traffic_level_id() const;
  inline void set_traffic_level_id(::google::protobuf::int32 value);

  // optional string traffic_level_str = 2;
  inline bool has_traffic_level_str() const;
  inline void clear_traffic_level_str();
  static const int kTrafficLevelStrFieldNumber = 2;
  inline const ::std::string& traffic_level_str() const;
  inline void set_traffic_level_str(const ::std::string& value);
  inline void set_traffic_level_str(const char* value);
  inline void set_traffic_level_str(const char* value, size_t size);
  inline ::std::string* mutable_traffic_level_str();
  inline ::std::string* release_traffic_level_str();
  inline void set_allocated_traffic_level_str(::std::string* traffic_level_str);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.TrafficLevelPair)
 private:
  inline void set_has_traffic_level_id();
  inline void clear_has_traffic_level_id();
  inline void set_has_traffic_level_str();
  inline void clear_has_traffic_level_str();

  ::std::string* traffic_level_str_;
  ::google::protobuf::int32 traffic_level_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2etraffic_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2etraffic_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2etraffic_2eproto();
  friend void protobuf_ShutdownFile_map_2etraffic_2eproto();

  void InitAsDefaultInstance();
  static TrafficLevelPair* default_instance_;
};
// ===================================================================


// ===================================================================

// TrafficRequest

// required .com.telenav.proto.map.TrafficRequest.Type type = 1;
inline bool TrafficRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::com::telenav::proto::map::TrafficRequest_Type TrafficRequest::type() const {
  return static_cast< ::com::telenav::proto::map::TrafficRequest_Type >(type_);
}
inline void TrafficRequest::set_type(::com::telenav::proto::map::TrafficRequest_Type value) {
  assert(::com::telenav::proto::map::TrafficRequest_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated string traffic_id = 2;
inline int TrafficRequest::traffic_id_size() const {
  return traffic_id_.size();
}
inline void TrafficRequest::clear_traffic_id() {
  traffic_id_.Clear();
}
inline const ::std::string& TrafficRequest::traffic_id(int index) const {
  return traffic_id_.Get(index);
}
inline ::std::string* TrafficRequest::mutable_traffic_id(int index) {
  return traffic_id_.Mutable(index);
}
inline void TrafficRequest::set_traffic_id(int index, const ::std::string& value) {
  traffic_id_.Mutable(index)->assign(value);
}
inline void TrafficRequest::set_traffic_id(int index, const char* value) {
  traffic_id_.Mutable(index)->assign(value);
}
inline void TrafficRequest::set_traffic_id(int index, const char* value, size_t size) {
  traffic_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficRequest::add_traffic_id() {
  return traffic_id_.Add();
}
inline void TrafficRequest::add_traffic_id(const ::std::string& value) {
  traffic_id_.Add()->assign(value);
}
inline void TrafficRequest::add_traffic_id(const char* value) {
  traffic_id_.Add()->assign(value);
}
inline void TrafficRequest::add_traffic_id(const char* value, size_t size) {
  traffic_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TrafficRequest::traffic_id() const {
  return traffic_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TrafficRequest::mutable_traffic_id() {
  return &traffic_id_;
}

// optional .com.telenav.proto.map.TileId tile_id = 3;
inline bool TrafficRequest::has_tile_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficRequest::set_has_tile_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficRequest::clear_has_tile_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficRequest::clear_tile_id() {
  if (tile_id_ != NULL) tile_id_->::com::telenav::proto::map::TileId::Clear();
  clear_has_tile_id();
}
inline const ::com::telenav::proto::map::TileId& TrafficRequest::tile_id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tile_id_ != NULL ? *tile_id_ : *default_instance().tile_id_;
#else
  return tile_id_ != NULL ? *tile_id_ : *default_instance_->tile_id_;
#endif
}
inline ::com::telenav::proto::map::TileId* TrafficRequest::mutable_tile_id() {
  set_has_tile_id();
  if (tile_id_ == NULL) tile_id_ = new ::com::telenav::proto::map::TileId;
  return tile_id_;
}
inline ::com::telenav::proto::map::TileId* TrafficRequest::release_tile_id() {
  clear_has_tile_id();
  ::com::telenav::proto::map::TileId* temp = tile_id_;
  tile_id_ = NULL;
  return temp;
}
inline void TrafficRequest::set_allocated_tile_id(::com::telenav::proto::map::TileId* tile_id) {
  delete tile_id_;
  tile_id_ = tile_id;
  if (tile_id) {
    set_has_tile_id();
  } else {
    clear_has_tile_id();
  }
}

// optional .com.telenav.proto.Context context = 4;
inline bool TrafficRequest::has_context() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficRequest::set_has_context() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficRequest::clear_has_context() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficRequest::clear_context() {
  if (context_ != NULL) context_->::com::telenav::proto::Context::Clear();
  clear_has_context();
}
inline const ::com::telenav::proto::Context& TrafficRequest::context() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return context_ != NULL ? *context_ : *default_instance().context_;
#else
  return context_ != NULL ? *context_ : *default_instance_->context_;
#endif
}
inline ::com::telenav::proto::Context* TrafficRequest::mutable_context() {
  set_has_context();
  if (context_ == NULL) context_ = new ::com::telenav::proto::Context;
  return context_;
}
inline ::com::telenav::proto::Context* TrafficRequest::release_context() {
  clear_has_context();
  ::com::telenav::proto::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline void TrafficRequest::set_allocated_context(::com::telenav::proto::Context* context) {
  delete context_;
  context_ = context;
  if (context) {
    set_has_context();
  } else {
    clear_has_context();
  }
}

// optional string data_set = 5;
inline bool TrafficRequest::has_data_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficRequest::set_has_data_set() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficRequest::clear_has_data_set() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficRequest::clear_data_set() {
  if (data_set_ != &::google::protobuf::internal::kEmptyString) {
    data_set_->clear();
  }
  clear_has_data_set();
}
inline const ::std::string& TrafficRequest::data_set() const {
  return *data_set_;
}
inline void TrafficRequest::set_data_set(const ::std::string& value) {
  set_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    data_set_ = new ::std::string;
  }
  data_set_->assign(value);
}
inline void TrafficRequest::set_data_set(const char* value) {
  set_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    data_set_ = new ::std::string;
  }
  data_set_->assign(value);
}
inline void TrafficRequest::set_data_set(const char* value, size_t size) {
  set_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    data_set_ = new ::std::string;
  }
  data_set_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficRequest::mutable_data_set() {
  set_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    data_set_ = new ::std::string;
  }
  return data_set_;
}
inline ::std::string* TrafficRequest::release_data_set() {
  clear_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_set_;
    data_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrafficRequest::set_allocated_data_set(::std::string* data_set) {
  if (data_set_ != &::google::protobuf::internal::kEmptyString) {
    delete data_set_;
  }
  if (data_set) {
    set_has_data_set();
    data_set_ = data_set;
  } else {
    clear_has_data_set();
    data_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string flow_data_src = 6;
inline bool TrafficRequest::has_flow_data_src() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrafficRequest::set_has_flow_data_src() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrafficRequest::clear_has_flow_data_src() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrafficRequest::clear_flow_data_src() {
  if (flow_data_src_ != &::google::protobuf::internal::kEmptyString) {
    flow_data_src_->clear();
  }
  clear_has_flow_data_src();
}
inline const ::std::string& TrafficRequest::flow_data_src() const {
  return *flow_data_src_;
}
inline void TrafficRequest::set_flow_data_src(const ::std::string& value) {
  set_has_flow_data_src();
  if (flow_data_src_ == &::google::protobuf::internal::kEmptyString) {
    flow_data_src_ = new ::std::string;
  }
  flow_data_src_->assign(value);
}
inline void TrafficRequest::set_flow_data_src(const char* value) {
  set_has_flow_data_src();
  if (flow_data_src_ == &::google::protobuf::internal::kEmptyString) {
    flow_data_src_ = new ::std::string;
  }
  flow_data_src_->assign(value);
}
inline void TrafficRequest::set_flow_data_src(const char* value, size_t size) {
  set_has_flow_data_src();
  if (flow_data_src_ == &::google::protobuf::internal::kEmptyString) {
    flow_data_src_ = new ::std::string;
  }
  flow_data_src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficRequest::mutable_flow_data_src() {
  set_has_flow_data_src();
  if (flow_data_src_ == &::google::protobuf::internal::kEmptyString) {
    flow_data_src_ = new ::std::string;
  }
  return flow_data_src_;
}
inline ::std::string* TrafficRequest::release_flow_data_src() {
  clear_has_flow_data_src();
  if (flow_data_src_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flow_data_src_;
    flow_data_src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrafficRequest::set_allocated_flow_data_src(::std::string* flow_data_src) {
  if (flow_data_src_ != &::google::protobuf::internal::kEmptyString) {
    delete flow_data_src_;
  }
  if (flow_data_src) {
    set_has_flow_data_src();
    flow_data_src_ = flow_data_src;
  } else {
    clear_has_flow_data_src();
    flow_data_src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alert_data_src = 7;
inline bool TrafficRequest::has_alert_data_src() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrafficRequest::set_has_alert_data_src() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrafficRequest::clear_has_alert_data_src() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrafficRequest::clear_alert_data_src() {
  if (alert_data_src_ != &::google::protobuf::internal::kEmptyString) {
    alert_data_src_->clear();
  }
  clear_has_alert_data_src();
}
inline const ::std::string& TrafficRequest::alert_data_src() const {
  return *alert_data_src_;
}
inline void TrafficRequest::set_alert_data_src(const ::std::string& value) {
  set_has_alert_data_src();
  if (alert_data_src_ == &::google::protobuf::internal::kEmptyString) {
    alert_data_src_ = new ::std::string;
  }
  alert_data_src_->assign(value);
}
inline void TrafficRequest::set_alert_data_src(const char* value) {
  set_has_alert_data_src();
  if (alert_data_src_ == &::google::protobuf::internal::kEmptyString) {
    alert_data_src_ = new ::std::string;
  }
  alert_data_src_->assign(value);
}
inline void TrafficRequest::set_alert_data_src(const char* value, size_t size) {
  set_has_alert_data_src();
  if (alert_data_src_ == &::google::protobuf::internal::kEmptyString) {
    alert_data_src_ = new ::std::string;
  }
  alert_data_src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficRequest::mutable_alert_data_src() {
  set_has_alert_data_src();
  if (alert_data_src_ == &::google::protobuf::internal::kEmptyString) {
    alert_data_src_ = new ::std::string;
  }
  return alert_data_src_;
}
inline ::std::string* TrafficRequest::release_alert_data_src() {
  clear_has_alert_data_src();
  if (alert_data_src_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alert_data_src_;
    alert_data_src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrafficRequest::set_allocated_alert_data_src(::std::string* alert_data_src) {
  if (alert_data_src_ != &::google::protobuf::internal::kEmptyString) {
    delete alert_data_src_;
  }
  if (alert_data_src) {
    set_has_alert_data_src();
    alert_data_src_ = alert_data_src;
  } else {
    clear_has_alert_data_src();
    alert_data_src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReportIncidentRequest

// optional .com.telenav.proto.Context context = 1;
inline bool ReportIncidentRequest::has_context() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportIncidentRequest::set_has_context() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportIncidentRequest::clear_has_context() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportIncidentRequest::clear_context() {
  if (context_ != NULL) context_->::com::telenav::proto::Context::Clear();
  clear_has_context();
}
inline const ::com::telenav::proto::Context& ReportIncidentRequest::context() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return context_ != NULL ? *context_ : *default_instance().context_;
#else
  return context_ != NULL ? *context_ : *default_instance_->context_;
#endif
}
inline ::com::telenav::proto::Context* ReportIncidentRequest::mutable_context() {
  set_has_context();
  if (context_ == NULL) context_ = new ::com::telenav::proto::Context;
  return context_;
}
inline ::com::telenav::proto::Context* ReportIncidentRequest::release_context() {
  clear_has_context();
  ::com::telenav::proto::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline void ReportIncidentRequest::set_allocated_context(::com::telenav::proto::Context* context) {
  delete context_;
  context_ = context;
  if (context) {
    set_has_context();
  } else {
    clear_has_context();
  }
}

// required string user_id = 2;
inline bool ReportIncidentRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportIncidentRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportIncidentRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportIncidentRequest::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& ReportIncidentRequest::user_id() const {
  return *user_id_;
}
inline void ReportIncidentRequest::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void ReportIncidentRequest::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void ReportIncidentRequest::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReportIncidentRequest::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* ReportIncidentRequest::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReportIncidentRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string data_set = 3;
inline bool ReportIncidentRequest::has_data_set() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReportIncidentRequest::set_has_data_set() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReportIncidentRequest::clear_has_data_set() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReportIncidentRequest::clear_data_set() {
  if (data_set_ != &::google::protobuf::internal::kEmptyString) {
    data_set_->clear();
  }
  clear_has_data_set();
}
inline const ::std::string& ReportIncidentRequest::data_set() const {
  return *data_set_;
}
inline void ReportIncidentRequest::set_data_set(const ::std::string& value) {
  set_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    data_set_ = new ::std::string;
  }
  data_set_->assign(value);
}
inline void ReportIncidentRequest::set_data_set(const char* value) {
  set_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    data_set_ = new ::std::string;
  }
  data_set_->assign(value);
}
inline void ReportIncidentRequest::set_data_set(const char* value, size_t size) {
  set_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    data_set_ = new ::std::string;
  }
  data_set_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReportIncidentRequest::mutable_data_set() {
  set_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    data_set_ = new ::std::string;
  }
  return data_set_;
}
inline ::std::string* ReportIncidentRequest::release_data_set() {
  clear_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_set_;
    data_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReportIncidentRequest::set_allocated_data_set(::std::string* data_set) {
  if (data_set_ != &::google::protobuf::internal::kEmptyString) {
    delete data_set_;
  }
  if (data_set) {
    set_has_data_set();
    data_set_ = data_set;
  } else {
    clear_has_data_set();
    data_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 user_heading = 4;
inline bool ReportIncidentRequest::has_user_heading() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReportIncidentRequest::set_has_user_heading() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReportIncidentRequest::clear_has_user_heading() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReportIncidentRequest::clear_user_heading() {
  user_heading_ = 0;
  clear_has_user_heading();
}
inline ::google::protobuf::int32 ReportIncidentRequest::user_heading() const {
  return user_heading_;
}
inline void ReportIncidentRequest::set_user_heading(::google::protobuf::int32 value) {
  set_has_user_heading();
  user_heading_ = value;
}

// optional int32 user_speed = 5;
inline bool ReportIncidentRequest::has_user_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReportIncidentRequest::set_has_user_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReportIncidentRequest::clear_has_user_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReportIncidentRequest::clear_user_speed() {
  user_speed_ = 0;
  clear_has_user_speed();
}
inline ::google::protobuf::int32 ReportIncidentRequest::user_speed() const {
  return user_speed_;
}
inline void ReportIncidentRequest::set_user_speed(::google::protobuf::int32 value) {
  set_has_user_speed();
  user_speed_ = value;
}

// required .com.telenav.proto.map.TrafficIncident traffic_incident = 6;
inline bool ReportIncidentRequest::has_traffic_incident() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReportIncidentRequest::set_has_traffic_incident() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReportIncidentRequest::clear_has_traffic_incident() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReportIncidentRequest::clear_traffic_incident() {
  if (traffic_incident_ != NULL) traffic_incident_->::com::telenav::proto::map::TrafficIncident::Clear();
  clear_has_traffic_incident();
}
inline const ::com::telenav::proto::map::TrafficIncident& ReportIncidentRequest::traffic_incident() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return traffic_incident_ != NULL ? *traffic_incident_ : *default_instance().traffic_incident_;
#else
  return traffic_incident_ != NULL ? *traffic_incident_ : *default_instance_->traffic_incident_;
#endif
}
inline ::com::telenav::proto::map::TrafficIncident* ReportIncidentRequest::mutable_traffic_incident() {
  set_has_traffic_incident();
  if (traffic_incident_ == NULL) traffic_incident_ = new ::com::telenav::proto::map::TrafficIncident;
  return traffic_incident_;
}
inline ::com::telenav::proto::map::TrafficIncident* ReportIncidentRequest::release_traffic_incident() {
  clear_has_traffic_incident();
  ::com::telenav::proto::map::TrafficIncident* temp = traffic_incident_;
  traffic_incident_ = NULL;
  return temp;
}
inline void ReportIncidentRequest::set_allocated_traffic_incident(::com::telenav::proto::map::TrafficIncident* traffic_incident) {
  delete traffic_incident_;
  traffic_incident_ = traffic_incident;
  if (traffic_incident) {
    set_has_traffic_incident();
  } else {
    clear_has_traffic_incident();
  }
}

// -------------------------------------------------------------------

// TileId

// optional int32 x_index = 1;
inline bool TileId::has_x_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TileId::set_has_x_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TileId::clear_has_x_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TileId::clear_x_index() {
  x_index_ = 0;
  clear_has_x_index();
}
inline ::google::protobuf::int32 TileId::x_index() const {
  return x_index_;
}
inline void TileId::set_x_index(::google::protobuf::int32 value) {
  set_has_x_index();
  x_index_ = value;
}

// optional int32 y_index = 2;
inline bool TileId::has_y_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TileId::set_has_y_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TileId::clear_has_y_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TileId::clear_y_index() {
  y_index_ = 0;
  clear_has_y_index();
}
inline ::google::protobuf::int32 TileId::y_index() const {
  return y_index_;
}
inline void TileId::set_y_index(::google::protobuf::int32 value) {
  set_has_y_index();
  y_index_ = value;
}

// optional int32 zoom_level = 3;
inline bool TileId::has_zoom_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TileId::set_has_zoom_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TileId::clear_has_zoom_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TileId::clear_zoom_level() {
  zoom_level_ = 0;
  clear_has_zoom_level();
}
inline ::google::protobuf::int32 TileId::zoom_level() const {
  return zoom_level_;
}
inline void TileId::set_zoom_level(::google::protobuf::int32 value) {
  set_has_zoom_level();
  zoom_level_ = value;
}

// -------------------------------------------------------------------

// TrafficResponse

// optional .com.telenav.proto.ServiceStatus status = 1;
inline bool TrafficResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficResponse::clear_status() {
  if (status_ != NULL) status_->::com::telenav::proto::ServiceStatus::Clear();
  clear_has_status();
}
inline const ::com::telenav::proto::ServiceStatus& TrafficResponse::status() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return status_ != NULL ? *status_ : *default_instance().status_;
#else
  return status_ != NULL ? *status_ : *default_instance_->status_;
#endif
}
inline ::com::telenav::proto::ServiceStatus* TrafficResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::com::telenav::proto::ServiceStatus;
  return status_;
}
inline ::com::telenav::proto::ServiceStatus* TrafficResponse::release_status() {
  clear_has_status();
  ::com::telenav::proto::ServiceStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void TrafficResponse::set_allocated_status(::com::telenav::proto::ServiceStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// repeated .com.telenav.proto.map.TrafficFlow traffic_flow = 2;
inline int TrafficResponse::traffic_flow_size() const {
  return traffic_flow_.size();
}
inline void TrafficResponse::clear_traffic_flow() {
  traffic_flow_.Clear();
}
inline const ::com::telenav::proto::map::TrafficFlow& TrafficResponse::traffic_flow(int index) const {
  return traffic_flow_.Get(index);
}
inline ::com::telenav::proto::map::TrafficFlow* TrafficResponse::mutable_traffic_flow(int index) {
  return traffic_flow_.Mutable(index);
}
inline ::com::telenav::proto::map::TrafficFlow* TrafficResponse::add_traffic_flow() {
  return traffic_flow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficFlow >&
TrafficResponse::traffic_flow() const {
  return traffic_flow_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficFlow >*
TrafficResponse::mutable_traffic_flow() {
  return &traffic_flow_;
}

// repeated .com.telenav.proto.map.TrafficIncident traffic_incident = 3;
inline int TrafficResponse::traffic_incident_size() const {
  return traffic_incident_.size();
}
inline void TrafficResponse::clear_traffic_incident() {
  traffic_incident_.Clear();
}
inline const ::com::telenav::proto::map::TrafficIncident& TrafficResponse::traffic_incident(int index) const {
  return traffic_incident_.Get(index);
}
inline ::com::telenav::proto::map::TrafficIncident* TrafficResponse::mutable_traffic_incident(int index) {
  return traffic_incident_.Mutable(index);
}
inline ::com::telenav::proto::map::TrafficIncident* TrafficResponse::add_traffic_incident() {
  return traffic_incident_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficIncident >&
TrafficResponse::traffic_incident() const {
  return traffic_incident_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficIncident >*
TrafficResponse::mutable_traffic_incident() {
  return &traffic_incident_;
}

// optional .com.telenav.proto.map.TileId tile_id = 4;
inline bool TrafficResponse::has_tile_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficResponse::set_has_tile_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficResponse::clear_has_tile_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficResponse::clear_tile_id() {
  if (tile_id_ != NULL) tile_id_->::com::telenav::proto::map::TileId::Clear();
  clear_has_tile_id();
}
inline const ::com::telenav::proto::map::TileId& TrafficResponse::tile_id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tile_id_ != NULL ? *tile_id_ : *default_instance().tile_id_;
#else
  return tile_id_ != NULL ? *tile_id_ : *default_instance_->tile_id_;
#endif
}
inline ::com::telenav::proto::map::TileId* TrafficResponse::mutable_tile_id() {
  set_has_tile_id();
  if (tile_id_ == NULL) tile_id_ = new ::com::telenav::proto::map::TileId;
  return tile_id_;
}
inline ::com::telenav::proto::map::TileId* TrafficResponse::release_tile_id() {
  clear_has_tile_id();
  ::com::telenav::proto::map::TileId* temp = tile_id_;
  tile_id_ = NULL;
  return temp;
}
inline void TrafficResponse::set_allocated_tile_id(::com::telenav::proto::map::TileId* tile_id) {
  delete tile_id_;
  tile_id_ = tile_id;
  if (tile_id) {
    set_has_tile_id();
  } else {
    clear_has_tile_id();
  }
}

// optional .com.telenav.proto.map.TrafficLevelDictionary dictionary = 5;
inline bool TrafficResponse::has_dictionary() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficResponse::set_has_dictionary() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficResponse::clear_has_dictionary() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficResponse::clear_dictionary() {
  if (dictionary_ != NULL) dictionary_->::com::telenav::proto::map::TrafficLevelDictionary::Clear();
  clear_has_dictionary();
}
inline const ::com::telenav::proto::map::TrafficLevelDictionary& TrafficResponse::dictionary() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dictionary_ != NULL ? *dictionary_ : *default_instance().dictionary_;
#else
  return dictionary_ != NULL ? *dictionary_ : *default_instance_->dictionary_;
#endif
}
inline ::com::telenav::proto::map::TrafficLevelDictionary* TrafficResponse::mutable_dictionary() {
  set_has_dictionary();
  if (dictionary_ == NULL) dictionary_ = new ::com::telenav::proto::map::TrafficLevelDictionary;
  return dictionary_;
}
inline ::com::telenav::proto::map::TrafficLevelDictionary* TrafficResponse::release_dictionary() {
  clear_has_dictionary();
  ::com::telenav::proto::map::TrafficLevelDictionary* temp = dictionary_;
  dictionary_ = NULL;
  return temp;
}
inline void TrafficResponse::set_allocated_dictionary(::com::telenav::proto::map::TrafficLevelDictionary* dictionary) {
  delete dictionary_;
  dictionary_ = dictionary;
  if (dictionary) {
    set_has_dictionary();
  } else {
    clear_has_dictionary();
  }
}

// -------------------------------------------------------------------

// TrafficFlow

// optional string traffic_id = 1;
inline bool TrafficFlow::has_traffic_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficFlow::set_has_traffic_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficFlow::clear_has_traffic_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficFlow::clear_traffic_id() {
  if (traffic_id_ != &::google::protobuf::internal::kEmptyString) {
    traffic_id_->clear();
  }
  clear_has_traffic_id();
}
inline const ::std::string& TrafficFlow::traffic_id() const {
  return *traffic_id_;
}
inline void TrafficFlow::set_traffic_id(const ::std::string& value) {
  set_has_traffic_id();
  if (traffic_id_ == &::google::protobuf::internal::kEmptyString) {
    traffic_id_ = new ::std::string;
  }
  traffic_id_->assign(value);
}
inline void TrafficFlow::set_traffic_id(const char* value) {
  set_has_traffic_id();
  if (traffic_id_ == &::google::protobuf::internal::kEmptyString) {
    traffic_id_ = new ::std::string;
  }
  traffic_id_->assign(value);
}
inline void TrafficFlow::set_traffic_id(const char* value, size_t size) {
  set_has_traffic_id();
  if (traffic_id_ == &::google::protobuf::internal::kEmptyString) {
    traffic_id_ = new ::std::string;
  }
  traffic_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficFlow::mutable_traffic_id() {
  set_has_traffic_id();
  if (traffic_id_ == &::google::protobuf::internal::kEmptyString) {
    traffic_id_ = new ::std::string;
  }
  return traffic_id_;
}
inline ::std::string* TrafficFlow::release_traffic_id() {
  clear_has_traffic_id();
  if (traffic_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = traffic_id_;
    traffic_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrafficFlow::set_allocated_traffic_id(::std::string* traffic_id) {
  if (traffic_id_ != &::google::protobuf::internal::kEmptyString) {
    delete traffic_id_;
  }
  if (traffic_id) {
    set_has_traffic_id();
    traffic_id_ = traffic_id;
  } else {
    clear_has_traffic_id();
    traffic_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double speed_in_mps = 2;
inline bool TrafficFlow::has_speed_in_mps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficFlow::set_has_speed_in_mps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficFlow::clear_has_speed_in_mps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficFlow::clear_speed_in_mps() {
  speed_in_mps_ = 0;
  clear_has_speed_in_mps();
}
inline double TrafficFlow::speed_in_mps() const {
  return speed_in_mps_;
}
inline void TrafficFlow::set_speed_in_mps(double value) {
  set_has_speed_in_mps();
  speed_in_mps_ = value;
}

// optional int32 traffic_level = 3;
inline bool TrafficFlow::has_traffic_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficFlow::set_has_traffic_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficFlow::clear_has_traffic_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficFlow::clear_traffic_level() {
  traffic_level_ = 0;
  clear_has_traffic_level();
}
inline ::google::protobuf::int32 TrafficFlow::traffic_level() const {
  return traffic_level_;
}
inline void TrafficFlow::set_traffic_level(::google::protobuf::int32 value) {
  set_has_traffic_level();
  traffic_level_ = value;
}

// optional int64 report_time = 4;
inline bool TrafficFlow::has_report_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficFlow::set_has_report_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficFlow::clear_has_report_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficFlow::clear_report_time() {
  report_time_ = GOOGLE_LONGLONG(0);
  clear_has_report_time();
}
inline ::google::protobuf::int64 TrafficFlow::report_time() const {
  return report_time_;
}
inline void TrafficFlow::set_report_time(::google::protobuf::int64 value) {
  set_has_report_time();
  report_time_ = value;
}

// optional double free_flow_speed_in_mps = 5;
inline bool TrafficFlow::has_free_flow_speed_in_mps() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficFlow::set_has_free_flow_speed_in_mps() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficFlow::clear_has_free_flow_speed_in_mps() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficFlow::clear_free_flow_speed_in_mps() {
  free_flow_speed_in_mps_ = 0;
  clear_has_free_flow_speed_in_mps();
}
inline double TrafficFlow::free_flow_speed_in_mps() const {
  return free_flow_speed_in_mps_;
}
inline void TrafficFlow::set_free_flow_speed_in_mps(double value) {
  set_has_free_flow_speed_in_mps();
  free_flow_speed_in_mps_ = value;
}

// -------------------------------------------------------------------

// TrafficIncident

// repeated string traffic_id = 1;
inline int TrafficIncident::traffic_id_size() const {
  return traffic_id_.size();
}
inline void TrafficIncident::clear_traffic_id() {
  traffic_id_.Clear();
}
inline const ::std::string& TrafficIncident::traffic_id(int index) const {
  return traffic_id_.Get(index);
}
inline ::std::string* TrafficIncident::mutable_traffic_id(int index) {
  return traffic_id_.Mutable(index);
}
inline void TrafficIncident::set_traffic_id(int index, const ::std::string& value) {
  traffic_id_.Mutable(index)->assign(value);
}
inline void TrafficIncident::set_traffic_id(int index, const char* value) {
  traffic_id_.Mutable(index)->assign(value);
}
inline void TrafficIncident::set_traffic_id(int index, const char* value, size_t size) {
  traffic_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficIncident::add_traffic_id() {
  return traffic_id_.Add();
}
inline void TrafficIncident::add_traffic_id(const ::std::string& value) {
  traffic_id_.Add()->assign(value);
}
inline void TrafficIncident::add_traffic_id(const char* value) {
  traffic_id_.Add()->assign(value);
}
inline void TrafficIncident::add_traffic_id(const char* value, size_t size) {
  traffic_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TrafficIncident::traffic_id() const {
  return traffic_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TrafficIncident::mutable_traffic_id() {
  return &traffic_id_;
}

// optional string incident_type = 2;
inline bool TrafficIncident::has_incident_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficIncident::set_has_incident_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficIncident::clear_has_incident_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficIncident::clear_incident_type() {
  if (incident_type_ != &::google::protobuf::internal::kEmptyString) {
    incident_type_->clear();
  }
  clear_has_incident_type();
}
inline const ::std::string& TrafficIncident::incident_type() const {
  return *incident_type_;
}
inline void TrafficIncident::set_incident_type(const ::std::string& value) {
  set_has_incident_type();
  if (incident_type_ == &::google::protobuf::internal::kEmptyString) {
    incident_type_ = new ::std::string;
  }
  incident_type_->assign(value);
}
inline void TrafficIncident::set_incident_type(const char* value) {
  set_has_incident_type();
  if (incident_type_ == &::google::protobuf::internal::kEmptyString) {
    incident_type_ = new ::std::string;
  }
  incident_type_->assign(value);
}
inline void TrafficIncident::set_incident_type(const char* value, size_t size) {
  set_has_incident_type();
  if (incident_type_ == &::google::protobuf::internal::kEmptyString) {
    incident_type_ = new ::std::string;
  }
  incident_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficIncident::mutable_incident_type() {
  set_has_incident_type();
  if (incident_type_ == &::google::protobuf::internal::kEmptyString) {
    incident_type_ = new ::std::string;
  }
  return incident_type_;
}
inline ::std::string* TrafficIncident::release_incident_type() {
  clear_has_incident_type();
  if (incident_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = incident_type_;
    incident_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrafficIncident::set_allocated_incident_type(::std::string* incident_type) {
  if (incident_type_ != &::google::protobuf::internal::kEmptyString) {
    delete incident_type_;
  }
  if (incident_type) {
    set_has_incident_type();
    incident_type_ = incident_type;
  } else {
    clear_has_incident_type();
    incident_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.telenav.proto.map.Severity incident_severity = 3;
inline bool TrafficIncident::has_incident_severity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficIncident::set_has_incident_severity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficIncident::clear_has_incident_severity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficIncident::clear_incident_severity() {
  incident_severity_ = -1;
  clear_has_incident_severity();
}
inline ::com::telenav::proto::map::Severity TrafficIncident::incident_severity() const {
  return static_cast< ::com::telenav::proto::map::Severity >(incident_severity_);
}
inline void TrafficIncident::set_incident_severity(::com::telenav::proto::map::Severity value) {
  assert(::com::telenav::proto::map::Severity_IsValid(value));
  set_has_incident_severity();
  incident_severity_ = value;
}

// optional .com.telenav.proto.LatLon incident_location = 4;
inline bool TrafficIncident::has_incident_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficIncident::set_has_incident_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficIncident::clear_has_incident_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficIncident::clear_incident_location() {
  if (incident_location_ != NULL) incident_location_->::com::telenav::proto::LatLon::Clear();
  clear_has_incident_location();
}
inline const ::com::telenav::proto::LatLon& TrafficIncident::incident_location() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return incident_location_ != NULL ? *incident_location_ : *default_instance().incident_location_;
#else
  return incident_location_ != NULL ? *incident_location_ : *default_instance_->incident_location_;
#endif
}
inline ::com::telenav::proto::LatLon* TrafficIncident::mutable_incident_location() {
  set_has_incident_location();
  if (incident_location_ == NULL) incident_location_ = new ::com::telenav::proto::LatLon;
  return incident_location_;
}
inline ::com::telenav::proto::LatLon* TrafficIncident::release_incident_location() {
  clear_has_incident_location();
  ::com::telenav::proto::LatLon* temp = incident_location_;
  incident_location_ = NULL;
  return temp;
}
inline void TrafficIncident::set_allocated_incident_location(::com::telenav::proto::LatLon* incident_location) {
  delete incident_location_;
  incident_location_ = incident_location;
  if (incident_location) {
    set_has_incident_location();
  } else {
    clear_has_incident_location();
  }
}

// optional string description = 5;
inline bool TrafficIncident::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficIncident::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficIncident::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficIncident::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& TrafficIncident::description() const {
  return *description_;
}
inline void TrafficIncident::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TrafficIncident::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TrafficIncident::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficIncident::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* TrafficIncident::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrafficIncident::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string street_name = 6;
inline bool TrafficIncident::has_street_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrafficIncident::set_has_street_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrafficIncident::clear_has_street_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrafficIncident::clear_street_name() {
  if (street_name_ != &::google::protobuf::internal::kEmptyString) {
    street_name_->clear();
  }
  clear_has_street_name();
}
inline const ::std::string& TrafficIncident::street_name() const {
  return *street_name_;
}
inline void TrafficIncident::set_street_name(const ::std::string& value) {
  set_has_street_name();
  if (street_name_ == &::google::protobuf::internal::kEmptyString) {
    street_name_ = new ::std::string;
  }
  street_name_->assign(value);
}
inline void TrafficIncident::set_street_name(const char* value) {
  set_has_street_name();
  if (street_name_ == &::google::protobuf::internal::kEmptyString) {
    street_name_ = new ::std::string;
  }
  street_name_->assign(value);
}
inline void TrafficIncident::set_street_name(const char* value, size_t size) {
  set_has_street_name();
  if (street_name_ == &::google::protobuf::internal::kEmptyString) {
    street_name_ = new ::std::string;
  }
  street_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficIncident::mutable_street_name() {
  set_has_street_name();
  if (street_name_ == &::google::protobuf::internal::kEmptyString) {
    street_name_ = new ::std::string;
  }
  return street_name_;
}
inline ::std::string* TrafficIncident::release_street_name() {
  clear_has_street_name();
  if (street_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = street_name_;
    street_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrafficIncident::set_allocated_street_name(::std::string* street_name) {
  if (street_name_ != &::google::protobuf::internal::kEmptyString) {
    delete street_name_;
  }
  if (street_name) {
    set_has_street_name();
    street_name_ = street_name;
  } else {
    clear_has_street_name();
    street_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string first_cross_street = 7;
inline bool TrafficIncident::has_first_cross_street() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrafficIncident::set_has_first_cross_street() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrafficIncident::clear_has_first_cross_street() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrafficIncident::clear_first_cross_street() {
  if (first_cross_street_ != &::google::protobuf::internal::kEmptyString) {
    first_cross_street_->clear();
  }
  clear_has_first_cross_street();
}
inline const ::std::string& TrafficIncident::first_cross_street() const {
  return *first_cross_street_;
}
inline void TrafficIncident::set_first_cross_street(const ::std::string& value) {
  set_has_first_cross_street();
  if (first_cross_street_ == &::google::protobuf::internal::kEmptyString) {
    first_cross_street_ = new ::std::string;
  }
  first_cross_street_->assign(value);
}
inline void TrafficIncident::set_first_cross_street(const char* value) {
  set_has_first_cross_street();
  if (first_cross_street_ == &::google::protobuf::internal::kEmptyString) {
    first_cross_street_ = new ::std::string;
  }
  first_cross_street_->assign(value);
}
inline void TrafficIncident::set_first_cross_street(const char* value, size_t size) {
  set_has_first_cross_street();
  if (first_cross_street_ == &::google::protobuf::internal::kEmptyString) {
    first_cross_street_ = new ::std::string;
  }
  first_cross_street_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficIncident::mutable_first_cross_street() {
  set_has_first_cross_street();
  if (first_cross_street_ == &::google::protobuf::internal::kEmptyString) {
    first_cross_street_ = new ::std::string;
  }
  return first_cross_street_;
}
inline ::std::string* TrafficIncident::release_first_cross_street() {
  clear_has_first_cross_street();
  if (first_cross_street_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = first_cross_street_;
    first_cross_street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrafficIncident::set_allocated_first_cross_street(::std::string* first_cross_street) {
  if (first_cross_street_ != &::google::protobuf::internal::kEmptyString) {
    delete first_cross_street_;
  }
  if (first_cross_street) {
    set_has_first_cross_street();
    first_cross_street_ = first_cross_street;
  } else {
    clear_has_first_cross_street();
    first_cross_street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string second_cross_street = 8;
inline bool TrafficIncident::has_second_cross_street() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrafficIncident::set_has_second_cross_street() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrafficIncident::clear_has_second_cross_street() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrafficIncident::clear_second_cross_street() {
  if (second_cross_street_ != &::google::protobuf::internal::kEmptyString) {
    second_cross_street_->clear();
  }
  clear_has_second_cross_street();
}
inline const ::std::string& TrafficIncident::second_cross_street() const {
  return *second_cross_street_;
}
inline void TrafficIncident::set_second_cross_street(const ::std::string& value) {
  set_has_second_cross_street();
  if (second_cross_street_ == &::google::protobuf::internal::kEmptyString) {
    second_cross_street_ = new ::std::string;
  }
  second_cross_street_->assign(value);
}
inline void TrafficIncident::set_second_cross_street(const char* value) {
  set_has_second_cross_street();
  if (second_cross_street_ == &::google::protobuf::internal::kEmptyString) {
    second_cross_street_ = new ::std::string;
  }
  second_cross_street_->assign(value);
}
inline void TrafficIncident::set_second_cross_street(const char* value, size_t size) {
  set_has_second_cross_street();
  if (second_cross_street_ == &::google::protobuf::internal::kEmptyString) {
    second_cross_street_ = new ::std::string;
  }
  second_cross_street_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficIncident::mutable_second_cross_street() {
  set_has_second_cross_street();
  if (second_cross_street_ == &::google::protobuf::internal::kEmptyString) {
    second_cross_street_ = new ::std::string;
  }
  return second_cross_street_;
}
inline ::std::string* TrafficIncident::release_second_cross_street() {
  clear_has_second_cross_street();
  if (second_cross_street_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = second_cross_street_;
    second_cross_street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrafficIncident::set_allocated_second_cross_street(::std::string* second_cross_street) {
  if (second_cross_street_ != &::google::protobuf::internal::kEmptyString) {
    delete second_cross_street_;
  }
  if (second_cross_street) {
    set_has_second_cross_street();
    second_cross_street_ = second_cross_street;
  } else {
    clear_has_second_cross_street();
    second_cross_street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 event_code = 9;
inline bool TrafficIncident::has_event_code() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TrafficIncident::set_has_event_code() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TrafficIncident::clear_has_event_code() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TrafficIncident::clear_event_code() {
  event_code_ = 0;
  clear_has_event_code();
}
inline ::google::protobuf::int32 TrafficIncident::event_code() const {
  return event_code_;
}
inline void TrafficIncident::set_event_code(::google::protobuf::int32 value) {
  set_has_event_code();
  event_code_ = value;
}

// optional int64 end_time = 10;
inline bool TrafficIncident::has_end_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TrafficIncident::set_has_end_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TrafficIncident::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TrafficIncident::clear_end_time() {
  end_time_ = GOOGLE_LONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::int64 TrafficIncident::end_time() const {
  return end_time_;
}
inline void TrafficIncident::set_end_time(::google::protobuf::int64 value) {
  set_has_end_time();
  end_time_ = value;
}

// optional int32 speed = 11;
inline bool TrafficIncident::has_speed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TrafficIncident::set_has_speed() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TrafficIncident::clear_has_speed() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TrafficIncident::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 TrafficIncident::speed() const {
  return speed_;
}
inline void TrafficIncident::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
}

// optional bool is_blocking = 12;
inline bool TrafficIncident::has_is_blocking() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TrafficIncident::set_has_is_blocking() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TrafficIncident::clear_has_is_blocking() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TrafficIncident::clear_is_blocking() {
  is_blocking_ = false;
  clear_has_is_blocking();
}
inline bool TrafficIncident::is_blocking() const {
  return is_blocking_;
}
inline void TrafficIncident::set_is_blocking(bool value) {
  set_has_is_blocking();
  is_blocking_ = value;
}

// repeated string edge_id = 14;
inline int TrafficIncident::edge_id_size() const {
  return edge_id_.size();
}
inline void TrafficIncident::clear_edge_id() {
  edge_id_.Clear();
}
inline const ::std::string& TrafficIncident::edge_id(int index) const {
  return edge_id_.Get(index);
}
inline ::std::string* TrafficIncident::mutable_edge_id(int index) {
  return edge_id_.Mutable(index);
}
inline void TrafficIncident::set_edge_id(int index, const ::std::string& value) {
  edge_id_.Mutable(index)->assign(value);
}
inline void TrafficIncident::set_edge_id(int index, const char* value) {
  edge_id_.Mutable(index)->assign(value);
}
inline void TrafficIncident::set_edge_id(int index, const char* value, size_t size) {
  edge_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficIncident::add_edge_id() {
  return edge_id_.Add();
}
inline void TrafficIncident::add_edge_id(const ::std::string& value) {
  edge_id_.Add()->assign(value);
}
inline void TrafficIncident::add_edge_id(const char* value) {
  edge_id_.Add()->assign(value);
}
inline void TrafficIncident::add_edge_id(const char* value, size_t size) {
  edge_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TrafficIncident::edge_id() const {
  return edge_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TrafficIncident::mutable_edge_id() {
  return &edge_id_;
}

// -------------------------------------------------------------------

// TrafficLevelDictionary

// repeated .com.telenav.proto.map.TrafficLevelPair level_pairs = 1;
inline int TrafficLevelDictionary::level_pairs_size() const {
  return level_pairs_.size();
}
inline void TrafficLevelDictionary::clear_level_pairs() {
  level_pairs_.Clear();
}
inline const ::com::telenav::proto::map::TrafficLevelPair& TrafficLevelDictionary::level_pairs(int index) const {
  return level_pairs_.Get(index);
}
inline ::com::telenav::proto::map::TrafficLevelPair* TrafficLevelDictionary::mutable_level_pairs(int index) {
  return level_pairs_.Mutable(index);
}
inline ::com::telenav::proto::map::TrafficLevelPair* TrafficLevelDictionary::add_level_pairs() {
  return level_pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficLevelPair >&
TrafficLevelDictionary::level_pairs() const {
  return level_pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TrafficLevelPair >*
TrafficLevelDictionary::mutable_level_pairs() {
  return &level_pairs_;
}

// -------------------------------------------------------------------

// TrafficLevelPair

// optional int32 traffic_level_id = 1;
inline bool TrafficLevelPair::has_traffic_level_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLevelPair::set_has_traffic_level_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLevelPair::clear_has_traffic_level_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLevelPair::clear_traffic_level_id() {
  traffic_level_id_ = 0;
  clear_has_traffic_level_id();
}
inline ::google::protobuf::int32 TrafficLevelPair::traffic_level_id() const {
  return traffic_level_id_;
}
inline void TrafficLevelPair::set_traffic_level_id(::google::protobuf::int32 value) {
  set_has_traffic_level_id();
  traffic_level_id_ = value;
}

// optional string traffic_level_str = 2;
inline bool TrafficLevelPair::has_traffic_level_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLevelPair::set_has_traffic_level_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLevelPair::clear_has_traffic_level_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLevelPair::clear_traffic_level_str() {
  if (traffic_level_str_ != &::google::protobuf::internal::kEmptyString) {
    traffic_level_str_->clear();
  }
  clear_has_traffic_level_str();
}
inline const ::std::string& TrafficLevelPair::traffic_level_str() const {
  return *traffic_level_str_;
}
inline void TrafficLevelPair::set_traffic_level_str(const ::std::string& value) {
  set_has_traffic_level_str();
  if (traffic_level_str_ == &::google::protobuf::internal::kEmptyString) {
    traffic_level_str_ = new ::std::string;
  }
  traffic_level_str_->assign(value);
}
inline void TrafficLevelPair::set_traffic_level_str(const char* value) {
  set_has_traffic_level_str();
  if (traffic_level_str_ == &::google::protobuf::internal::kEmptyString) {
    traffic_level_str_ = new ::std::string;
  }
  traffic_level_str_->assign(value);
}
inline void TrafficLevelPair::set_traffic_level_str(const char* value, size_t size) {
  set_has_traffic_level_str();
  if (traffic_level_str_ == &::google::protobuf::internal::kEmptyString) {
    traffic_level_str_ = new ::std::string;
  }
  traffic_level_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficLevelPair::mutable_traffic_level_str() {
  set_has_traffic_level_str();
  if (traffic_level_str_ == &::google::protobuf::internal::kEmptyString) {
    traffic_level_str_ = new ::std::string;
  }
  return traffic_level_str_;
}
inline ::std::string* TrafficLevelPair::release_traffic_level_str() {
  clear_has_traffic_level_str();
  if (traffic_level_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = traffic_level_str_;
    traffic_level_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrafficLevelPair::set_allocated_traffic_level_str(::std::string* traffic_level_str) {
  if (traffic_level_str_ != &::google::protobuf::internal::kEmptyString) {
    delete traffic_level_str_;
  }
  if (traffic_level_str) {
    set_has_traffic_level_str();
    traffic_level_str_ = traffic_level_str;
  } else {
    clear_has_traffic_level_str();
    traffic_level_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace map
}  // namespace proto
}  // namespace telenav
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_map_2etraffic_2eproto__INCLUDED
