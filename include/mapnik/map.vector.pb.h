// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map.vector.proto

#ifndef PROTOBUF_map_2evector_2eproto__INCLUDED
#define PROTOBUF_map_2evector_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mapnik/common.pb.h"
#include "mapnik/map.common.pb.h"
#include "mapnik/services.pb.h"
// @@protoc_insertion_point(includes)

namespace com {
namespace telenav {
namespace proto {
namespace map {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_map_2evector_2eproto();
void protobuf_AssignDesc_map_2evector_2eproto();
void protobuf_ShutdownFile_map_2evector_2eproto();

class VectorMapRequest;
class TfcObj;
class Polygon;
class Polyline;
class VectorTrafficTile;
class VectorMapTile;
class FeatureName;
class HighwayShield;
class RoadFeature;
class AreaFeature;
class LineFeature;
class PointFeature;
class BuildingBlockRef;
class BuildingBlockList;
class BigTileConfig;
class ZoomLevel;

enum RoadSubType {
  RST_UNKNOWN = 0,
  RST_COMMON = 1,
  RST_JUNCTION = 2,
  RST_RAMP = 3,
  RST_BRIDGE = 4,
  RST_TUNNEL = 5
};
bool RoadSubType_IsValid(int value);
const RoadSubType RoadSubType_MIN = RST_UNKNOWN;
const RoadSubType RoadSubType_MAX = RST_TUNNEL;
const int RoadSubType_ARRAYSIZE = RoadSubType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadSubType_descriptor();
inline const ::std::string& RoadSubType_Name(RoadSubType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadSubType_descriptor(), value);
}
inline bool RoadSubType_Parse(
    const ::std::string& name, RoadSubType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadSubType>(
    RoadSubType_descriptor(), name, value);
}
enum RoadDirection {
  CLOSED = 0,
  POSITIVE = 1,
  NEGATIVE = 2,
  BOTHWAY = 3,
  UNKONWN = 4
};
bool RoadDirection_IsValid(int value);
const RoadDirection RoadDirection_MIN = CLOSED;
const RoadDirection RoadDirection_MAX = UNKONWN;
const int RoadDirection_ARRAYSIZE = RoadDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadDirection_descriptor();
inline const ::std::string& RoadDirection_Name(RoadDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadDirection_descriptor(), value);
}
inline bool RoadDirection_Parse(
    const ::std::string& name, RoadDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadDirection>(
    RoadDirection_descriptor(), name, value);
}
enum RoadFunctionClass {
  FC_1 = 1,
  FC_2 = 2,
  FC_3 = 3,
  FC_4 = 4,
  FC_5 = 5
};
bool RoadFunctionClass_IsValid(int value);
const RoadFunctionClass RoadFunctionClass_MIN = FC_1;
const RoadFunctionClass RoadFunctionClass_MAX = FC_5;
const int RoadFunctionClass_ARRAYSIZE = RoadFunctionClass_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadFunctionClass_descriptor();
inline const ::std::string& RoadFunctionClass_Name(RoadFunctionClass value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadFunctionClass_descriptor(), value);
}
inline bool RoadFunctionClass_Parse(
    const ::std::string& name, RoadFunctionClass* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadFunctionClass>(
    RoadFunctionClass_descriptor(), name, value);
}
enum AreaType {
  BK_AREA_UNKNOWN = 0,
  BK_AREA_BUILDING = 1,
  BK_AREA_WOODLAND = 2,
  BK_AREA_BEACH = 3,
  BK_AREA_PARK = 4,
  BK_AREA_ISLAND = 5,
  BK_AREA_AIRPORT = 6,
  BK_AREA_AIRCRAFT_ROAD = 7,
  BK_AREA_PEDESTRIAN = 8,
  BK_AREA_MILITARY = 9,
  BK_AREA_RESERVATION = 10,
  BK_AREA_ELEVATIONI = 11,
  BK_AREA_COLONIA = 12,
  BK_AREA_CONGESTION = 13,
  BK_AREA_HURRICANE_PRONE = 14,
  BK_AREA_FLOOD_PRONE = 15,
  BK_AREA_TSUNAMI_PRONE = 16,
  BK_AREA_WATER = 17,
  BK_AREA_BUILTUP = 18,
  BK_AREA_EXPO_AREA = 19
};
bool AreaType_IsValid(int value);
const AreaType AreaType_MIN = BK_AREA_UNKNOWN;
const AreaType AreaType_MAX = BK_AREA_EXPO_AREA;
const int AreaType_ARRAYSIZE = AreaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AreaType_descriptor();
inline const ::std::string& AreaType_Name(AreaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AreaType_descriptor(), value);
}
inline bool AreaType_Parse(
    const ::std::string& name, AreaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AreaType>(
    AreaType_descriptor(), name, value);
}
enum RingOrientation {
  OR_UNKNOWN = 0,
  OR_CLOCKWISE = 1,
  OR_ANTI_CLOCKWISE = 2
};
bool RingOrientation_IsValid(int value);
const RingOrientation RingOrientation_MIN = OR_UNKNOWN;
const RingOrientation RingOrientation_MAX = OR_ANTI_CLOCKWISE;
const int RingOrientation_ARRAYSIZE = RingOrientation_MAX + 1;

const ::google::protobuf::EnumDescriptor* RingOrientation_descriptor();
inline const ::std::string& RingOrientation_Name(RingOrientation value) {
  return ::google::protobuf::internal::NameOfEnum(
    RingOrientation_descriptor(), value);
}
inline bool RingOrientation_Parse(
    const ::std::string& name, RingOrientation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RingOrientation>(
    RingOrientation_descriptor(), name, value);
}
enum PointType {
  PT_UNKNOWN = 0,
  PT_ROAD = 1,
  PT_ICON = 2,
  PT_LINE = 3,
  PT_AREA = 4,
  PT_CITY = 5,
  PT_POINT = 6,
  PT_GLOBAL_CENTER = 7,
  PT_HOUSE_NUMBER = 8,
  PT_NEIGHBORHOOD = 9
};
bool PointType_IsValid(int value);
const PointType PointType_MIN = PT_UNKNOWN;
const PointType PointType_MAX = PT_NEIGHBORHOOD;
const int PointType_ARRAYSIZE = PointType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PointType_descriptor();
inline const ::std::string& PointType_Name(PointType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PointType_descriptor(), value);
}
inline bool PointType_Parse(
    const ::std::string& name, PointType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PointType>(
    PointType_descriptor(), name, value);
}
enum LineType {
  BK_LINE_UNKNOWN = 0,
  BK_LINE_CANAL = 1,
  BK_LINE_RAIL = 2,
  BK_LINE_BORDER = 3,
  BK_LINE_DENOTE = 4,
  BK_LINE_RUNWAY = 5,
  BK_LINE_TAXIWAY = 6
};
bool LineType_IsValid(int value);
const LineType LineType_MIN = BK_LINE_UNKNOWN;
const LineType LineType_MAX = BK_LINE_TAXIWAY;
const int LineType_ARRAYSIZE = LineType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LineType_descriptor();
inline const ::std::string& LineType_Name(LineType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LineType_descriptor(), value);
}
inline bool LineType_Parse(
    const ::std::string& name, LineType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LineType>(
    LineType_descriptor(), name, value);
}
enum FontStyle {
  FT_UNKNOWN = 0,
  FT_PLAIN = 1,
  FT_ITALIC = 2,
  FT_BOLD = 3
};
bool FontStyle_IsValid(int value);
const FontStyle FontStyle_MIN = FT_UNKNOWN;
const FontStyle FontStyle_MAX = FT_BOLD;
const int FontStyle_ARRAYSIZE = FontStyle_MAX + 1;

const ::google::protobuf::EnumDescriptor* FontStyle_descriptor();
inline const ::std::string& FontStyle_Name(FontStyle value) {
  return ::google::protobuf::internal::NameOfEnum(
    FontStyle_descriptor(), value);
}
inline bool FontStyle_Parse(
    const ::std::string& name, FontStyle* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FontStyle>(
    FontStyle_descriptor(), name, value);
}
// ===================================================================

class VectorMapRequest : public ::google::protobuf::Message {
 public:
  VectorMapRequest();
  virtual ~VectorMapRequest();

  VectorMapRequest(const VectorMapRequest& from);

  inline VectorMapRequest& operator=(const VectorMapRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VectorMapRequest& default_instance();

  void Swap(VectorMapRequest* other);

  // implements Message ----------------------------------------------

  VectorMapRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VectorMapRequest& from);
  void MergeFrom(const VectorMapRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 zoomLevel = 1;
  inline bool has_zoomlevel() const;
  inline void clear_zoomlevel();
  static const int kZoomLevelFieldNumber = 1;
  inline ::google::protobuf::int32 zoomlevel() const;
  inline void set_zoomlevel(::google::protobuf::int32 value);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional .com.telenav.proto.Context context = 4;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 4;
  inline const ::com::telenav::proto::Context& context() const;
  inline ::com::telenav::proto::Context* mutable_context();
  inline ::com::telenav::proto::Context* release_context();
  inline void set_allocated_context(::com::telenav::proto::Context* context);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.VectorMapRequest)
 private:
  inline void set_has_zoomlevel();
  inline void clear_has_zoomlevel();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_context();
  inline void clear_has_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 zoomlevel_;
  ::google::protobuf::int32 x_;
  ::com::telenav::proto::Context* context_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static VectorMapRequest* default_instance_;
};
// -------------------------------------------------------------------

class TfcObj : public ::google::protobuf::Message {
 public:
  TfcObj();
  virtual ~TfcObj();

  TfcObj(const TfcObj& from);

  inline TfcObj& operator=(const TfcObj& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TfcObj& default_instance();

  void Swap(TfcObj* other);

  // implements Message ----------------------------------------------

  TfcObj* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TfcObj& from);
  void MergeFrom(const TfcObj& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string trafficId = 1;
  inline bool has_trafficid() const;
  inline void clear_trafficid();
  static const int kTrafficIdFieldNumber = 1;
  inline const ::std::string& trafficid() const;
  inline void set_trafficid(const ::std::string& value);
  inline void set_trafficid(const char* value);
  inline void set_trafficid(const char* value, size_t size);
  inline ::std::string* mutable_trafficid();
  inline ::std::string* release_trafficid();
  inline void set_allocated_trafficid(::std::string* trafficid);

  // optional uint32 start_idx = 2;
  inline bool has_start_idx() const;
  inline void clear_start_idx();
  static const int kStartIdxFieldNumber = 2;
  inline ::google::protobuf::uint32 start_idx() const;
  inline void set_start_idx(::google::protobuf::uint32 value);

  // optional uint32 end_idx = 3;
  inline bool has_end_idx() const;
  inline void clear_end_idx();
  static const int kEndIdxFieldNumber = 3;
  inline ::google::protobuf::uint32 end_idx() const;
  inline void set_end_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.TfcObj)
 private:
  inline void set_has_trafficid();
  inline void clear_has_trafficid();
  inline void set_has_start_idx();
  inline void clear_has_start_idx();
  inline void set_has_end_idx();
  inline void clear_has_end_idx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* trafficid_;
  ::google::protobuf::uint32 start_idx_;
  ::google::protobuf::uint32 end_idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static TfcObj* default_instance_;
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  void Swap(Polygon* other);

  // implements Message ----------------------------------------------

  Polygon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint32 latlon = 1 [packed = true];
  inline int latlon_size() const;
  inline void clear_latlon();
  static const int kLatlonFieldNumber = 1;
  inline ::google::protobuf::int32 latlon(int index) const;
  inline void set_latlon(int index, ::google::protobuf::int32 value);
  inline void add_latlon(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      latlon() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_latlon();

  // optional .com.telenav.proto.map.RingOrientation orient = 2 [default = OR_UNKNOWN];
  inline bool has_orient() const;
  inline void clear_orient();
  static const int kOrientFieldNumber = 2;
  inline ::com::telenav::proto::map::RingOrientation orient() const;
  inline void set_orient(::com::telenav::proto::map::RingOrientation value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.Polygon)
 private:
  inline void set_has_orient();
  inline void clear_has_orient();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > latlon_;
  mutable int _latlon_cached_byte_size_;
  int orient_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static Polygon* default_instance_;
};
// -------------------------------------------------------------------

class Polyline : public ::google::protobuf::Message {
 public:
  Polyline();
  virtual ~Polyline();

  Polyline(const Polyline& from);

  inline Polyline& operator=(const Polyline& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Polyline& default_instance();

  void Swap(Polyline* other);

  // implements Message ----------------------------------------------

  Polyline* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Polyline& from);
  void MergeFrom(const Polyline& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint32 latlon = 1 [packed = true];
  inline int latlon_size() const;
  inline void clear_latlon();
  static const int kLatlonFieldNumber = 1;
  inline ::google::protobuf::int32 latlon(int index) const;
  inline void set_latlon(int index, ::google::protobuf::int32 value);
  inline void add_latlon(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      latlon() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_latlon();

  // repeated .com.telenav.proto.map.TfcObj tfcId_right = 2;
  inline int tfcid_right_size() const;
  inline void clear_tfcid_right();
  static const int kTfcIdRightFieldNumber = 2;
  inline const ::com::telenav::proto::map::TfcObj& tfcid_right(int index) const;
  inline ::com::telenav::proto::map::TfcObj* mutable_tfcid_right(int index);
  inline ::com::telenav::proto::map::TfcObj* add_tfcid_right();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TfcObj >&
      tfcid_right() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TfcObj >*
      mutable_tfcid_right();

  // repeated .com.telenav.proto.map.TfcObj tfcId_left = 3;
  inline int tfcid_left_size() const;
  inline void clear_tfcid_left();
  static const int kTfcIdLeftFieldNumber = 3;
  inline const ::com::telenav::proto::map::TfcObj& tfcid_left(int index) const;
  inline ::com::telenav::proto::map::TfcObj* mutable_tfcid_left(int index);
  inline ::com::telenav::proto::map::TfcObj* add_tfcid_left();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TfcObj >&
      tfcid_left() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TfcObj >*
      mutable_tfcid_left();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.Polyline)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > latlon_;
  mutable int _latlon_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TfcObj > tfcid_right_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TfcObj > tfcid_left_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static Polyline* default_instance_;
};
// -------------------------------------------------------------------

class VectorTrafficTile : public ::google::protobuf::Message {
 public:
  VectorTrafficTile();
  virtual ~VectorTrafficTile();

  VectorTrafficTile(const VectorTrafficTile& from);

  inline VectorTrafficTile& operator=(const VectorTrafficTile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VectorTrafficTile& default_instance();

  void Swap(VectorTrafficTile* other);

  // implements Message ----------------------------------------------

  VectorTrafficTile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VectorTrafficTile& from);
  void MergeFrom(const VectorTrafficTile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 tmcIds = 1 [packed = true];
  inline int tmcids_size() const;
  inline void clear_tmcids();
  static const int kTmcIdsFieldNumber = 1;
  inline ::google::protobuf::uint32 tmcids(int index) const;
  inline void set_tmcids(int index, ::google::protobuf::uint32 value);
  inline void add_tmcids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tmcids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tmcids();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.VectorTrafficTile)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tmcids_;
  mutable int _tmcids_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static VectorTrafficTile* default_instance_;
};
// -------------------------------------------------------------------

class VectorMapTile : public ::google::protobuf::Message {
 public:
  VectorMapTile();
  virtual ~VectorMapTile();

  VectorMapTile(const VectorMapTile& from);

  inline VectorMapTile& operator=(const VectorMapTile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VectorMapTile& default_instance();

  void Swap(VectorMapTile* other);

  // implements Message ----------------------------------------------

  VectorMapTile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VectorMapTile& from);
  void MergeFrom(const VectorMapTile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.telenav.proto.map.RoadFeature rf = 1;
  inline int rf_size() const;
  inline void clear_rf();
  static const int kRfFieldNumber = 1;
  inline const ::com::telenav::proto::map::RoadFeature& rf(int index) const;
  inline ::com::telenav::proto::map::RoadFeature* mutable_rf(int index);
  inline ::com::telenav::proto::map::RoadFeature* add_rf();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::RoadFeature >&
      rf() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::RoadFeature >*
      mutable_rf();

  // repeated .com.telenav.proto.map.AreaFeature af = 2;
  inline int af_size() const;
  inline void clear_af();
  static const int kAfFieldNumber = 2;
  inline const ::com::telenav::proto::map::AreaFeature& af(int index) const;
  inline ::com::telenav::proto::map::AreaFeature* mutable_af(int index);
  inline ::com::telenav::proto::map::AreaFeature* add_af();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::AreaFeature >&
      af() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::AreaFeature >*
      mutable_af();

  // repeated .com.telenav.proto.map.LineFeature lf = 3;
  inline int lf_size() const;
  inline void clear_lf();
  static const int kLfFieldNumber = 3;
  inline const ::com::telenav::proto::map::LineFeature& lf(int index) const;
  inline ::com::telenav::proto::map::LineFeature* mutable_lf(int index);
  inline ::com::telenav::proto::map::LineFeature* add_lf();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::LineFeature >&
      lf() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::LineFeature >*
      mutable_lf();

  // repeated .com.telenav.proto.map.PointFeature pf = 4;
  inline int pf_size() const;
  inline void clear_pf();
  static const int kPfFieldNumber = 4;
  inline const ::com::telenav::proto::map::PointFeature& pf(int index) const;
  inline ::com::telenav::proto::map::PointFeature* mutable_pf(int index);
  inline ::com::telenav::proto::map::PointFeature* add_pf();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::PointFeature >&
      pf() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::PointFeature >*
      mutable_pf();

  // optional .com.telenav.proto.map.BuildingBlockList buildingBlockList = 5;
  inline bool has_buildingblocklist() const;
  inline void clear_buildingblocklist();
  static const int kBuildingBlockListFieldNumber = 5;
  inline const ::com::telenav::proto::map::BuildingBlockList& buildingblocklist() const;
  inline ::com::telenav::proto::map::BuildingBlockList* mutable_buildingblocklist();
  inline ::com::telenav::proto::map::BuildingBlockList* release_buildingblocklist();
  inline void set_allocated_buildingblocklist(::com::telenav::proto::map::BuildingBlockList* buildingblocklist);

  // optional string dataVersion = 6;
  inline bool has_dataversion() const;
  inline void clear_dataversion();
  static const int kDataVersionFieldNumber = 6;
  inline const ::std::string& dataversion() const;
  inline void set_dataversion(const ::std::string& value);
  inline void set_dataversion(const char* value);
  inline void set_dataversion(const char* value, size_t size);
  inline ::std::string* mutable_dataversion();
  inline ::std::string* release_dataversion();
  inline void set_allocated_dataversion(::std::string* dataversion);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.VectorMapTile)
 private:
  inline void set_has_buildingblocklist();
  inline void clear_has_buildingblocklist();
  inline void set_has_dataversion();
  inline void clear_has_dataversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::RoadFeature > rf_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::AreaFeature > af_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::LineFeature > lf_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::PointFeature > pf_;
  ::com::telenav::proto::map::BuildingBlockList* buildingblocklist_;
  ::std::string* dataversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static VectorMapTile* default_instance_;
};
// -------------------------------------------------------------------

class FeatureName : public ::google::protobuf::Message {
 public:
  FeatureName();
  virtual ~FeatureName();

  FeatureName(const FeatureName& from);

  inline FeatureName& operator=(const FeatureName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureName& default_instance();

  void Swap(FeatureName* other);

  // implements Message ----------------------------------------------

  FeatureName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureName& from);
  void MergeFrom(const FeatureName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string alias = 2;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 2;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // optional string language = 3;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 3;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.FeatureName)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_language();
  inline void clear_has_language();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* alias_;
  ::std::string* language_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static FeatureName* default_instance_;
};
// -------------------------------------------------------------------

class HighwayShield : public ::google::protobuf::Message {
 public:
  HighwayShield();
  virtual ~HighwayShield();

  HighwayShield(const HighwayShield& from);

  inline HighwayShield& operator=(const HighwayShield& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HighwayShield& default_instance();

  void Swap(HighwayShield* other);

  // implements Message ----------------------------------------------

  HighwayShield* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HighwayShield& from);
  void MergeFrom(const HighwayShield& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // optional string iconID = 2;
  inline bool has_iconid() const;
  inline void clear_iconid();
  static const int kIconIDFieldNumber = 2;
  inline const ::std::string& iconid() const;
  inline void set_iconid(const ::std::string& value);
  inline void set_iconid(const char* value);
  inline void set_iconid(const char* value, size_t size);
  inline ::std::string* mutable_iconid();
  inline ::std::string* release_iconid();
  inline void set_allocated_iconid(::std::string* iconid);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.HighwayShield)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_iconid();
  inline void clear_has_iconid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* number_;
  ::std::string* iconid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static HighwayShield* default_instance_;
};
// -------------------------------------------------------------------

class RoadFeature : public ::google::protobuf::Message {
 public:
  RoadFeature();
  virtual ~RoadFeature();

  RoadFeature(const RoadFeature& from);

  inline RoadFeature& operator=(const RoadFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadFeature& default_instance();

  void Swap(RoadFeature* other);

  // implements Message ----------------------------------------------

  RoadFeature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoadFeature& from);
  void MergeFrom(const RoadFeature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.telenav.proto.map.Polyline lines = 1;
  inline int lines_size() const;
  inline void clear_lines();
  static const int kLinesFieldNumber = 1;
  inline const ::com::telenav::proto::map::Polyline& lines(int index) const;
  inline ::com::telenav::proto::map::Polyline* mutable_lines(int index);
  inline ::com::telenav::proto::map::Polyline* add_lines();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polyline >&
      lines() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polyline >*
      mutable_lines();

  // optional .com.telenav.proto.map.RoadType roadType = 2 [default = RT_UNKNOWN];
  inline bool has_roadtype() const;
  inline void clear_roadtype();
  static const int kRoadTypeFieldNumber = 2;
  inline ::com::telenav::proto::map::RoadType roadtype() const;
  inline void set_roadtype(::com::telenav::proto::map::RoadType value);

  // optional .com.telenav.proto.map.RoadSubType roadSubType = 3 [default = RST_UNKNOWN];
  inline bool has_roadsubtype() const;
  inline void clear_roadsubtype();
  static const int kRoadSubTypeFieldNumber = 3;
  inline ::com::telenav::proto::map::RoadSubType roadsubtype() const;
  inline void set_roadsubtype(::com::telenav::proto::map::RoadSubType value);

  // optional string roadName = 4;
  inline bool has_roadname() const;
  inline void clear_roadname();
  static const int kRoadNameFieldNumber = 4;
  inline const ::std::string& roadname() const;
  inline void set_roadname(const ::std::string& value);
  inline void set_roadname(const char* value);
  inline void set_roadname(const char* value, size_t size);
  inline ::std::string* mutable_roadname();
  inline ::std::string* release_roadname();
  inline void set_allocated_roadname(::std::string* roadname);

  // optional string roadAlias = 5;
  inline bool has_roadalias() const;
  inline void clear_roadalias();
  static const int kRoadAliasFieldNumber = 5;
  inline const ::std::string& roadalias() const;
  inline void set_roadalias(const ::std::string& value);
  inline void set_roadalias(const char* value);
  inline void set_roadalias(const char* value, size_t size);
  inline ::std::string* mutable_roadalias();
  inline ::std::string* release_roadalias();
  inline void set_allocated_roadalias(::std::string* roadalias);

  // optional uint64 featureID = 15;
  inline bool has_featureid() const;
  inline void clear_featureid();
  static const int kFeatureIDFieldNumber = 15;
  inline ::google::protobuf::uint64 featureid() const;
  inline void set_featureid(::google::protobuf::uint64 value);

  // repeated .com.telenav.proto.map.FeatureName roadNames = 6;
  inline int roadnames_size() const;
  inline void clear_roadnames();
  static const int kRoadNamesFieldNumber = 6;
  inline const ::com::telenav::proto::map::FeatureName& roadnames(int index) const;
  inline ::com::telenav::proto::map::FeatureName* mutable_roadnames(int index);
  inline ::com::telenav::proto::map::FeatureName* add_roadnames();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >&
      roadnames() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >*
      mutable_roadnames();

  // repeated .com.telenav.proto.map.HighwayShield shields = 7;
  inline int shields_size() const;
  inline void clear_shields();
  static const int kShieldsFieldNumber = 7;
  inline const ::com::telenav::proto::map::HighwayShield& shields(int index) const;
  inline ::com::telenav::proto::map::HighwayShield* mutable_shields(int index);
  inline ::com::telenav::proto::map::HighwayShield* add_shields();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::HighwayShield >&
      shields() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::HighwayShield >*
      mutable_shields();

  // optional .com.telenav.proto.map.RoadFunctionClass roadFunctionClass = 8;
  inline bool has_roadfunctionclass() const;
  inline void clear_roadfunctionclass();
  static const int kRoadFunctionClassFieldNumber = 8;
  inline ::com::telenav::proto::map::RoadFunctionClass roadfunctionclass() const;
  inline void set_roadfunctionclass(::com::telenav::proto::map::RoadFunctionClass value);

  // optional .com.telenav.proto.map.RoadDirection roadDirection = 9 [default = UNKONWN];
  inline bool has_roaddirection() const;
  inline void clear_roaddirection();
  static const int kRoadDirectionFieldNumber = 9;
  inline ::com::telenav::proto::map::RoadDirection roaddirection() const;
  inline void set_roaddirection(::com::telenav::proto::map::RoadDirection value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.RoadFeature)
 private:
  inline void set_has_roadtype();
  inline void clear_has_roadtype();
  inline void set_has_roadsubtype();
  inline void clear_has_roadsubtype();
  inline void set_has_roadname();
  inline void clear_has_roadname();
  inline void set_has_roadalias();
  inline void clear_has_roadalias();
  inline void set_has_featureid();
  inline void clear_has_featureid();
  inline void set_has_roadfunctionclass();
  inline void clear_has_roadfunctionclass();
  inline void set_has_roaddirection();
  inline void clear_has_roaddirection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polyline > lines_;
  int roadtype_;
  int roadsubtype_;
  ::std::string* roadname_;
  ::std::string* roadalias_;
  ::google::protobuf::uint64 featureid_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName > roadnames_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::HighwayShield > shields_;
  int roadfunctionclass_;
  int roaddirection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static RoadFeature* default_instance_;
};
// -------------------------------------------------------------------

class AreaFeature : public ::google::protobuf::Message {
 public:
  AreaFeature();
  virtual ~AreaFeature();

  AreaFeature(const AreaFeature& from);

  inline AreaFeature& operator=(const AreaFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AreaFeature& default_instance();

  void Swap(AreaFeature* other);

  // implements Message ----------------------------------------------

  AreaFeature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AreaFeature& from);
  void MergeFrom(const AreaFeature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.telenav.proto.map.Polygon rings = 1;
  inline int rings_size() const;
  inline void clear_rings();
  static const int kRingsFieldNumber = 1;
  inline const ::com::telenav::proto::map::Polygon& rings(int index) const;
  inline ::com::telenav::proto::map::Polygon* mutable_rings(int index);
  inline ::com::telenav::proto::map::Polygon* add_rings();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polygon >&
      rings() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polygon >*
      mutable_rings();

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .com.telenav.proto.map.AreaType mainType = 3 [default = BK_AREA_UNKNOWN];
  inline bool has_maintype() const;
  inline void clear_maintype();
  static const int kMainTypeFieldNumber = 3;
  inline ::com::telenav::proto::map::AreaType maintype() const;
  inline void set_maintype(::com::telenav::proto::map::AreaType value);

  // optional string subType = 4;
  inline bool has_subtype() const;
  inline void clear_subtype();
  static const int kSubTypeFieldNumber = 4;
  inline const ::std::string& subtype() const;
  inline void set_subtype(const ::std::string& value);
  inline void set_subtype(const char* value);
  inline void set_subtype(const char* value, size_t size);
  inline ::std::string* mutable_subtype();
  inline ::std::string* release_subtype();
  inline void set_allocated_subtype(::std::string* subtype);

  // optional uint64 featureID = 15;
  inline bool has_featureid() const;
  inline void clear_featureid();
  static const int kFeatureIDFieldNumber = 15;
  inline ::google::protobuf::uint64 featureid() const;
  inline void set_featureid(::google::protobuf::uint64 value);

  // repeated .com.telenav.proto.map.FeatureName areaNames = 5;
  inline int areanames_size() const;
  inline void clear_areanames();
  static const int kAreaNamesFieldNumber = 5;
  inline const ::com::telenav::proto::map::FeatureName& areanames(int index) const;
  inline ::com::telenav::proto::map::FeatureName* mutable_areanames(int index);
  inline ::com::telenav::proto::map::FeatureName* add_areanames();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >&
      areanames() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >*
      mutable_areanames();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.AreaFeature)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_maintype();
  inline void clear_has_maintype();
  inline void set_has_subtype();
  inline void clear_has_subtype();
  inline void set_has_featureid();
  inline void clear_has_featureid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polygon > rings_;
  ::std::string* name_;
  ::std::string* subtype_;
  ::google::protobuf::uint64 featureid_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName > areanames_;
  int maintype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static AreaFeature* default_instance_;
};
// -------------------------------------------------------------------

class LineFeature : public ::google::protobuf::Message {
 public:
  LineFeature();
  virtual ~LineFeature();

  LineFeature(const LineFeature& from);

  inline LineFeature& operator=(const LineFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineFeature& default_instance();

  void Swap(LineFeature* other);

  // implements Message ----------------------------------------------

  LineFeature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LineFeature& from);
  void MergeFrom(const LineFeature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.telenav.proto.map.Polyline lines = 1;
  inline int lines_size() const;
  inline void clear_lines();
  static const int kLinesFieldNumber = 1;
  inline const ::com::telenav::proto::map::Polyline& lines(int index) const;
  inline ::com::telenav::proto::map::Polyline* mutable_lines(int index);
  inline ::com::telenav::proto::map::Polyline* add_lines();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polyline >&
      lines() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polyline >*
      mutable_lines();

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .com.telenav.proto.map.LineType mainType = 3 [default = BK_LINE_UNKNOWN];
  inline bool has_maintype() const;
  inline void clear_maintype();
  static const int kMainTypeFieldNumber = 3;
  inline ::com::telenav::proto::map::LineType maintype() const;
  inline void set_maintype(::com::telenav::proto::map::LineType value);

  // optional string subType = 4;
  inline bool has_subtype() const;
  inline void clear_subtype();
  static const int kSubTypeFieldNumber = 4;
  inline const ::std::string& subtype() const;
  inline void set_subtype(const ::std::string& value);
  inline void set_subtype(const char* value);
  inline void set_subtype(const char* value, size_t size);
  inline ::std::string* mutable_subtype();
  inline ::std::string* release_subtype();
  inline void set_allocated_subtype(::std::string* subtype);

  // optional uint64 featureID = 15;
  inline bool has_featureid() const;
  inline void clear_featureid();
  static const int kFeatureIDFieldNumber = 15;
  inline ::google::protobuf::uint64 featureid() const;
  inline void set_featureid(::google::protobuf::uint64 value);

  // repeated .com.telenav.proto.map.FeatureName names = 6;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 6;
  inline const ::com::telenav::proto::map::FeatureName& names(int index) const;
  inline ::com::telenav::proto::map::FeatureName* mutable_names(int index);
  inline ::com::telenav::proto::map::FeatureName* add_names();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >&
      names() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >*
      mutable_names();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.LineFeature)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_maintype();
  inline void clear_has_maintype();
  inline void set_has_subtype();
  inline void clear_has_subtype();
  inline void set_has_featureid();
  inline void clear_has_featureid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polyline > lines_;
  ::std::string* name_;
  ::std::string* subtype_;
  ::google::protobuf::uint64 featureid_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName > names_;
  int maintype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static LineFeature* default_instance_;
};
// -------------------------------------------------------------------

class PointFeature : public ::google::protobuf::Message {
 public:
  PointFeature();
  virtual ~PointFeature();

  PointFeature(const PointFeature& from);

  inline PointFeature& operator=(const PointFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointFeature& default_instance();

  void Swap(PointFeature* other);

  // implements Message ----------------------------------------------

  PointFeature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointFeature& from);
  void MergeFrom(const PointFeature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint32 latlon = 1 [packed = true];
  inline int latlon_size() const;
  inline void clear_latlon();
  static const int kLatlonFieldNumber = 1;
  inline ::google::protobuf::int32 latlon(int index) const;
  inline void set_latlon(int index, ::google::protobuf::int32 value);
  inline void add_latlon(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      latlon() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_latlon();

  // optional .com.telenav.proto.map.PointType mainType = 2 [default = PT_UNKNOWN];
  inline bool has_maintype() const;
  inline void clear_maintype();
  static const int kMainTypeFieldNumber = 2;
  inline ::com::telenav::proto::map::PointType maintype() const;
  inline void set_maintype(::com::telenav::proto::map::PointType value);

  // optional string subType = 3;
  inline bool has_subtype() const;
  inline void clear_subtype();
  static const int kSubTypeFieldNumber = 3;
  inline const ::std::string& subtype() const;
  inline void set_subtype(const ::std::string& value);
  inline void set_subtype(const char* value);
  inline void set_subtype(const char* value, size_t size);
  inline ::std::string* mutable_subtype();
  inline ::std::string* release_subtype();
  inline void set_allocated_subtype(::std::string* subtype);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 fontSize = 5;
  inline bool has_fontsize() const;
  inline void clear_fontsize();
  static const int kFontSizeFieldNumber = 5;
  inline ::google::protobuf::int32 fontsize() const;
  inline void set_fontsize(::google::protobuf::int32 value);

  // optional string country = 6;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 6;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // repeated int32 rdNameOri = 7 [packed = true];
  inline int rdnameori_size() const;
  inline void clear_rdnameori();
  static const int kRdNameOriFieldNumber = 7;
  inline ::google::protobuf::int32 rdnameori(int index) const;
  inline void set_rdnameori(int index, ::google::protobuf::int32 value);
  inline void add_rdnameori(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      rdnameori() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_rdnameori();

  // optional .com.telenav.proto.map.FontStyle fontStyle = 8;
  inline bool has_fontstyle() const;
  inline void clear_fontstyle();
  static const int kFontStyleFieldNumber = 8;
  inline ::com::telenav::proto::map::FontStyle fontstyle() const;
  inline void set_fontstyle(::com::telenav::proto::map::FontStyle value);

  // optional .com.telenav.proto.map.Polyline spline = 9;
  inline bool has_spline() const;
  inline void clear_spline();
  static const int kSplineFieldNumber = 9;
  inline const ::com::telenav::proto::map::Polyline& spline() const;
  inline ::com::telenav::proto::map::Polyline* mutable_spline();
  inline ::com::telenav::proto::map::Polyline* release_spline();
  inline void set_allocated_spline(::com::telenav::proto::map::Polyline* spline);

  // repeated uint64 p_featureID = 14;
  inline int p_featureid_size() const;
  inline void clear_p_featureid();
  static const int kPFeatureIDFieldNumber = 14;
  inline ::google::protobuf::uint64 p_featureid(int index) const;
  inline void set_p_featureid(int index, ::google::protobuf::uint64 value);
  inline void add_p_featureid(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      p_featureid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_p_featureid();

  // optional uint64 featureID = 15;
  inline bool has_featureid() const;
  inline void clear_featureid();
  static const int kFeatureIDFieldNumber = 15;
  inline ::google::protobuf::uint64 featureid() const;
  inline void set_featureid(::google::protobuf::uint64 value);

  // repeated .com.telenav.proto.map.FeatureName pointNames = 10;
  inline int pointnames_size() const;
  inline void clear_pointnames();
  static const int kPointNamesFieldNumber = 10;
  inline const ::com::telenav::proto::map::FeatureName& pointnames(int index) const;
  inline ::com::telenav::proto::map::FeatureName* mutable_pointnames(int index);
  inline ::com::telenav::proto::map::FeatureName* add_pointnames();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >&
      pointnames() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >*
      mutable_pointnames();

  // optional string landmark_icon = 11;
  inline bool has_landmark_icon() const;
  inline void clear_landmark_icon();
  static const int kLandmarkIconFieldNumber = 11;
  inline const ::std::string& landmark_icon() const;
  inline void set_landmark_icon(const ::std::string& value);
  inline void set_landmark_icon(const char* value);
  inline void set_landmark_icon(const char* value, size_t size);
  inline ::std::string* mutable_landmark_icon();
  inline ::std::string* release_landmark_icon();
  inline void set_allocated_landmark_icon(::std::string* landmark_icon);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.PointFeature)
 private:
  inline void set_has_maintype();
  inline void clear_has_maintype();
  inline void set_has_subtype();
  inline void clear_has_subtype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fontsize();
  inline void clear_has_fontsize();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_fontstyle();
  inline void clear_has_fontstyle();
  inline void set_has_spline();
  inline void clear_has_spline();
  inline void set_has_featureid();
  inline void clear_has_featureid();
  inline void set_has_landmark_icon();
  inline void clear_has_landmark_icon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > latlon_;
  mutable int _latlon_cached_byte_size_;
  ::std::string* subtype_;
  int maintype_;
  ::google::protobuf::int32 fontsize_;
  ::std::string* name_;
  ::std::string* country_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > rdnameori_;
  mutable int _rdnameori_cached_byte_size_;
  ::com::telenav::proto::map::Polyline* spline_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > p_featureid_;
  ::google::protobuf::uint64 featureid_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName > pointnames_;
  ::std::string* landmark_icon_;
  int fontstyle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static PointFeature* default_instance_;
};
// -------------------------------------------------------------------

class BuildingBlockRef : public ::google::protobuf::Message {
 public:
  BuildingBlockRef();
  virtual ~BuildingBlockRef();

  BuildingBlockRef(const BuildingBlockRef& from);

  inline BuildingBlockRef& operator=(const BuildingBlockRef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildingBlockRef& default_instance();

  void Swap(BuildingBlockRef* other);

  // implements Message ----------------------------------------------

  BuildingBlockRef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildingBlockRef& from);
  void MergeFrom(const BuildingBlockRef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 depth = 1;
  inline bool has_depth() const;
  inline void clear_depth();
  static const int kDepthFieldNumber = 1;
  inline ::google::protobuf::uint32 depth() const;
  inline void set_depth(::google::protobuf::uint32 value);

  // optional uint32 col = 2;
  inline bool has_col() const;
  inline void clear_col();
  static const int kColFieldNumber = 2;
  inline ::google::protobuf::uint32 col() const;
  inline void set_col(::google::protobuf::uint32 value);

  // optional uint32 row = 3;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 3;
  inline ::google::protobuf::uint32 row() const;
  inline void set_row(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.BuildingBlockRef)
 private:
  inline void set_has_depth();
  inline void clear_has_depth();
  inline void set_has_col();
  inline void clear_has_col();
  inline void set_has_row();
  inline void clear_has_row();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 depth_;
  ::google::protobuf::uint32 col_;
  ::google::protobuf::uint32 row_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static BuildingBlockRef* default_instance_;
};
// -------------------------------------------------------------------

class BuildingBlockList : public ::google::protobuf::Message {
 public:
  BuildingBlockList();
  virtual ~BuildingBlockList();

  BuildingBlockList(const BuildingBlockList& from);

  inline BuildingBlockList& operator=(const BuildingBlockList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildingBlockList& default_instance();

  void Swap(BuildingBlockList* other);

  // implements Message ----------------------------------------------

  BuildingBlockList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildingBlockList& from);
  void MergeFrom(const BuildingBlockList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // repeated .com.telenav.proto.map.BuildingBlockRef blockRefs = 2;
  inline int blockrefs_size() const;
  inline void clear_blockrefs();
  static const int kBlockRefsFieldNumber = 2;
  inline const ::com::telenav::proto::map::BuildingBlockRef& blockrefs(int index) const;
  inline ::com::telenav::proto::map::BuildingBlockRef* mutable_blockrefs(int index);
  inline ::com::telenav::proto::map::BuildingBlockRef* add_blockrefs();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BuildingBlockRef >&
      blockrefs() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BuildingBlockRef >*
      mutable_blockrefs();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.BuildingBlockList)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BuildingBlockRef > blockrefs_;
  ::google::protobuf::int32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static BuildingBlockList* default_instance_;
};
// -------------------------------------------------------------------

class BigTileConfig : public ::google::protobuf::Message {
 public:
  BigTileConfig();
  virtual ~BigTileConfig();

  BigTileConfig(const BigTileConfig& from);

  inline BigTileConfig& operator=(const BigTileConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BigTileConfig& default_instance();

  void Swap(BigTileConfig* other);

  // implements Message ----------------------------------------------

  BigTileConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BigTileConfig& from);
  void MergeFrom(const BigTileConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.telenav.proto.map.ZoomLevel zoomlevel = 1;
  inline int zoomlevel_size() const;
  inline void clear_zoomlevel();
  static const int kZoomlevelFieldNumber = 1;
  inline const ::com::telenav::proto::map::ZoomLevel& zoomlevel(int index) const;
  inline ::com::telenav::proto::map::ZoomLevel* mutable_zoomlevel(int index);
  inline ::com::telenav::proto::map::ZoomLevel* add_zoomlevel();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::ZoomLevel >&
      zoomlevel() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::ZoomLevel >*
      mutable_zoomlevel();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.BigTileConfig)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::ZoomLevel > zoomlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static BigTileConfig* default_instance_;
};
// -------------------------------------------------------------------

class ZoomLevel : public ::google::protobuf::Message {
 public:
  ZoomLevel();
  virtual ~ZoomLevel();

  ZoomLevel(const ZoomLevel& from);

  inline ZoomLevel& operator=(const ZoomLevel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZoomLevel& default_instance();

  void Swap(ZoomLevel* other);

  // implements Message ----------------------------------------------

  ZoomLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZoomLevel& from);
  void MergeFrom(const ZoomLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 power = 2;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 2;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.ZoomLevel)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_power();
  inline void clear_has_power();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_map_2evector_2eproto();
  friend void protobuf_AssignDesc_map_2evector_2eproto();
  friend void protobuf_ShutdownFile_map_2evector_2eproto();

  void InitAsDefaultInstance();
  static ZoomLevel* default_instance_;
};
// ===================================================================


// ===================================================================

// VectorMapRequest

// optional int32 zoomLevel = 1;
inline bool VectorMapRequest::has_zoomlevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VectorMapRequest::set_has_zoomlevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VectorMapRequest::clear_has_zoomlevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VectorMapRequest::clear_zoomlevel() {
  zoomlevel_ = 0;
  clear_has_zoomlevel();
}
inline ::google::protobuf::int32 VectorMapRequest::zoomlevel() const {
  return zoomlevel_;
}
inline void VectorMapRequest::set_zoomlevel(::google::protobuf::int32 value) {
  set_has_zoomlevel();
  zoomlevel_ = value;
}

// optional int32 x = 2;
inline bool VectorMapRequest::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VectorMapRequest::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VectorMapRequest::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VectorMapRequest::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 VectorMapRequest::x() const {
  return x_;
}
inline void VectorMapRequest::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 3;
inline bool VectorMapRequest::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VectorMapRequest::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VectorMapRequest::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VectorMapRequest::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 VectorMapRequest::y() const {
  return y_;
}
inline void VectorMapRequest::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional .com.telenav.proto.Context context = 4;
inline bool VectorMapRequest::has_context() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VectorMapRequest::set_has_context() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VectorMapRequest::clear_has_context() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VectorMapRequest::clear_context() {
  if (context_ != NULL) context_->::com::telenav::proto::Context::Clear();
  clear_has_context();
}
inline const ::com::telenav::proto::Context& VectorMapRequest::context() const {
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::com::telenav::proto::Context* VectorMapRequest::mutable_context() {
  set_has_context();
  if (context_ == NULL) context_ = new ::com::telenav::proto::Context;
  return context_;
}
inline ::com::telenav::proto::Context* VectorMapRequest::release_context() {
  clear_has_context();
  ::com::telenav::proto::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline void VectorMapRequest::set_allocated_context(::com::telenav::proto::Context* context) {
  delete context_;
  context_ = context;
  if (context) {
    set_has_context();
  } else {
    clear_has_context();
  }
}

// -------------------------------------------------------------------

// TfcObj

// optional string trafficId = 1;
inline bool TfcObj::has_trafficid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TfcObj::set_has_trafficid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TfcObj::clear_has_trafficid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TfcObj::clear_trafficid() {
  if (trafficid_ != &::google::protobuf::internal::kEmptyString) {
    trafficid_->clear();
  }
  clear_has_trafficid();
}
inline const ::std::string& TfcObj::trafficid() const {
  return *trafficid_;
}
inline void TfcObj::set_trafficid(const ::std::string& value) {
  set_has_trafficid();
  if (trafficid_ == &::google::protobuf::internal::kEmptyString) {
    trafficid_ = new ::std::string;
  }
  trafficid_->assign(value);
}
inline void TfcObj::set_trafficid(const char* value) {
  set_has_trafficid();
  if (trafficid_ == &::google::protobuf::internal::kEmptyString) {
    trafficid_ = new ::std::string;
  }
  trafficid_->assign(value);
}
inline void TfcObj::set_trafficid(const char* value, size_t size) {
  set_has_trafficid();
  if (trafficid_ == &::google::protobuf::internal::kEmptyString) {
    trafficid_ = new ::std::string;
  }
  trafficid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TfcObj::mutable_trafficid() {
  set_has_trafficid();
  if (trafficid_ == &::google::protobuf::internal::kEmptyString) {
    trafficid_ = new ::std::string;
  }
  return trafficid_;
}
inline ::std::string* TfcObj::release_trafficid() {
  clear_has_trafficid();
  if (trafficid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trafficid_;
    trafficid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TfcObj::set_allocated_trafficid(::std::string* trafficid) {
  if (trafficid_ != &::google::protobuf::internal::kEmptyString) {
    delete trafficid_;
  }
  if (trafficid) {
    set_has_trafficid();
    trafficid_ = trafficid;
  } else {
    clear_has_trafficid();
    trafficid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 start_idx = 2;
inline bool TfcObj::has_start_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TfcObj::set_has_start_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TfcObj::clear_has_start_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TfcObj::clear_start_idx() {
  start_idx_ = 0u;
  clear_has_start_idx();
}
inline ::google::protobuf::uint32 TfcObj::start_idx() const {
  return start_idx_;
}
inline void TfcObj::set_start_idx(::google::protobuf::uint32 value) {
  set_has_start_idx();
  start_idx_ = value;
}

// optional uint32 end_idx = 3;
inline bool TfcObj::has_end_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TfcObj::set_has_end_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TfcObj::clear_has_end_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TfcObj::clear_end_idx() {
  end_idx_ = 0u;
  clear_has_end_idx();
}
inline ::google::protobuf::uint32 TfcObj::end_idx() const {
  return end_idx_;
}
inline void TfcObj::set_end_idx(::google::protobuf::uint32 value) {
  set_has_end_idx();
  end_idx_ = value;
}

// -------------------------------------------------------------------

// Polygon

// repeated sint32 latlon = 1 [packed = true];
inline int Polygon::latlon_size() const {
  return latlon_.size();
}
inline void Polygon::clear_latlon() {
  latlon_.Clear();
}
inline ::google::protobuf::int32 Polygon::latlon(int index) const {
  return latlon_.Get(index);
}
inline void Polygon::set_latlon(int index, ::google::protobuf::int32 value) {
  latlon_.Set(index, value);
}
inline void Polygon::add_latlon(::google::protobuf::int32 value) {
  latlon_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Polygon::latlon() const {
  return latlon_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Polygon::mutable_latlon() {
  return &latlon_;
}

// optional .com.telenav.proto.map.RingOrientation orient = 2 [default = OR_UNKNOWN];
inline bool Polygon::has_orient() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Polygon::set_has_orient() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Polygon::clear_has_orient() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Polygon::clear_orient() {
  orient_ = 0;
  clear_has_orient();
}
inline ::com::telenav::proto::map::RingOrientation Polygon::orient() const {
  return static_cast< ::com::telenav::proto::map::RingOrientation >(orient_);
}
inline void Polygon::set_orient(::com::telenav::proto::map::RingOrientation value) {
  assert(::com::telenav::proto::map::RingOrientation_IsValid(value));
  set_has_orient();
  orient_ = value;
}

// -------------------------------------------------------------------

// Polyline

// repeated sint32 latlon = 1 [packed = true];
inline int Polyline::latlon_size() const {
  return latlon_.size();
}
inline void Polyline::clear_latlon() {
  latlon_.Clear();
}
inline ::google::protobuf::int32 Polyline::latlon(int index) const {
  return latlon_.Get(index);
}
inline void Polyline::set_latlon(int index, ::google::protobuf::int32 value) {
  latlon_.Set(index, value);
}
inline void Polyline::add_latlon(::google::protobuf::int32 value) {
  latlon_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Polyline::latlon() const {
  return latlon_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Polyline::mutable_latlon() {
  return &latlon_;
}

// repeated .com.telenav.proto.map.TfcObj tfcId_right = 2;
inline int Polyline::tfcid_right_size() const {
  return tfcid_right_.size();
}
inline void Polyline::clear_tfcid_right() {
  tfcid_right_.Clear();
}
inline const ::com::telenav::proto::map::TfcObj& Polyline::tfcid_right(int index) const {
  return tfcid_right_.Get(index);
}
inline ::com::telenav::proto::map::TfcObj* Polyline::mutable_tfcid_right(int index) {
  return tfcid_right_.Mutable(index);
}
inline ::com::telenav::proto::map::TfcObj* Polyline::add_tfcid_right() {
  return tfcid_right_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TfcObj >&
Polyline::tfcid_right() const {
  return tfcid_right_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TfcObj >*
Polyline::mutable_tfcid_right() {
  return &tfcid_right_;
}

// repeated .com.telenav.proto.map.TfcObj tfcId_left = 3;
inline int Polyline::tfcid_left_size() const {
  return tfcid_left_.size();
}
inline void Polyline::clear_tfcid_left() {
  tfcid_left_.Clear();
}
inline const ::com::telenav::proto::map::TfcObj& Polyline::tfcid_left(int index) const {
  return tfcid_left_.Get(index);
}
inline ::com::telenav::proto::map::TfcObj* Polyline::mutable_tfcid_left(int index) {
  return tfcid_left_.Mutable(index);
}
inline ::com::telenav::proto::map::TfcObj* Polyline::add_tfcid_left() {
  return tfcid_left_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TfcObj >&
Polyline::tfcid_left() const {
  return tfcid_left_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::TfcObj >*
Polyline::mutable_tfcid_left() {
  return &tfcid_left_;
}

// -------------------------------------------------------------------

// VectorTrafficTile

// repeated uint32 tmcIds = 1 [packed = true];
inline int VectorTrafficTile::tmcids_size() const {
  return tmcids_.size();
}
inline void VectorTrafficTile::clear_tmcids() {
  tmcids_.Clear();
}
inline ::google::protobuf::uint32 VectorTrafficTile::tmcids(int index) const {
  return tmcids_.Get(index);
}
inline void VectorTrafficTile::set_tmcids(int index, ::google::protobuf::uint32 value) {
  tmcids_.Set(index, value);
}
inline void VectorTrafficTile::add_tmcids(::google::protobuf::uint32 value) {
  tmcids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VectorTrafficTile::tmcids() const {
  return tmcids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VectorTrafficTile::mutable_tmcids() {
  return &tmcids_;
}

// -------------------------------------------------------------------

// VectorMapTile

// repeated .com.telenav.proto.map.RoadFeature rf = 1;
inline int VectorMapTile::rf_size() const {
  return rf_.size();
}
inline void VectorMapTile::clear_rf() {
  rf_.Clear();
}
inline const ::com::telenav::proto::map::RoadFeature& VectorMapTile::rf(int index) const {
  return rf_.Get(index);
}
inline ::com::telenav::proto::map::RoadFeature* VectorMapTile::mutable_rf(int index) {
  return rf_.Mutable(index);
}
inline ::com::telenav::proto::map::RoadFeature* VectorMapTile::add_rf() {
  return rf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::RoadFeature >&
VectorMapTile::rf() const {
  return rf_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::RoadFeature >*
VectorMapTile::mutable_rf() {
  return &rf_;
}

// repeated .com.telenav.proto.map.AreaFeature af = 2;
inline int VectorMapTile::af_size() const {
  return af_.size();
}
inline void VectorMapTile::clear_af() {
  af_.Clear();
}
inline const ::com::telenav::proto::map::AreaFeature& VectorMapTile::af(int index) const {
  return af_.Get(index);
}
inline ::com::telenav::proto::map::AreaFeature* VectorMapTile::mutable_af(int index) {
  return af_.Mutable(index);
}
inline ::com::telenav::proto::map::AreaFeature* VectorMapTile::add_af() {
  return af_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::AreaFeature >&
VectorMapTile::af() const {
  return af_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::AreaFeature >*
VectorMapTile::mutable_af() {
  return &af_;
}

// repeated .com.telenav.proto.map.LineFeature lf = 3;
inline int VectorMapTile::lf_size() const {
  return lf_.size();
}
inline void VectorMapTile::clear_lf() {
  lf_.Clear();
}
inline const ::com::telenav::proto::map::LineFeature& VectorMapTile::lf(int index) const {
  return lf_.Get(index);
}
inline ::com::telenav::proto::map::LineFeature* VectorMapTile::mutable_lf(int index) {
  return lf_.Mutable(index);
}
inline ::com::telenav::proto::map::LineFeature* VectorMapTile::add_lf() {
  return lf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::LineFeature >&
VectorMapTile::lf() const {
  return lf_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::LineFeature >*
VectorMapTile::mutable_lf() {
  return &lf_;
}

// repeated .com.telenav.proto.map.PointFeature pf = 4;
inline int VectorMapTile::pf_size() const {
  return pf_.size();
}
inline void VectorMapTile::clear_pf() {
  pf_.Clear();
}
inline const ::com::telenav::proto::map::PointFeature& VectorMapTile::pf(int index) const {
  return pf_.Get(index);
}
inline ::com::telenav::proto::map::PointFeature* VectorMapTile::mutable_pf(int index) {
  return pf_.Mutable(index);
}
inline ::com::telenav::proto::map::PointFeature* VectorMapTile::add_pf() {
  return pf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::PointFeature >&
VectorMapTile::pf() const {
  return pf_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::PointFeature >*
VectorMapTile::mutable_pf() {
  return &pf_;
}

// optional .com.telenav.proto.map.BuildingBlockList buildingBlockList = 5;
inline bool VectorMapTile::has_buildingblocklist() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VectorMapTile::set_has_buildingblocklist() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VectorMapTile::clear_has_buildingblocklist() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VectorMapTile::clear_buildingblocklist() {
  if (buildingblocklist_ != NULL) buildingblocklist_->::com::telenav::proto::map::BuildingBlockList::Clear();
  clear_has_buildingblocklist();
}
inline const ::com::telenav::proto::map::BuildingBlockList& VectorMapTile::buildingblocklist() const {
  return buildingblocklist_ != NULL ? *buildingblocklist_ : *default_instance_->buildingblocklist_;
}
inline ::com::telenav::proto::map::BuildingBlockList* VectorMapTile::mutable_buildingblocklist() {
  set_has_buildingblocklist();
  if (buildingblocklist_ == NULL) buildingblocklist_ = new ::com::telenav::proto::map::BuildingBlockList;
  return buildingblocklist_;
}
inline ::com::telenav::proto::map::BuildingBlockList* VectorMapTile::release_buildingblocklist() {
  clear_has_buildingblocklist();
  ::com::telenav::proto::map::BuildingBlockList* temp = buildingblocklist_;
  buildingblocklist_ = NULL;
  return temp;
}
inline void VectorMapTile::set_allocated_buildingblocklist(::com::telenav::proto::map::BuildingBlockList* buildingblocklist) {
  delete buildingblocklist_;
  buildingblocklist_ = buildingblocklist;
  if (buildingblocklist) {
    set_has_buildingblocklist();
  } else {
    clear_has_buildingblocklist();
  }
}

// optional string dataVersion = 6;
inline bool VectorMapTile::has_dataversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VectorMapTile::set_has_dataversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VectorMapTile::clear_has_dataversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VectorMapTile::clear_dataversion() {
  if (dataversion_ != &::google::protobuf::internal::kEmptyString) {
    dataversion_->clear();
  }
  clear_has_dataversion();
}
inline const ::std::string& VectorMapTile::dataversion() const {
  return *dataversion_;
}
inline void VectorMapTile::set_dataversion(const ::std::string& value) {
  set_has_dataversion();
  if (dataversion_ == &::google::protobuf::internal::kEmptyString) {
    dataversion_ = new ::std::string;
  }
  dataversion_->assign(value);
}
inline void VectorMapTile::set_dataversion(const char* value) {
  set_has_dataversion();
  if (dataversion_ == &::google::protobuf::internal::kEmptyString) {
    dataversion_ = new ::std::string;
  }
  dataversion_->assign(value);
}
inline void VectorMapTile::set_dataversion(const char* value, size_t size) {
  set_has_dataversion();
  if (dataversion_ == &::google::protobuf::internal::kEmptyString) {
    dataversion_ = new ::std::string;
  }
  dataversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VectorMapTile::mutable_dataversion() {
  set_has_dataversion();
  if (dataversion_ == &::google::protobuf::internal::kEmptyString) {
    dataversion_ = new ::std::string;
  }
  return dataversion_;
}
inline ::std::string* VectorMapTile::release_dataversion() {
  clear_has_dataversion();
  if (dataversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dataversion_;
    dataversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VectorMapTile::set_allocated_dataversion(::std::string* dataversion) {
  if (dataversion_ != &::google::protobuf::internal::kEmptyString) {
    delete dataversion_;
  }
  if (dataversion) {
    set_has_dataversion();
    dataversion_ = dataversion;
  } else {
    clear_has_dataversion();
    dataversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FeatureName

// optional string name = 1;
inline bool FeatureName::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureName::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureName::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeatureName::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FeatureName::name() const {
  return *name_;
}
inline void FeatureName::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FeatureName::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FeatureName::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeatureName::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FeatureName::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeatureName::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alias = 2;
inline bool FeatureName::has_alias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeatureName::set_has_alias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeatureName::clear_has_alias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeatureName::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& FeatureName::alias() const {
  return *alias_;
}
inline void FeatureName::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void FeatureName::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void FeatureName::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeatureName::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* FeatureName::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeatureName::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string language = 3;
inline bool FeatureName::has_language() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeatureName::set_has_language() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeatureName::clear_has_language() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeatureName::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& FeatureName::language() const {
  return *language_;
}
inline void FeatureName::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void FeatureName::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void FeatureName::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeatureName::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* FeatureName::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeatureName::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HighwayShield

// optional string number = 1;
inline bool HighwayShield::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HighwayShield::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HighwayShield::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HighwayShield::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& HighwayShield::number() const {
  return *number_;
}
inline void HighwayShield::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void HighwayShield::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void HighwayShield::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HighwayShield::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* HighwayShield::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HighwayShield::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string iconID = 2;
inline bool HighwayShield::has_iconid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HighwayShield::set_has_iconid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HighwayShield::clear_has_iconid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HighwayShield::clear_iconid() {
  if (iconid_ != &::google::protobuf::internal::kEmptyString) {
    iconid_->clear();
  }
  clear_has_iconid();
}
inline const ::std::string& HighwayShield::iconid() const {
  return *iconid_;
}
inline void HighwayShield::set_iconid(const ::std::string& value) {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::kEmptyString) {
    iconid_ = new ::std::string;
  }
  iconid_->assign(value);
}
inline void HighwayShield::set_iconid(const char* value) {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::kEmptyString) {
    iconid_ = new ::std::string;
  }
  iconid_->assign(value);
}
inline void HighwayShield::set_iconid(const char* value, size_t size) {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::kEmptyString) {
    iconid_ = new ::std::string;
  }
  iconid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HighwayShield::mutable_iconid() {
  set_has_iconid();
  if (iconid_ == &::google::protobuf::internal::kEmptyString) {
    iconid_ = new ::std::string;
  }
  return iconid_;
}
inline ::std::string* HighwayShield::release_iconid() {
  clear_has_iconid();
  if (iconid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iconid_;
    iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HighwayShield::set_allocated_iconid(::std::string* iconid) {
  if (iconid_ != &::google::protobuf::internal::kEmptyString) {
    delete iconid_;
  }
  if (iconid) {
    set_has_iconid();
    iconid_ = iconid;
  } else {
    clear_has_iconid();
    iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoadFeature

// repeated .com.telenav.proto.map.Polyline lines = 1;
inline int RoadFeature::lines_size() const {
  return lines_.size();
}
inline void RoadFeature::clear_lines() {
  lines_.Clear();
}
inline const ::com::telenav::proto::map::Polyline& RoadFeature::lines(int index) const {
  return lines_.Get(index);
}
inline ::com::telenav::proto::map::Polyline* RoadFeature::mutable_lines(int index) {
  return lines_.Mutable(index);
}
inline ::com::telenav::proto::map::Polyline* RoadFeature::add_lines() {
  return lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polyline >&
RoadFeature::lines() const {
  return lines_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polyline >*
RoadFeature::mutable_lines() {
  return &lines_;
}

// optional .com.telenav.proto.map.RoadType roadType = 2 [default = RT_UNKNOWN];
inline bool RoadFeature::has_roadtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoadFeature::set_has_roadtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoadFeature::clear_has_roadtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoadFeature::clear_roadtype() {
  roadtype_ = 0;
  clear_has_roadtype();
}
inline ::com::telenav::proto::map::RoadType RoadFeature::roadtype() const {
  return static_cast< ::com::telenav::proto::map::RoadType >(roadtype_);
}
inline void RoadFeature::set_roadtype(::com::telenav::proto::map::RoadType value) {
  assert(::com::telenav::proto::map::RoadType_IsValid(value));
  set_has_roadtype();
  roadtype_ = value;
}

// optional .com.telenav.proto.map.RoadSubType roadSubType = 3 [default = RST_UNKNOWN];
inline bool RoadFeature::has_roadsubtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoadFeature::set_has_roadsubtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoadFeature::clear_has_roadsubtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoadFeature::clear_roadsubtype() {
  roadsubtype_ = 0;
  clear_has_roadsubtype();
}
inline ::com::telenav::proto::map::RoadSubType RoadFeature::roadsubtype() const {
  return static_cast< ::com::telenav::proto::map::RoadSubType >(roadsubtype_);
}
inline void RoadFeature::set_roadsubtype(::com::telenav::proto::map::RoadSubType value) {
  assert(::com::telenav::proto::map::RoadSubType_IsValid(value));
  set_has_roadsubtype();
  roadsubtype_ = value;
}

// optional string roadName = 4;
inline bool RoadFeature::has_roadname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoadFeature::set_has_roadname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoadFeature::clear_has_roadname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoadFeature::clear_roadname() {
  if (roadname_ != &::google::protobuf::internal::kEmptyString) {
    roadname_->clear();
  }
  clear_has_roadname();
}
inline const ::std::string& RoadFeature::roadname() const {
  return *roadname_;
}
inline void RoadFeature::set_roadname(const ::std::string& value) {
  set_has_roadname();
  if (roadname_ == &::google::protobuf::internal::kEmptyString) {
    roadname_ = new ::std::string;
  }
  roadname_->assign(value);
}
inline void RoadFeature::set_roadname(const char* value) {
  set_has_roadname();
  if (roadname_ == &::google::protobuf::internal::kEmptyString) {
    roadname_ = new ::std::string;
  }
  roadname_->assign(value);
}
inline void RoadFeature::set_roadname(const char* value, size_t size) {
  set_has_roadname();
  if (roadname_ == &::google::protobuf::internal::kEmptyString) {
    roadname_ = new ::std::string;
  }
  roadname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoadFeature::mutable_roadname() {
  set_has_roadname();
  if (roadname_ == &::google::protobuf::internal::kEmptyString) {
    roadname_ = new ::std::string;
  }
  return roadname_;
}
inline ::std::string* RoadFeature::release_roadname() {
  clear_has_roadname();
  if (roadname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roadname_;
    roadname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoadFeature::set_allocated_roadname(::std::string* roadname) {
  if (roadname_ != &::google::protobuf::internal::kEmptyString) {
    delete roadname_;
  }
  if (roadname) {
    set_has_roadname();
    roadname_ = roadname;
  } else {
    clear_has_roadname();
    roadname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string roadAlias = 5;
inline bool RoadFeature::has_roadalias() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoadFeature::set_has_roadalias() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoadFeature::clear_has_roadalias() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoadFeature::clear_roadalias() {
  if (roadalias_ != &::google::protobuf::internal::kEmptyString) {
    roadalias_->clear();
  }
  clear_has_roadalias();
}
inline const ::std::string& RoadFeature::roadalias() const {
  return *roadalias_;
}
inline void RoadFeature::set_roadalias(const ::std::string& value) {
  set_has_roadalias();
  if (roadalias_ == &::google::protobuf::internal::kEmptyString) {
    roadalias_ = new ::std::string;
  }
  roadalias_->assign(value);
}
inline void RoadFeature::set_roadalias(const char* value) {
  set_has_roadalias();
  if (roadalias_ == &::google::protobuf::internal::kEmptyString) {
    roadalias_ = new ::std::string;
  }
  roadalias_->assign(value);
}
inline void RoadFeature::set_roadalias(const char* value, size_t size) {
  set_has_roadalias();
  if (roadalias_ == &::google::protobuf::internal::kEmptyString) {
    roadalias_ = new ::std::string;
  }
  roadalias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoadFeature::mutable_roadalias() {
  set_has_roadalias();
  if (roadalias_ == &::google::protobuf::internal::kEmptyString) {
    roadalias_ = new ::std::string;
  }
  return roadalias_;
}
inline ::std::string* RoadFeature::release_roadalias() {
  clear_has_roadalias();
  if (roadalias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roadalias_;
    roadalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoadFeature::set_allocated_roadalias(::std::string* roadalias) {
  if (roadalias_ != &::google::protobuf::internal::kEmptyString) {
    delete roadalias_;
  }
  if (roadalias) {
    set_has_roadalias();
    roadalias_ = roadalias;
  } else {
    clear_has_roadalias();
    roadalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 featureID = 15;
inline bool RoadFeature::has_featureid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoadFeature::set_has_featureid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoadFeature::clear_has_featureid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoadFeature::clear_featureid() {
  featureid_ = GOOGLE_ULONGLONG(0);
  clear_has_featureid();
}
inline ::google::protobuf::uint64 RoadFeature::featureid() const {
  return featureid_;
}
inline void RoadFeature::set_featureid(::google::protobuf::uint64 value) {
  set_has_featureid();
  featureid_ = value;
}

// repeated .com.telenav.proto.map.FeatureName roadNames = 6;
inline int RoadFeature::roadnames_size() const {
  return roadnames_.size();
}
inline void RoadFeature::clear_roadnames() {
  roadnames_.Clear();
}
inline const ::com::telenav::proto::map::FeatureName& RoadFeature::roadnames(int index) const {
  return roadnames_.Get(index);
}
inline ::com::telenav::proto::map::FeatureName* RoadFeature::mutable_roadnames(int index) {
  return roadnames_.Mutable(index);
}
inline ::com::telenav::proto::map::FeatureName* RoadFeature::add_roadnames() {
  return roadnames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >&
RoadFeature::roadnames() const {
  return roadnames_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >*
RoadFeature::mutable_roadnames() {
  return &roadnames_;
}

// repeated .com.telenav.proto.map.HighwayShield shields = 7;
inline int RoadFeature::shields_size() const {
  return shields_.size();
}
inline void RoadFeature::clear_shields() {
  shields_.Clear();
}
inline const ::com::telenav::proto::map::HighwayShield& RoadFeature::shields(int index) const {
  return shields_.Get(index);
}
inline ::com::telenav::proto::map::HighwayShield* RoadFeature::mutable_shields(int index) {
  return shields_.Mutable(index);
}
inline ::com::telenav::proto::map::HighwayShield* RoadFeature::add_shields() {
  return shields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::HighwayShield >&
RoadFeature::shields() const {
  return shields_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::HighwayShield >*
RoadFeature::mutable_shields() {
  return &shields_;
}

// optional .com.telenav.proto.map.RoadFunctionClass roadFunctionClass = 8;
inline bool RoadFeature::has_roadfunctionclass() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoadFeature::set_has_roadfunctionclass() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoadFeature::clear_has_roadfunctionclass() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoadFeature::clear_roadfunctionclass() {
  roadfunctionclass_ = 1;
  clear_has_roadfunctionclass();
}
inline ::com::telenav::proto::map::RoadFunctionClass RoadFeature::roadfunctionclass() const {
  return static_cast< ::com::telenav::proto::map::RoadFunctionClass >(roadfunctionclass_);
}
inline void RoadFeature::set_roadfunctionclass(::com::telenav::proto::map::RoadFunctionClass value) {
  assert(::com::telenav::proto::map::RoadFunctionClass_IsValid(value));
  set_has_roadfunctionclass();
  roadfunctionclass_ = value;
}

// optional .com.telenav.proto.map.RoadDirection roadDirection = 9 [default = UNKONWN];
inline bool RoadFeature::has_roaddirection() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RoadFeature::set_has_roaddirection() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RoadFeature::clear_has_roaddirection() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RoadFeature::clear_roaddirection() {
  roaddirection_ = 4;
  clear_has_roaddirection();
}
inline ::com::telenav::proto::map::RoadDirection RoadFeature::roaddirection() const {
  return static_cast< ::com::telenav::proto::map::RoadDirection >(roaddirection_);
}
inline void RoadFeature::set_roaddirection(::com::telenav::proto::map::RoadDirection value) {
  assert(::com::telenav::proto::map::RoadDirection_IsValid(value));
  set_has_roaddirection();
  roaddirection_ = value;
}

// -------------------------------------------------------------------

// AreaFeature

// repeated .com.telenav.proto.map.Polygon rings = 1;
inline int AreaFeature::rings_size() const {
  return rings_.size();
}
inline void AreaFeature::clear_rings() {
  rings_.Clear();
}
inline const ::com::telenav::proto::map::Polygon& AreaFeature::rings(int index) const {
  return rings_.Get(index);
}
inline ::com::telenav::proto::map::Polygon* AreaFeature::mutable_rings(int index) {
  return rings_.Mutable(index);
}
inline ::com::telenav::proto::map::Polygon* AreaFeature::add_rings() {
  return rings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polygon >&
AreaFeature::rings() const {
  return rings_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polygon >*
AreaFeature::mutable_rings() {
  return &rings_;
}

// optional string name = 2;
inline bool AreaFeature::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AreaFeature::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AreaFeature::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AreaFeature::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AreaFeature::name() const {
  return *name_;
}
inline void AreaFeature::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AreaFeature::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AreaFeature::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AreaFeature::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AreaFeature::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AreaFeature::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.telenav.proto.map.AreaType mainType = 3 [default = BK_AREA_UNKNOWN];
inline bool AreaFeature::has_maintype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AreaFeature::set_has_maintype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AreaFeature::clear_has_maintype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AreaFeature::clear_maintype() {
  maintype_ = 0;
  clear_has_maintype();
}
inline ::com::telenav::proto::map::AreaType AreaFeature::maintype() const {
  return static_cast< ::com::telenav::proto::map::AreaType >(maintype_);
}
inline void AreaFeature::set_maintype(::com::telenav::proto::map::AreaType value) {
  assert(::com::telenav::proto::map::AreaType_IsValid(value));
  set_has_maintype();
  maintype_ = value;
}

// optional string subType = 4;
inline bool AreaFeature::has_subtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AreaFeature::set_has_subtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AreaFeature::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AreaFeature::clear_subtype() {
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    subtype_->clear();
  }
  clear_has_subtype();
}
inline const ::std::string& AreaFeature::subtype() const {
  return *subtype_;
}
inline void AreaFeature::set_subtype(const ::std::string& value) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(value);
}
inline void AreaFeature::set_subtype(const char* value) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(value);
}
inline void AreaFeature::set_subtype(const char* value, size_t size) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AreaFeature::mutable_subtype() {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  return subtype_;
}
inline ::std::string* AreaFeature::release_subtype() {
  clear_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtype_;
    subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AreaFeature::set_allocated_subtype(::std::string* subtype) {
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    delete subtype_;
  }
  if (subtype) {
    set_has_subtype();
    subtype_ = subtype;
  } else {
    clear_has_subtype();
    subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 featureID = 15;
inline bool AreaFeature::has_featureid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AreaFeature::set_has_featureid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AreaFeature::clear_has_featureid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AreaFeature::clear_featureid() {
  featureid_ = GOOGLE_ULONGLONG(0);
  clear_has_featureid();
}
inline ::google::protobuf::uint64 AreaFeature::featureid() const {
  return featureid_;
}
inline void AreaFeature::set_featureid(::google::protobuf::uint64 value) {
  set_has_featureid();
  featureid_ = value;
}

// repeated .com.telenav.proto.map.FeatureName areaNames = 5;
inline int AreaFeature::areanames_size() const {
  return areanames_.size();
}
inline void AreaFeature::clear_areanames() {
  areanames_.Clear();
}
inline const ::com::telenav::proto::map::FeatureName& AreaFeature::areanames(int index) const {
  return areanames_.Get(index);
}
inline ::com::telenav::proto::map::FeatureName* AreaFeature::mutable_areanames(int index) {
  return areanames_.Mutable(index);
}
inline ::com::telenav::proto::map::FeatureName* AreaFeature::add_areanames() {
  return areanames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >&
AreaFeature::areanames() const {
  return areanames_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >*
AreaFeature::mutable_areanames() {
  return &areanames_;
}

// -------------------------------------------------------------------

// LineFeature

// repeated .com.telenav.proto.map.Polyline lines = 1;
inline int LineFeature::lines_size() const {
  return lines_.size();
}
inline void LineFeature::clear_lines() {
  lines_.Clear();
}
inline const ::com::telenav::proto::map::Polyline& LineFeature::lines(int index) const {
  return lines_.Get(index);
}
inline ::com::telenav::proto::map::Polyline* LineFeature::mutable_lines(int index) {
  return lines_.Mutable(index);
}
inline ::com::telenav::proto::map::Polyline* LineFeature::add_lines() {
  return lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polyline >&
LineFeature::lines() const {
  return lines_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Polyline >*
LineFeature::mutable_lines() {
  return &lines_;
}

// optional string name = 2;
inline bool LineFeature::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineFeature::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineFeature::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineFeature::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LineFeature::name() const {
  return *name_;
}
inline void LineFeature::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LineFeature::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LineFeature::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LineFeature::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LineFeature::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LineFeature::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.telenav.proto.map.LineType mainType = 3 [default = BK_LINE_UNKNOWN];
inline bool LineFeature::has_maintype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LineFeature::set_has_maintype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LineFeature::clear_has_maintype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LineFeature::clear_maintype() {
  maintype_ = 0;
  clear_has_maintype();
}
inline ::com::telenav::proto::map::LineType LineFeature::maintype() const {
  return static_cast< ::com::telenav::proto::map::LineType >(maintype_);
}
inline void LineFeature::set_maintype(::com::telenav::proto::map::LineType value) {
  assert(::com::telenav::proto::map::LineType_IsValid(value));
  set_has_maintype();
  maintype_ = value;
}

// optional string subType = 4;
inline bool LineFeature::has_subtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LineFeature::set_has_subtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LineFeature::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LineFeature::clear_subtype() {
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    subtype_->clear();
  }
  clear_has_subtype();
}
inline const ::std::string& LineFeature::subtype() const {
  return *subtype_;
}
inline void LineFeature::set_subtype(const ::std::string& value) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(value);
}
inline void LineFeature::set_subtype(const char* value) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(value);
}
inline void LineFeature::set_subtype(const char* value, size_t size) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LineFeature::mutable_subtype() {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  return subtype_;
}
inline ::std::string* LineFeature::release_subtype() {
  clear_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtype_;
    subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LineFeature::set_allocated_subtype(::std::string* subtype) {
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    delete subtype_;
  }
  if (subtype) {
    set_has_subtype();
    subtype_ = subtype;
  } else {
    clear_has_subtype();
    subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 featureID = 15;
inline bool LineFeature::has_featureid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LineFeature::set_has_featureid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LineFeature::clear_has_featureid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LineFeature::clear_featureid() {
  featureid_ = GOOGLE_ULONGLONG(0);
  clear_has_featureid();
}
inline ::google::protobuf::uint64 LineFeature::featureid() const {
  return featureid_;
}
inline void LineFeature::set_featureid(::google::protobuf::uint64 value) {
  set_has_featureid();
  featureid_ = value;
}

// repeated .com.telenav.proto.map.FeatureName names = 6;
inline int LineFeature::names_size() const {
  return names_.size();
}
inline void LineFeature::clear_names() {
  names_.Clear();
}
inline const ::com::telenav::proto::map::FeatureName& LineFeature::names(int index) const {
  return names_.Get(index);
}
inline ::com::telenav::proto::map::FeatureName* LineFeature::mutable_names(int index) {
  return names_.Mutable(index);
}
inline ::com::telenav::proto::map::FeatureName* LineFeature::add_names() {
  return names_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >&
LineFeature::names() const {
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >*
LineFeature::mutable_names() {
  return &names_;
}

// -------------------------------------------------------------------

// PointFeature

// repeated sint32 latlon = 1 [packed = true];
inline int PointFeature::latlon_size() const {
  return latlon_.size();
}
inline void PointFeature::clear_latlon() {
  latlon_.Clear();
}
inline ::google::protobuf::int32 PointFeature::latlon(int index) const {
  return latlon_.Get(index);
}
inline void PointFeature::set_latlon(int index, ::google::protobuf::int32 value) {
  latlon_.Set(index, value);
}
inline void PointFeature::add_latlon(::google::protobuf::int32 value) {
  latlon_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PointFeature::latlon() const {
  return latlon_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PointFeature::mutable_latlon() {
  return &latlon_;
}

// optional .com.telenav.proto.map.PointType mainType = 2 [default = PT_UNKNOWN];
inline bool PointFeature::has_maintype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointFeature::set_has_maintype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointFeature::clear_has_maintype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointFeature::clear_maintype() {
  maintype_ = 0;
  clear_has_maintype();
}
inline ::com::telenav::proto::map::PointType PointFeature::maintype() const {
  return static_cast< ::com::telenav::proto::map::PointType >(maintype_);
}
inline void PointFeature::set_maintype(::com::telenav::proto::map::PointType value) {
  assert(::com::telenav::proto::map::PointType_IsValid(value));
  set_has_maintype();
  maintype_ = value;
}

// optional string subType = 3;
inline bool PointFeature::has_subtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointFeature::set_has_subtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointFeature::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointFeature::clear_subtype() {
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    subtype_->clear();
  }
  clear_has_subtype();
}
inline const ::std::string& PointFeature::subtype() const {
  return *subtype_;
}
inline void PointFeature::set_subtype(const ::std::string& value) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(value);
}
inline void PointFeature::set_subtype(const char* value) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(value);
}
inline void PointFeature::set_subtype(const char* value, size_t size) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PointFeature::mutable_subtype() {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  return subtype_;
}
inline ::std::string* PointFeature::release_subtype() {
  clear_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtype_;
    subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PointFeature::set_allocated_subtype(::std::string* subtype) {
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    delete subtype_;
  }
  if (subtype) {
    set_has_subtype();
    subtype_ = subtype;
  } else {
    clear_has_subtype();
    subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 4;
inline bool PointFeature::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PointFeature::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PointFeature::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PointFeature::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PointFeature::name() const {
  return *name_;
}
inline void PointFeature::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PointFeature::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PointFeature::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PointFeature::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PointFeature::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PointFeature::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fontSize = 5;
inline bool PointFeature::has_fontsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PointFeature::set_has_fontsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PointFeature::clear_has_fontsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PointFeature::clear_fontsize() {
  fontsize_ = 0;
  clear_has_fontsize();
}
inline ::google::protobuf::int32 PointFeature::fontsize() const {
  return fontsize_;
}
inline void PointFeature::set_fontsize(::google::protobuf::int32 value) {
  set_has_fontsize();
  fontsize_ = value;
}

// optional string country = 6;
inline bool PointFeature::has_country() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PointFeature::set_has_country() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PointFeature::clear_has_country() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PointFeature::clear_country() {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& PointFeature::country() const {
  return *country_;
}
inline void PointFeature::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void PointFeature::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void PointFeature::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PointFeature::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  return country_;
}
inline ::std::string* PointFeature::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PointFeature::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 rdNameOri = 7 [packed = true];
inline int PointFeature::rdnameori_size() const {
  return rdnameori_.size();
}
inline void PointFeature::clear_rdnameori() {
  rdnameori_.Clear();
}
inline ::google::protobuf::int32 PointFeature::rdnameori(int index) const {
  return rdnameori_.Get(index);
}
inline void PointFeature::set_rdnameori(int index, ::google::protobuf::int32 value) {
  rdnameori_.Set(index, value);
}
inline void PointFeature::add_rdnameori(::google::protobuf::int32 value) {
  rdnameori_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PointFeature::rdnameori() const {
  return rdnameori_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PointFeature::mutable_rdnameori() {
  return &rdnameori_;
}

// optional .com.telenav.proto.map.FontStyle fontStyle = 8;
inline bool PointFeature::has_fontstyle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PointFeature::set_has_fontstyle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PointFeature::clear_has_fontstyle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PointFeature::clear_fontstyle() {
  fontstyle_ = 0;
  clear_has_fontstyle();
}
inline ::com::telenav::proto::map::FontStyle PointFeature::fontstyle() const {
  return static_cast< ::com::telenav::proto::map::FontStyle >(fontstyle_);
}
inline void PointFeature::set_fontstyle(::com::telenav::proto::map::FontStyle value) {
  assert(::com::telenav::proto::map::FontStyle_IsValid(value));
  set_has_fontstyle();
  fontstyle_ = value;
}

// optional .com.telenav.proto.map.Polyline spline = 9;
inline bool PointFeature::has_spline() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PointFeature::set_has_spline() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PointFeature::clear_has_spline() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PointFeature::clear_spline() {
  if (spline_ != NULL) spline_->::com::telenav::proto::map::Polyline::Clear();
  clear_has_spline();
}
inline const ::com::telenav::proto::map::Polyline& PointFeature::spline() const {
  return spline_ != NULL ? *spline_ : *default_instance_->spline_;
}
inline ::com::telenav::proto::map::Polyline* PointFeature::mutable_spline() {
  set_has_spline();
  if (spline_ == NULL) spline_ = new ::com::telenav::proto::map::Polyline;
  return spline_;
}
inline ::com::telenav::proto::map::Polyline* PointFeature::release_spline() {
  clear_has_spline();
  ::com::telenav::proto::map::Polyline* temp = spline_;
  spline_ = NULL;
  return temp;
}
inline void PointFeature::set_allocated_spline(::com::telenav::proto::map::Polyline* spline) {
  delete spline_;
  spline_ = spline;
  if (spline) {
    set_has_spline();
  } else {
    clear_has_spline();
  }
}

// repeated uint64 p_featureID = 14;
inline int PointFeature::p_featureid_size() const {
  return p_featureid_.size();
}
inline void PointFeature::clear_p_featureid() {
  p_featureid_.Clear();
}
inline ::google::protobuf::uint64 PointFeature::p_featureid(int index) const {
  return p_featureid_.Get(index);
}
inline void PointFeature::set_p_featureid(int index, ::google::protobuf::uint64 value) {
  p_featureid_.Set(index, value);
}
inline void PointFeature::add_p_featureid(::google::protobuf::uint64 value) {
  p_featureid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
PointFeature::p_featureid() const {
  return p_featureid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
PointFeature::mutable_p_featureid() {
  return &p_featureid_;
}

// optional uint64 featureID = 15;
inline bool PointFeature::has_featureid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PointFeature::set_has_featureid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PointFeature::clear_has_featureid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PointFeature::clear_featureid() {
  featureid_ = GOOGLE_ULONGLONG(0);
  clear_has_featureid();
}
inline ::google::protobuf::uint64 PointFeature::featureid() const {
  return featureid_;
}
inline void PointFeature::set_featureid(::google::protobuf::uint64 value) {
  set_has_featureid();
  featureid_ = value;
}

// repeated .com.telenav.proto.map.FeatureName pointNames = 10;
inline int PointFeature::pointnames_size() const {
  return pointnames_.size();
}
inline void PointFeature::clear_pointnames() {
  pointnames_.Clear();
}
inline const ::com::telenav::proto::map::FeatureName& PointFeature::pointnames(int index) const {
  return pointnames_.Get(index);
}
inline ::com::telenav::proto::map::FeatureName* PointFeature::mutable_pointnames(int index) {
  return pointnames_.Mutable(index);
}
inline ::com::telenav::proto::map::FeatureName* PointFeature::add_pointnames() {
  return pointnames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >&
PointFeature::pointnames() const {
  return pointnames_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::FeatureName >*
PointFeature::mutable_pointnames() {
  return &pointnames_;
}

// optional string landmark_icon = 11;
inline bool PointFeature::has_landmark_icon() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PointFeature::set_has_landmark_icon() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PointFeature::clear_has_landmark_icon() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PointFeature::clear_landmark_icon() {
  if (landmark_icon_ != &::google::protobuf::internal::kEmptyString) {
    landmark_icon_->clear();
  }
  clear_has_landmark_icon();
}
inline const ::std::string& PointFeature::landmark_icon() const {
  return *landmark_icon_;
}
inline void PointFeature::set_landmark_icon(const ::std::string& value) {
  set_has_landmark_icon();
  if (landmark_icon_ == &::google::protobuf::internal::kEmptyString) {
    landmark_icon_ = new ::std::string;
  }
  landmark_icon_->assign(value);
}
inline void PointFeature::set_landmark_icon(const char* value) {
  set_has_landmark_icon();
  if (landmark_icon_ == &::google::protobuf::internal::kEmptyString) {
    landmark_icon_ = new ::std::string;
  }
  landmark_icon_->assign(value);
}
inline void PointFeature::set_landmark_icon(const char* value, size_t size) {
  set_has_landmark_icon();
  if (landmark_icon_ == &::google::protobuf::internal::kEmptyString) {
    landmark_icon_ = new ::std::string;
  }
  landmark_icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PointFeature::mutable_landmark_icon() {
  set_has_landmark_icon();
  if (landmark_icon_ == &::google::protobuf::internal::kEmptyString) {
    landmark_icon_ = new ::std::string;
  }
  return landmark_icon_;
}
inline ::std::string* PointFeature::release_landmark_icon() {
  clear_has_landmark_icon();
  if (landmark_icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = landmark_icon_;
    landmark_icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PointFeature::set_allocated_landmark_icon(::std::string* landmark_icon) {
  if (landmark_icon_ != &::google::protobuf::internal::kEmptyString) {
    delete landmark_icon_;
  }
  if (landmark_icon) {
    set_has_landmark_icon();
    landmark_icon_ = landmark_icon;
  } else {
    clear_has_landmark_icon();
    landmark_icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BuildingBlockRef

// optional uint32 depth = 1;
inline bool BuildingBlockRef::has_depth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildingBlockRef::set_has_depth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildingBlockRef::clear_has_depth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildingBlockRef::clear_depth() {
  depth_ = 0u;
  clear_has_depth();
}
inline ::google::protobuf::uint32 BuildingBlockRef::depth() const {
  return depth_;
}
inline void BuildingBlockRef::set_depth(::google::protobuf::uint32 value) {
  set_has_depth();
  depth_ = value;
}

// optional uint32 col = 2;
inline bool BuildingBlockRef::has_col() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildingBlockRef::set_has_col() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildingBlockRef::clear_has_col() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildingBlockRef::clear_col() {
  col_ = 0u;
  clear_has_col();
}
inline ::google::protobuf::uint32 BuildingBlockRef::col() const {
  return col_;
}
inline void BuildingBlockRef::set_col(::google::protobuf::uint32 value) {
  set_has_col();
  col_ = value;
}

// optional uint32 row = 3;
inline bool BuildingBlockRef::has_row() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuildingBlockRef::set_has_row() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuildingBlockRef::clear_has_row() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuildingBlockRef::clear_row() {
  row_ = 0u;
  clear_has_row();
}
inline ::google::protobuf::uint32 BuildingBlockRef::row() const {
  return row_;
}
inline void BuildingBlockRef::set_row(::google::protobuf::uint32 value) {
  set_has_row();
  row_ = value;
}

// -------------------------------------------------------------------

// BuildingBlockList

// optional int32 version = 1;
inline bool BuildingBlockList::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildingBlockList::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildingBlockList::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildingBlockList::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 BuildingBlockList::version() const {
  return version_;
}
inline void BuildingBlockList::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// repeated .com.telenav.proto.map.BuildingBlockRef blockRefs = 2;
inline int BuildingBlockList::blockrefs_size() const {
  return blockrefs_.size();
}
inline void BuildingBlockList::clear_blockrefs() {
  blockrefs_.Clear();
}
inline const ::com::telenav::proto::map::BuildingBlockRef& BuildingBlockList::blockrefs(int index) const {
  return blockrefs_.Get(index);
}
inline ::com::telenav::proto::map::BuildingBlockRef* BuildingBlockList::mutable_blockrefs(int index) {
  return blockrefs_.Mutable(index);
}
inline ::com::telenav::proto::map::BuildingBlockRef* BuildingBlockList::add_blockrefs() {
  return blockrefs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BuildingBlockRef >&
BuildingBlockList::blockrefs() const {
  return blockrefs_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BuildingBlockRef >*
BuildingBlockList::mutable_blockrefs() {
  return &blockrefs_;
}

// -------------------------------------------------------------------

// BigTileConfig

// repeated .com.telenav.proto.map.ZoomLevel zoomlevel = 1;
inline int BigTileConfig::zoomlevel_size() const {
  return zoomlevel_.size();
}
inline void BigTileConfig::clear_zoomlevel() {
  zoomlevel_.Clear();
}
inline const ::com::telenav::proto::map::ZoomLevel& BigTileConfig::zoomlevel(int index) const {
  return zoomlevel_.Get(index);
}
inline ::com::telenav::proto::map::ZoomLevel* BigTileConfig::mutable_zoomlevel(int index) {
  return zoomlevel_.Mutable(index);
}
inline ::com::telenav::proto::map::ZoomLevel* BigTileConfig::add_zoomlevel() {
  return zoomlevel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::ZoomLevel >&
BigTileConfig::zoomlevel() const {
  return zoomlevel_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::ZoomLevel >*
BigTileConfig::mutable_zoomlevel() {
  return &zoomlevel_;
}

// -------------------------------------------------------------------

// ZoomLevel

// optional int32 level = 1;
inline bool ZoomLevel::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZoomLevel::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZoomLevel::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZoomLevel::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ZoomLevel::level() const {
  return level_;
}
inline void ZoomLevel::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 power = 2;
inline bool ZoomLevel::has_power() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZoomLevel::set_has_power() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZoomLevel::clear_has_power() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZoomLevel::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 ZoomLevel::power() const {
  return power_;
}
inline void ZoomLevel::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace map
}  // namespace proto
}  // namespace telenav
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::telenav::proto::map::RoadSubType>() {
  return ::com::telenav::proto::map::RoadSubType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::telenav::proto::map::RoadDirection>() {
  return ::com::telenav::proto::map::RoadDirection_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::telenav::proto::map::RoadFunctionClass>() {
  return ::com::telenav::proto::map::RoadFunctionClass_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::telenav::proto::map::AreaType>() {
  return ::com::telenav::proto::map::AreaType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::telenav::proto::map::RingOrientation>() {
  return ::com::telenav::proto::map::RingOrientation_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::telenav::proto::map::PointType>() {
  return ::com::telenav::proto::map::PointType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::telenav::proto::map::LineType>() {
  return ::com::telenav::proto::map::LineType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::telenav::proto::map::FontStyle>() {
  return ::com::telenav::proto::map::FontStyle_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_map_2evector_2eproto__INCLUDED
