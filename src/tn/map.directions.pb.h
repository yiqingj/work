// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map.directions.proto

#ifndef PROTOBUF_map_2edirections_2eproto__INCLUDED
#define PROTOBUF_map_2edirections_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "services.pb.h"
#include "common.pb.h"
#include "map.common.pb.h"
// @@protoc_insertion_point(includes)

namespace com {
namespace telenav {
namespace proto {
namespace map {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_map_2edirections_2eproto();
void protobuf_AssignDesc_map_2edirections_2eproto();
void protobuf_ShutdownFile_map_2edirections_2eproto();

class RouteRequest;
class RouteOption;
class Location;
class OutputOption;
class GuidanceRequest;
class BasicRouteResponse;
class RouteResponse;
class FindMeRequest;
class FindMeResponse;
class SystemInfoResponse;
class GpsFix;
class Candidate;
class BasicRoute;
class BasicPath;
class Route;
class RouteInfo;
class Path;
class GuidanceSegment;
class RoadName;
class SignPost;
class SignBoard;
class Edge;
class TimeProfile;
class LaneInfo;
class JunctionView;

enum RouteStyle {
  FASTEST = 1,
  SHORTEST = 2,
  PEDESTRIAN = 3,
  ECO = 4
};
bool RouteStyle_IsValid(int value);
const RouteStyle RouteStyle_MIN = FASTEST;
const RouteStyle RouteStyle_MAX = ECO;
const int RouteStyle_ARRAYSIZE = RouteStyle_MAX + 1;

enum EcoMode {
  LOW_ECO_MODE = 1,
  MEDIUM_ECO_MODE = 2,
  HIGH_ECO_MODE = 3
};
bool EcoMode_IsValid(int value);
const EcoMode EcoMode_MIN = LOW_ECO_MODE;
const EcoMode EcoMode_MAX = HIGH_ECO_MODE;
const int EcoMode_ARRAYSIZE = EcoMode_MAX + 1;

enum SignBoardType {
  SIGN_AS_REAL = 1,
  GENERIC_MOTOWAY_SIGNBOARD = 2,
  GRAPHIC_SIGNBOARD = 3
};
bool SignBoardType_IsValid(int value);
const SignBoardType SignBoardType_MIN = SIGN_AS_REAL;
const SignBoardType SignBoardType_MAX = GRAPHIC_SIGNBOARD;
const int SignBoardType_ARRAYSIZE = SignBoardType_MAX + 1;

enum LanePattern {
  NONE = 1,
  CONTINUE = 2,
  CONTINUE_AND_LEFT = 3,
  CONTINUE_AND_RIGHT = 4,
  LEFT = 5,
  RIGHT = 6,
  LEFT_UTURN = 7,
  RIGHT_UTURN = 8,
  LEFT_AND_RIGHT = 9,
  LEFT_AND_LEFT_UTURN = 10,
  RIGHT_AND_RIGHT_UTURN = 11,
  CONTINUE_AND_LEFT_AND_RIGHT = 12
};
bool LanePattern_IsValid(int value);
const LanePattern LanePattern_MIN = NONE;
const LanePattern LanePattern_MAX = CONTINUE_AND_LEFT_AND_RIGHT;
const int LanePattern_ARRAYSIZE = LanePattern_MAX + 1;

enum JunctionViewType {
  ENHANCED_JUNCTION_VIEW = 1,
  GENERIC_JUNCTION_VIEW = 2,
  BASIC_JUNCTION_VIEW = 3,
  HCG_JUNCTION_VIEW = 4,
  HEG_JUNCTION_VIEW = 5,
  UCG_JUNCTION_VIEW = 6
};
bool JunctionViewType_IsValid(int value);
const JunctionViewType JunctionViewType_MIN = ENHANCED_JUNCTION_VIEW;
const JunctionViewType JunctionViewType_MAX = UCG_JUNCTION_VIEW;
const int JunctionViewType_ARRAYSIZE = JunctionViewType_MAX + 1;

enum HighlightedLane {
  HIGHLIGHT_NONE = 1,
  HIGHLIGHT_CONTINUE = 2,
  HIGHLIGHT_LEFT = 3,
  HIGHLIGHT_RIGHT = 4,
  HIGHLIGHT_LEFT_UTURN = 5,
  HIGHLIGHT_RIGHT_UTURN = 6
};
bool HighlightedLane_IsValid(int value);
const HighlightedLane HighlightedLane_MIN = HIGHLIGHT_NONE;
const HighlightedLane HighlightedLane_MAX = HIGHLIGHT_RIGHT_UTURN;
const int HighlightedLane_ARRAYSIZE = HighlightedLane_MAX + 1;

enum Warning {
  HAS_HIGHWAY = 1,
  HAS_TOLL = 2,
  HAS_FERRY = 3,
  HAS_HOV = 4,
  HAS_TUNNEL = 5,
  HAS_AVOID_SEGMENT = 6,
  HAS_TIME_RESTRICTION = 7
};
bool Warning_IsValid(int value);
const Warning Warning_MIN = HAS_HIGHWAY;
const Warning Warning_MAX = HAS_TIME_RESTRICTION;
const int Warning_ARRAYSIZE = Warning_MAX + 1;

enum TurnType {
  L2L_CONTINUE = 0,
  L2L_TURN_SLIGHT_RIGHT = 1,
  L2L_TURN_RIGHT = 2,
  L2L_TURN_HARD_RIGHT = 3,
  L2L_U_TURN = 4,
  L2L_TURN_HARD_LEFT = 5,
  L2L_TURN_LEFT = 6,
  L2L_TURN_SLIGHT_LEFT = 7,
  R2H_ENTER_LEFT = 10,
  R2H_ENTER_RIGHT = 11,
  H2R_EXIT_LEFT = 12,
  H2R_EXIT_RIGHT = 13,
  H2R_EXIT_MIDDLE = 60,
  H2H_MERGE_LEFT = 14,
  H2H_MERGE_RIGHT = 15,
  H2H_MERGE_AHEAD = 16,
  DESTINATION_LEFT = 17,
  DESTINATION_RIGHT = 18,
  DESTINATION_AHEAD = 19,
  ROUNDABOUT_ENTER = 20,
  ROUNDABOUT_EXIT = 21,
  STAY_LEFT = 26,
  STAY_RIGHT = 27,
  STAY_MIDDLE = 61,
  MULIT_FORK_STAY_LEFT = 76,
  MULIT_FORK_STAY_RIGHT = 77,
  F2Z_ENTER_LEFT = 62,
  F2Z_ENTER_RIGHT = 113,
  Z2F_EXIT_RIGHT = 114,
  Z2F_EXIT_LEFT = 63,
  H2H_EXIT_LEFT = 67,
  H2H_EXIT_RIGHT = 70,
  L2H_ENTER = 88,
  DESTINATION_INCOMPLETE_AHEAD = 80,
  DESTINATION_INCOMPLETE_SLIGHT_RIGHT = 81,
  DESTINATION_INCOMPLETE_RIGHT = 82,
  DESTINATION_INCOMPLETE_HARD_RIGHT = 83,
  DESTINATION_INCOMPLETE_BACK = 84,
  DESTINATION_INCOMPLETE_HARD_LEFT = 85,
  DESTINATION_INCOMPLETE_LEFT = 86,
  DESTINATION_INCOMPLETE_SLIGHT_LEFT = 87,
  VIA_POINT_LEFT = 97,
  VIA_POINT_RIGHT = 98,
  VIA_POINT_AHEAD = 99,
  ENTER_FERRY = 50,
  EXIT_FERRY = 51,
  LEFT_U_TURN = 120,
  RIGHT_U_TURN = 121
};
bool TurnType_IsValid(int value);
const TurnType TurnType_MIN = L2L_CONTINUE;
const TurnType TurnType_MAX = RIGHT_U_TURN;
const int TurnType_ARRAYSIZE = TurnType_MAX + 1;

// ===================================================================

class RouteRequest : public ::google::protobuf::MessageLite {
 public:
  RouteRequest();
  virtual ~RouteRequest();

  RouteRequest(const RouteRequest& from);

  inline RouteRequest& operator=(const RouteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const RouteRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RouteRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RouteRequest* other);

  // implements Message ----------------------------------------------

  RouteRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RouteRequest& from);
  void MergeFrom(const RouteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.map.Location origin = 1;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 1;
  inline const ::com::telenav::proto::map::Location& origin() const;
  inline ::com::telenav::proto::map::Location* mutable_origin();
  inline ::com::telenav::proto::map::Location* release_origin();
  inline void set_allocated_origin(::com::telenav::proto::map::Location* origin);

  // optional .com.telenav.proto.map.Location destination = 2;
  inline bool has_destination() const;
  inline void clear_destination();
  static const int kDestinationFieldNumber = 2;
  inline const ::com::telenav::proto::map::Location& destination() const;
  inline ::com::telenav::proto::map::Location* mutable_destination();
  inline ::com::telenav::proto::map::Location* release_destination();
  inline void set_allocated_destination(::com::telenav::proto::map::Location* destination);

  // optional .com.telenav.proto.map.RouteStyle style = 7 [default = FASTEST];
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 7;
  inline ::com::telenav::proto::map::RouteStyle style() const;
  inline void set_style(::com::telenav::proto::map::RouteStyle value);

  // optional .com.telenav.proto.map.RouteOption option = 8;
  inline bool has_option() const;
  inline void clear_option();
  static const int kOptionFieldNumber = 8;
  inline const ::com::telenav::proto::map::RouteOption& option() const;
  inline ::com::telenav::proto::map::RouteOption* mutable_option();
  inline ::com::telenav::proto::map::RouteOption* release_option();
  inline void set_allocated_option(::com::telenav::proto::map::RouteOption* option);

  // optional int32 max_route_number = 9 [default = 1];
  inline bool has_max_route_number() const;
  inline void clear_max_route_number();
  static const int kMaxRouteNumberFieldNumber = 9;
  inline ::google::protobuf::int32 max_route_number() const;
  inline void set_max_route_number(::google::protobuf::int32 value);

  // optional int32 heading = 10 [default = -1];
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 10;
  inline ::google::protobuf::int32 heading() const;
  inline void set_heading(::google::protobuf::int32 value);

  // optional int32 speed_in_mps = 11;
  inline bool has_speed_in_mps() const;
  inline void clear_speed_in_mps();
  static const int kSpeedInMpsFieldNumber = 11;
  inline ::google::protobuf::int32 speed_in_mps() const;
  inline void set_speed_in_mps(::google::protobuf::int32 value);

  // repeated .com.telenav.proto.LatLon dest_candidate = 12;
  inline int dest_candidate_size() const;
  inline void clear_dest_candidate();
  static const int kDestCandidateFieldNumber = 12;
  inline const ::com::telenav::proto::LatLon& dest_candidate(int index) const;
  inline ::com::telenav::proto::LatLon* mutable_dest_candidate(int index);
  inline ::com::telenav::proto::LatLon* add_dest_candidate();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::LatLon >&
      dest_candidate() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::LatLon >*
      mutable_dest_candidate();

  // optional .com.telenav.proto.map.OutputOption output_option = 13;
  inline bool has_output_option() const;
  inline void clear_output_option();
  static const int kOutputOptionFieldNumber = 13;
  inline const ::com::telenav::proto::map::OutputOption& output_option() const;
  inline ::com::telenav::proto::map::OutputOption* mutable_output_option();
  inline ::com::telenav::proto::map::OutputOption* release_output_option();
  inline void set_allocated_output_option(::com::telenav::proto::map::OutputOption* output_option);

  // optional int32 deviation_count = 18;
  inline bool has_deviation_count() const;
  inline void clear_deviation_count();
  static const int kDeviationCountFieldNumber = 18;
  inline ::google::protobuf::int32 deviation_count() const;
  inline void set_deviation_count(::google::protobuf::int32 value);

  // optional string data_set = 19;
  inline bool has_data_set() const;
  inline void clear_data_set();
  static const int kDataSetFieldNumber = 19;
  inline const ::std::string& data_set() const;
  inline void set_data_set(const ::std::string& value);
  inline void set_data_set(const char* value);
  inline void set_data_set(const char* value, size_t size);
  inline ::std::string* mutable_data_set();
  inline ::std::string* release_data_set();
  inline void set_allocated_data_set(::std::string* data_set);

  // optional .com.telenav.proto.Context context = 16;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 16;
  inline const ::com::telenav::proto::Context& context() const;
  inline ::com::telenav::proto::Context* mutable_context();
  inline ::com::telenav::proto::Context* release_context();
  inline void set_allocated_context(::com::telenav::proto::Context* context);

  // optional int64 route_start_time = 20;
  inline bool has_route_start_time() const;
  inline void clear_route_start_time();
  static const int kRouteStartTimeFieldNumber = 20;
  inline ::google::protobuf::int64 route_start_time() const;
  inline void set_route_start_time(::google::protobuf::int64 value);

  // optional bool use_time_restriction_for_road = 21;
  inline bool has_use_time_restriction_for_road() const;
  inline void clear_use_time_restriction_for_road();
  static const int kUseTimeRestrictionForRoadFieldNumber = 21;
  inline bool use_time_restriction_for_road() const;
  inline void set_use_time_restriction_for_road(bool value);

  // optional .com.telenav.proto.map.EcoMode eco_mode = 22 [default = HIGH_ECO_MODE];
  inline bool has_eco_mode() const;
  inline void clear_eco_mode();
  static const int kEcoModeFieldNumber = 22;
  inline ::com::telenav::proto::map::EcoMode eco_mode() const;
  inline void set_eco_mode(::com::telenav::proto::map::EcoMode value);

  // repeated .com.telenav.proto.map.Location waypoint = 23;
  inline int waypoint_size() const;
  inline void clear_waypoint();
  static const int kWaypointFieldNumber = 23;
  inline const ::com::telenav::proto::map::Location& waypoint(int index) const;
  inline ::com::telenav::proto::map::Location* mutable_waypoint(int index);
  inline ::com::telenav::proto::map::Location* add_waypoint();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Location >&
      waypoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Location >*
      mutable_waypoint();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.RouteRequest)
 private:
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_destination();
  inline void clear_has_destination();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_option();
  inline void clear_has_option();
  inline void set_has_max_route_number();
  inline void clear_has_max_route_number();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_speed_in_mps();
  inline void clear_has_speed_in_mps();
  inline void set_has_output_option();
  inline void clear_has_output_option();
  inline void set_has_deviation_count();
  inline void clear_has_deviation_count();
  inline void set_has_data_set();
  inline void clear_has_data_set();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_route_start_time();
  inline void clear_has_route_start_time();
  inline void set_has_use_time_restriction_for_road();
  inline void clear_has_use_time_restriction_for_road();
  inline void set_has_eco_mode();
  inline void clear_has_eco_mode();

  ::com::telenav::proto::map::Location* origin_;
  ::com::telenav::proto::map::Location* destination_;
  ::com::telenav::proto::map::RouteOption* option_;
  int style_;
  ::google::protobuf::int32 max_route_number_;
  ::google::protobuf::int32 heading_;
  ::google::protobuf::int32 speed_in_mps_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::LatLon > dest_candidate_;
  ::com::telenav::proto::map::OutputOption* output_option_;
  ::std::string* data_set_;
  ::com::telenav::proto::Context* context_;
  ::google::protobuf::int32 deviation_count_;
  bool use_time_restriction_for_road_;
  ::google::protobuf::int64 route_start_time_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Location > waypoint_;
  int eco_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static RouteRequest* default_instance_;
};
// -------------------------------------------------------------------

class RouteOption : public ::google::protobuf::MessageLite {
 public:
  RouteOption();
  virtual ~RouteOption();

  RouteOption(const RouteOption& from);

  inline RouteOption& operator=(const RouteOption& from) {
    CopyFrom(from);
    return *this;
  }

  static const RouteOption& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RouteOption* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RouteOption* other);

  // implements Message ----------------------------------------------

  RouteOption* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RouteOption& from);
  void MergeFrom(const RouteOption& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool avoid_hov_lane = 1;
  inline bool has_avoid_hov_lane() const;
  inline void clear_avoid_hov_lane();
  static const int kAvoidHovLaneFieldNumber = 1;
  inline bool avoid_hov_lane() const;
  inline void set_avoid_hov_lane(bool value);

  // optional bool avoid_highway = 2;
  inline bool has_avoid_highway() const;
  inline void clear_avoid_highway();
  static const int kAvoidHighwayFieldNumber = 2;
  inline bool avoid_highway() const;
  inline void set_avoid_highway(bool value);

  // optional bool avoid_toll_road = 3;
  inline bool has_avoid_toll_road() const;
  inline void clear_avoid_toll_road();
  static const int kAvoidTollRoadFieldNumber = 3;
  inline bool avoid_toll_road() const;
  inline void set_avoid_toll_road(bool value);

  // optional bool avoid_ferry = 4;
  inline bool has_avoid_ferry() const;
  inline void clear_avoid_ferry();
  static const int kAvoidFerryFieldNumber = 4;
  inline bool avoid_ferry() const;
  inline void set_avoid_ferry(bool value);

  // optional bool avoid_car_train = 5;
  inline bool has_avoid_car_train() const;
  inline void clear_avoid_car_train();
  static const int kAvoidCarTrainFieldNumber = 5;
  inline bool avoid_car_train() const;
  inline void set_avoid_car_train(bool value);

  // optional bool avoid_unpaved_road = 6;
  inline bool has_avoid_unpaved_road() const;
  inline void clear_avoid_unpaved_road();
  static const int kAvoidUnpavedRoadFieldNumber = 6;
  inline bool avoid_unpaved_road() const;
  inline void set_avoid_unpaved_road(bool value);

  // optional bool avoid_tunnel = 7;
  inline bool has_avoid_tunnel() const;
  inline void clear_avoid_tunnel();
  static const int kAvoidTunnelFieldNumber = 7;
  inline bool avoid_tunnel() const;
  inline void set_avoid_tunnel(bool value);

  // optional bool avoid_uturn = 8;
  inline bool has_avoid_uturn() const;
  inline void clear_avoid_uturn();
  static const int kAvoidUturnFieldNumber = 8;
  inline bool avoid_uturn() const;
  inline void set_avoid_uturn(bool value);

  // optional bool avoid_traffic = 9;
  inline bool has_avoid_traffic() const;
  inline void clear_avoid_traffic();
  static const int kAvoidTrafficFieldNumber = 9;
  inline bool avoid_traffic() const;
  inline void set_avoid_traffic(bool value);

  // repeated int64 must_avoid_edge_id = 10;
  inline int must_avoid_edge_id_size() const;
  inline void clear_must_avoid_edge_id();
  static const int kMustAvoidEdgeIdFieldNumber = 10;
  inline ::google::protobuf::int64 must_avoid_edge_id(int index) const;
  inline void set_must_avoid_edge_id(int index, ::google::protobuf::int64 value);
  inline void add_must_avoid_edge_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      must_avoid_edge_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_must_avoid_edge_id();

  // repeated int64 try_avoid_edge_Id = 11;
  inline int try_avoid_edge_id_size() const;
  inline void clear_try_avoid_edge_id();
  static const int kTryAvoidEdgeIdFieldNumber = 11;
  inline ::google::protobuf::int64 try_avoid_edge_id(int index) const;
  inline void set_try_avoid_edge_id(int index, ::google::protobuf::int64 value);
  inline void add_try_avoid_edge_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      try_avoid_edge_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_try_avoid_edge_id();

  // repeated int64 preferred_edge_Id = 12;
  inline int preferred_edge_id_size() const;
  inline void clear_preferred_edge_id();
  static const int kPreferredEdgeIdFieldNumber = 12;
  inline ::google::protobuf::int64 preferred_edge_id(int index) const;
  inline void set_preferred_edge_id(int index, ::google::protobuf::int64 value);
  inline void add_preferred_edge_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      preferred_edge_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_preferred_edge_id();

  // repeated string avoid_traffic_id = 13;
  inline int avoid_traffic_id_size() const;
  inline void clear_avoid_traffic_id();
  static const int kAvoidTrafficIdFieldNumber = 13;
  inline const ::std::string& avoid_traffic_id(int index) const;
  inline ::std::string* mutable_avoid_traffic_id(int index);
  inline void set_avoid_traffic_id(int index, const ::std::string& value);
  inline void set_avoid_traffic_id(int index, const char* value);
  inline void set_avoid_traffic_id(int index, const char* value, size_t size);
  inline ::std::string* add_avoid_traffic_id();
  inline void add_avoid_traffic_id(const ::std::string& value);
  inline void add_avoid_traffic_id(const char* value);
  inline void add_avoid_traffic_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& avoid_traffic_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_avoid_traffic_id();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.RouteOption)
 private:
  inline void set_has_avoid_hov_lane();
  inline void clear_has_avoid_hov_lane();
  inline void set_has_avoid_highway();
  inline void clear_has_avoid_highway();
  inline void set_has_avoid_toll_road();
  inline void clear_has_avoid_toll_road();
  inline void set_has_avoid_ferry();
  inline void clear_has_avoid_ferry();
  inline void set_has_avoid_car_train();
  inline void clear_has_avoid_car_train();
  inline void set_has_avoid_unpaved_road();
  inline void clear_has_avoid_unpaved_road();
  inline void set_has_avoid_tunnel();
  inline void clear_has_avoid_tunnel();
  inline void set_has_avoid_uturn();
  inline void clear_has_avoid_uturn();
  inline void set_has_avoid_traffic();
  inline void clear_has_avoid_traffic();

  bool avoid_hov_lane_;
  bool avoid_highway_;
  bool avoid_toll_road_;
  bool avoid_ferry_;
  bool avoid_car_train_;
  bool avoid_unpaved_road_;
  bool avoid_tunnel_;
  bool avoid_uturn_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > must_avoid_edge_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > try_avoid_edge_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > preferred_edge_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> avoid_traffic_id_;
  bool avoid_traffic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static RouteOption* default_instance_;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::MessageLite {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }

  static const Location& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Location* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Location* other);

  // implements Message ----------------------------------------------

  Location* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.LatLon lat_lon = 1;
  inline bool has_lat_lon() const;
  inline void clear_lat_lon();
  static const int kLatLonFieldNumber = 1;
  inline const ::com::telenav::proto::LatLon& lat_lon() const;
  inline ::com::telenav::proto::LatLon* mutable_lat_lon();
  inline ::com::telenav::proto::LatLon* release_lat_lon();
  inline void set_allocated_lat_lon(::com::telenav::proto::LatLon* lat_lon);

  // optional .com.telenav.proto.Address address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::com::telenav::proto::Address& address() const;
  inline ::com::telenav::proto::Address* mutable_address();
  inline ::com::telenav::proto::Address* release_address();
  inline void set_allocated_address(::com::telenav::proto::Address* address);

  // repeated int64 edge_id = 3;
  inline int edge_id_size() const;
  inline void clear_edge_id();
  static const int kEdgeIdFieldNumber = 3;
  inline ::google::protobuf::int64 edge_id(int index) const;
  inline void set_edge_id(int index, ::google::protobuf::int64 value);
  inline void add_edge_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      edge_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_edge_id();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.Location)
 private:
  inline void set_has_lat_lon();
  inline void clear_has_lat_lon();
  inline void set_has_address();
  inline void clear_has_address();

  ::com::telenav::proto::LatLon* lat_lon_;
  ::com::telenav::proto::Address* address_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > edge_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static Location* default_instance_;
};
// -------------------------------------------------------------------

class OutputOption : public ::google::protobuf::MessageLite {
 public:
  OutputOption();
  virtual ~OutputOption();

  OutputOption(const OutputOption& from);

  inline OutputOption& operator=(const OutputOption& from) {
    CopyFrom(from);
    return *this;
  }

  static const OutputOption& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OutputOption* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OutputOption* other);

  // implements Message ----------------------------------------------

  OutputOption* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OutputOption& from);
  void MergeFrom(const OutputOption& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool eta_only = 1 [default = false];
  inline bool has_eta_only() const;
  inline void clear_eta_only();
  static const int kEtaOnlyFieldNumber = 1;
  inline bool eta_only() const;
  inline void set_eta_only(bool value);

  // optional bool edge_detail = 2 [default = false];
  inline bool has_edge_detail() const;
  inline void clear_edge_detail();
  static const int kEdgeDetailFieldNumber = 2;
  inline bool edge_detail() const;
  inline void set_edge_detail(bool value);

  // optional bool basic_route = 3 [default = false];
  inline bool has_basic_route() const;
  inline void clear_basic_route();
  static const int kBasicRouteFieldNumber = 3;
  inline bool basic_route() const;
  inline void set_basic_route(bool value);

  // optional bool traffic_id = 4 [default = true];
  inline bool has_traffic_id() const;
  inline void clear_traffic_id();
  static const int kTrafficIdFieldNumber = 4;
  inline bool traffic_id() const;
  inline void set_traffic_id(bool value);

  // optional bool lane_info = 5 [default = true];
  inline bool has_lane_info() const;
  inline void clear_lane_info();
  static const int kLaneInfoFieldNumber = 5;
  inline bool lane_info() const;
  inline void set_lane_info(bool value);

  // optional bool speed_limit = 6 [default = true];
  inline bool has_speed_limit() const;
  inline void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 6;
  inline bool speed_limit() const;
  inline void set_speed_limit(bool value);

  // optional bool overview = 9 [default = false];
  inline bool has_overview() const;
  inline void clear_overview();
  static const int kOverviewFieldNumber = 9;
  inline bool overview() const;
  inline void set_overview(bool value);

  // optional bool route_info = 10 [default = true];
  inline bool has_route_info() const;
  inline void clear_route_info();
  static const int kRouteInfoFieldNumber = 10;
  inline bool route_info() const;
  inline void set_route_info(bool value);

  // optional int32 overview_decimated_level = 11;
  inline bool has_overview_decimated_level() const;
  inline void clear_overview_decimated_level();
  static const int kOverviewDecimatedLevelFieldNumber = 11;
  inline ::google::protobuf::int32 overview_decimated_level() const;
  inline void set_overview_decimated_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.OutputOption)
 private:
  inline void set_has_eta_only();
  inline void clear_has_eta_only();
  inline void set_has_edge_detail();
  inline void clear_has_edge_detail();
  inline void set_has_basic_route();
  inline void clear_has_basic_route();
  inline void set_has_traffic_id();
  inline void clear_has_traffic_id();
  inline void set_has_lane_info();
  inline void clear_has_lane_info();
  inline void set_has_speed_limit();
  inline void clear_has_speed_limit();
  inline void set_has_overview();
  inline void clear_has_overview();
  inline void set_has_route_info();
  inline void clear_has_route_info();
  inline void set_has_overview_decimated_level();
  inline void clear_has_overview_decimated_level();

  bool eta_only_;
  bool edge_detail_;
  bool basic_route_;
  bool traffic_id_;
  bool lane_info_;
  bool speed_limit_;
  bool overview_;
  bool route_info_;
  ::google::protobuf::int32 overview_decimated_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static OutputOption* default_instance_;
};
// -------------------------------------------------------------------

class GuidanceRequest : public ::google::protobuf::MessageLite {
 public:
  GuidanceRequest();
  virtual ~GuidanceRequest();

  GuidanceRequest(const GuidanceRequest& from);

  inline GuidanceRequest& operator=(const GuidanceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const GuidanceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GuidanceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GuidanceRequest* other);

  // implements Message ----------------------------------------------

  GuidanceRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GuidanceRequest& from);
  void MergeFrom(const GuidanceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.telenav.proto.map.BasicPath basic_path = 1;
  inline int basic_path_size() const;
  inline void clear_basic_path();
  static const int kBasicPathFieldNumber = 1;
  inline const ::com::telenav::proto::map::BasicPath& basic_path(int index) const;
  inline ::com::telenav::proto::map::BasicPath* mutable_basic_path(int index);
  inline ::com::telenav::proto::map::BasicPath* add_basic_path();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicPath >&
      basic_path() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicPath >*
      mutable_basic_path();

  // optional int32 start_index = 2;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 2;
  inline ::google::protobuf::int32 start_index() const;
  inline void set_start_index(::google::protobuf::int32 value);

  // optional int32 end_index = 3;
  inline bool has_end_index() const;
  inline void clear_end_index();
  static const int kEndIndexFieldNumber = 3;
  inline ::google::protobuf::int32 end_index() const;
  inline void set_end_index(::google::protobuf::int32 value);

  // optional int32 length_in_meter = 4;
  inline bool has_length_in_meter() const;
  inline void clear_length_in_meter();
  static const int kLengthInMeterFieldNumber = 4;
  inline ::google::protobuf::int32 length_in_meter() const;
  inline void set_length_in_meter(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.GuidanceRequest)
 private:
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_end_index();
  inline void clear_has_end_index();
  inline void set_has_length_in_meter();
  inline void clear_has_length_in_meter();

  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicPath > basic_path_;
  ::google::protobuf::int32 start_index_;
  ::google::protobuf::int32 end_index_;
  ::google::protobuf::int32 length_in_meter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static GuidanceRequest* default_instance_;
};
// -------------------------------------------------------------------

class BasicRouteResponse : public ::google::protobuf::MessageLite {
 public:
  BasicRouteResponse();
  virtual ~BasicRouteResponse();

  BasicRouteResponse(const BasicRouteResponse& from);

  inline BasicRouteResponse& operator=(const BasicRouteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const BasicRouteResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BasicRouteResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BasicRouteResponse* other);

  // implements Message ----------------------------------------------

  BasicRouteResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BasicRouteResponse& from);
  void MergeFrom(const BasicRouteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.ServiceStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::com::telenav::proto::ServiceStatus& status() const;
  inline ::com::telenav::proto::ServiceStatus* mutable_status();
  inline ::com::telenav::proto::ServiceStatus* release_status();
  inline void set_allocated_status(::com::telenav::proto::ServiceStatus* status);

  // optional string data_version = 3;
  inline bool has_data_version() const;
  inline void clear_data_version();
  static const int kDataVersionFieldNumber = 3;
  inline const ::std::string& data_version() const;
  inline void set_data_version(const ::std::string& value);
  inline void set_data_version(const char* value);
  inline void set_data_version(const char* value, size_t size);
  inline ::std::string* mutable_data_version();
  inline ::std::string* release_data_version();
  inline void set_allocated_data_version(::std::string* data_version);

  // repeated .com.telenav.proto.map.RouteInfo route_info = 4;
  inline int route_info_size() const;
  inline void clear_route_info();
  static const int kRouteInfoFieldNumber = 4;
  inline const ::com::telenav::proto::map::RouteInfo& route_info(int index) const;
  inline ::com::telenav::proto::map::RouteInfo* mutable_route_info(int index);
  inline ::com::telenav::proto::map::RouteInfo* add_route_info();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::RouteInfo >&
      route_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::RouteInfo >*
      mutable_route_info();

  // repeated .com.telenav.proto.map.BasicRoute route = 5;
  inline int route_size() const;
  inline void clear_route();
  static const int kRouteFieldNumber = 5;
  inline const ::com::telenav::proto::map::BasicRoute& route(int index) const;
  inline ::com::telenav::proto::map::BasicRoute* mutable_route(int index);
  inline ::com::telenav::proto::map::BasicRoute* add_route();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicRoute >&
      route() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicRoute >*
      mutable_route();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.BasicRouteResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_data_version();
  inline void clear_has_data_version();

  ::com::telenav::proto::ServiceStatus* status_;
  ::std::string* data_version_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::RouteInfo > route_info_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicRoute > route_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static BasicRouteResponse* default_instance_;
};
// -------------------------------------------------------------------

class RouteResponse : public ::google::protobuf::MessageLite {
 public:
  RouteResponse();
  virtual ~RouteResponse();

  RouteResponse(const RouteResponse& from);

  inline RouteResponse& operator=(const RouteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const RouteResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RouteResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RouteResponse* other);

  // implements Message ----------------------------------------------

  RouteResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RouteResponse& from);
  void MergeFrom(const RouteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.ServiceStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::com::telenav::proto::ServiceStatus& status() const;
  inline ::com::telenav::proto::ServiceStatus* mutable_status();
  inline ::com::telenav::proto::ServiceStatus* release_status();
  inline void set_allocated_status(::com::telenav::proto::ServiceStatus* status);

  // optional string data_version = 3;
  inline bool has_data_version() const;
  inline void clear_data_version();
  static const int kDataVersionFieldNumber = 3;
  inline const ::std::string& data_version() const;
  inline void set_data_version(const ::std::string& value);
  inline void set_data_version(const char* value);
  inline void set_data_version(const char* value, size_t size);
  inline ::std::string* mutable_data_version();
  inline ::std::string* release_data_version();
  inline void set_allocated_data_version(::std::string* data_version);

  // repeated .com.telenav.proto.map.Route route = 4;
  inline int route_size() const;
  inline void clear_route();
  static const int kRouteFieldNumber = 4;
  inline const ::com::telenav::proto::map::Route& route(int index) const;
  inline ::com::telenav::proto::map::Route* mutable_route(int index);
  inline ::com::telenav::proto::map::Route* add_route();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Route >&
      route() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Route >*
      mutable_route();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.RouteResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_data_version();
  inline void clear_has_data_version();

  ::com::telenav::proto::ServiceStatus* status_;
  ::std::string* data_version_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Route > route_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static RouteResponse* default_instance_;
};
// -------------------------------------------------------------------

class FindMeRequest : public ::google::protobuf::MessageLite {
 public:
  FindMeRequest();
  virtual ~FindMeRequest();

  FindMeRequest(const FindMeRequest& from);

  inline FindMeRequest& operator=(const FindMeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const FindMeRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FindMeRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FindMeRequest* other);

  // implements Message ----------------------------------------------

  FindMeRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FindMeRequest& from);
  void MergeFrom(const FindMeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.telenav.proto.map.GpsFix gps_fix = 1;
  inline int gps_fix_size() const;
  inline void clear_gps_fix();
  static const int kGpsFixFieldNumber = 1;
  inline const ::com::telenav::proto::map::GpsFix& gps_fix(int index) const;
  inline ::com::telenav::proto::map::GpsFix* mutable_gps_fix(int index);
  inline ::com::telenav::proto::map::GpsFix* add_gps_fix();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::GpsFix >&
      gps_fix() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::GpsFix >*
      mutable_gps_fix();

  // optional int32 latch_heading = 2 [default = -999];
  inline bool has_latch_heading() const;
  inline void clear_latch_heading();
  static const int kLatchHeadingFieldNumber = 2;
  inline ::google::protobuf::int32 latch_heading() const;
  inline void set_latch_heading(::google::protobuf::int32 value);

  // optional .com.telenav.proto.Context context = 3;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 3;
  inline const ::com::telenav::proto::Context& context() const;
  inline ::com::telenav::proto::Context* mutable_context();
  inline ::com::telenav::proto::Context* release_context();
  inline void set_allocated_context(::com::telenav::proto::Context* context);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.FindMeRequest)
 private:
  inline void set_has_latch_heading();
  inline void clear_has_latch_heading();
  inline void set_has_context();
  inline void clear_has_context();

  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::GpsFix > gps_fix_;
  ::com::telenav::proto::Context* context_;
  ::google::protobuf::int32 latch_heading_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static FindMeRequest* default_instance_;
};
// -------------------------------------------------------------------

class FindMeResponse : public ::google::protobuf::MessageLite {
 public:
  FindMeResponse();
  virtual ~FindMeResponse();

  FindMeResponse(const FindMeResponse& from);

  inline FindMeResponse& operator=(const FindMeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const FindMeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FindMeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FindMeResponse* other);

  // implements Message ----------------------------------------------

  FindMeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FindMeResponse& from);
  void MergeFrom(const FindMeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.ServiceStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::com::telenav::proto::ServiceStatus& status() const;
  inline ::com::telenav::proto::ServiceStatus* mutable_status();
  inline ::com::telenav::proto::ServiceStatus* release_status();
  inline void set_allocated_status(::com::telenav::proto::ServiceStatus* status);

  // optional string data_version = 3;
  inline bool has_data_version() const;
  inline void clear_data_version();
  static const int kDataVersionFieldNumber = 3;
  inline const ::std::string& data_version() const;
  inline void set_data_version(const ::std::string& value);
  inline void set_data_version(const char* value);
  inline void set_data_version(const char* value, size_t size);
  inline ::std::string* mutable_data_version();
  inline ::std::string* release_data_version();
  inline void set_allocated_data_version(::std::string* data_version);

  // repeated .com.telenav.proto.map.Candidate candidate = 4;
  inline int candidate_size() const;
  inline void clear_candidate();
  static const int kCandidateFieldNumber = 4;
  inline const ::com::telenav::proto::map::Candidate& candidate(int index) const;
  inline ::com::telenav::proto::map::Candidate* mutable_candidate(int index);
  inline ::com::telenav::proto::map::Candidate* add_candidate();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Candidate >&
      candidate() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Candidate >*
      mutable_candidate();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.FindMeResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_data_version();
  inline void clear_has_data_version();

  ::com::telenav::proto::ServiceStatus* status_;
  ::std::string* data_version_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Candidate > candidate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static FindMeResponse* default_instance_;
};
// -------------------------------------------------------------------

class SystemInfoResponse : public ::google::protobuf::MessageLite {
 public:
  SystemInfoResponse();
  virtual ~SystemInfoResponse();

  SystemInfoResponse(const SystemInfoResponse& from);

  inline SystemInfoResponse& operator=(const SystemInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const SystemInfoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SystemInfoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SystemInfoResponse* other);

  // implements Message ----------------------------------------------

  SystemInfoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SystemInfoResponse& from);
  void MergeFrom(const SystemInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.ServiceStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::com::telenav::proto::ServiceStatus& status() const;
  inline ::com::telenav::proto::ServiceStatus* mutable_status();
  inline ::com::telenav::proto::ServiceStatus* release_status();
  inline void set_allocated_status(::com::telenav::proto::ServiceStatus* status);

  // optional string app_version = 2;
  inline bool has_app_version() const;
  inline void clear_app_version();
  static const int kAppVersionFieldNumber = 2;
  inline const ::std::string& app_version() const;
  inline void set_app_version(const ::std::string& value);
  inline void set_app_version(const char* value);
  inline void set_app_version(const char* value, size_t size);
  inline ::std::string* mutable_app_version();
  inline ::std::string* release_app_version();
  inline void set_allocated_app_version(::std::string* app_version);

  // optional string data_version = 3;
  inline bool has_data_version() const;
  inline void clear_data_version();
  static const int kDataVersionFieldNumber = 3;
  inline const ::std::string& data_version() const;
  inline void set_data_version(const ::std::string& value);
  inline void set_data_version(const char* value);
  inline void set_data_version(const char* value, size_t size);
  inline ::std::string* mutable_data_version();
  inline ::std::string* release_data_version();
  inline void set_allocated_data_version(::std::string* data_version);

  // optional int64 up_time = 4;
  inline bool has_up_time() const;
  inline void clear_up_time();
  static const int kUpTimeFieldNumber = 4;
  inline ::google::protobuf::int64 up_time() const;
  inline void set_up_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.SystemInfoResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_app_version();
  inline void clear_has_app_version();
  inline void set_has_data_version();
  inline void clear_has_data_version();
  inline void set_has_up_time();
  inline void clear_has_up_time();

  ::com::telenav::proto::ServiceStatus* status_;
  ::std::string* app_version_;
  ::std::string* data_version_;
  ::google::protobuf::int64 up_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static SystemInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class GpsFix : public ::google::protobuf::MessageLite {
 public:
  GpsFix();
  virtual ~GpsFix();

  GpsFix(const GpsFix& from);

  inline GpsFix& operator=(const GpsFix& from) {
    CopyFrom(from);
    return *this;
  }

  static const GpsFix& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpsFix* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpsFix* other);

  // implements Message ----------------------------------------------

  GpsFix* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpsFix& from);
  void MergeFrom(const GpsFix& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline double lat() const;
  inline void set_lat(double value);

  // optional double lon = 2;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 2;
  inline double lon() const;
  inline void set_lon(double value);

  // optional double alt = 3;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 3;
  inline double alt() const;
  inline void set_alt(double value);

  // optional int64 time_stamp = 4;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 4;
  inline ::google::protobuf::int64 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::int64 value);

  // optional int32 speed = 5;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 5;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional int32 heading = 6;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 6;
  inline ::google::protobuf::int32 heading() const;
  inline void set_heading(::google::protobuf::int32 value);

  // optional int32 error = 7;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 7;
  inline ::google::protobuf::int32 error() const;
  inline void set_error(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.GpsFix)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_error();
  inline void clear_has_error();

  double lat_;
  double lon_;
  double alt_;
  ::google::protobuf::int64 time_stamp_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 heading_;
  ::google::protobuf::int32 error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static GpsFix* default_instance_;
};
// -------------------------------------------------------------------

class Candidate : public ::google::protobuf::MessageLite {
 public:
  Candidate();
  virtual ~Candidate();

  Candidate(const Candidate& from);

  inline Candidate& operator=(const Candidate& from) {
    CopyFrom(from);
    return *this;
  }

  static const Candidate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Candidate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Candidate* other);

  // implements Message ----------------------------------------------

  Candidate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Candidate& from);
  void MergeFrom(const Candidate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.LatLon lat_lon = 1;
  inline bool has_lat_lon() const;
  inline void clear_lat_lon();
  static const int kLatLonFieldNumber = 1;
  inline const ::com::telenav::proto::LatLon& lat_lon() const;
  inline ::com::telenav::proto::LatLon* mutable_lat_lon();
  inline ::com::telenav::proto::LatLon* release_lat_lon();
  inline void set_allocated_lat_lon(::com::telenav::proto::LatLon* lat_lon);

  // optional .com.telenav.proto.Address address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::com::telenav::proto::Address& address() const;
  inline ::com::telenav::proto::Address* mutable_address();
  inline ::com::telenav::proto::Address* release_address();
  inline void set_allocated_address(::com::telenav::proto::Address* address);

  // optional int32 heading = 3;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 3;
  inline ::google::protobuf::int32 heading() const;
  inline void set_heading(::google::protobuf::int32 value);

  // optional int32 speed_in_mps = 4;
  inline bool has_speed_in_mps() const;
  inline void clear_speed_in_mps();
  static const int kSpeedInMpsFieldNumber = 4;
  inline ::google::protobuf::int32 speed_in_mps() const;
  inline void set_speed_in_mps(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.Candidate)
 private:
  inline void set_has_lat_lon();
  inline void clear_has_lat_lon();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_speed_in_mps();
  inline void clear_has_speed_in_mps();

  ::com::telenav::proto::LatLon* lat_lon_;
  ::com::telenav::proto::Address* address_;
  ::google::protobuf::int32 heading_;
  ::google::protobuf::int32 speed_in_mps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static Candidate* default_instance_;
};
// -------------------------------------------------------------------

class BasicRoute : public ::google::protobuf::MessageLite {
 public:
  BasicRoute();
  virtual ~BasicRoute();

  BasicRoute(const BasicRoute& from);

  inline BasicRoute& operator=(const BasicRoute& from) {
    CopyFrom(from);
    return *this;
  }

  static const BasicRoute& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BasicRoute* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BasicRoute* other);

  // implements Message ----------------------------------------------

  BasicRoute* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BasicRoute& from);
  void MergeFrom(const BasicRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.telenav.proto.map.BasicPath head_path = 2;
  inline int head_path_size() const;
  inline void clear_head_path();
  static const int kHeadPathFieldNumber = 2;
  inline const ::com::telenav::proto::map::BasicPath& head_path(int index) const;
  inline ::com::telenav::proto::map::BasicPath* mutable_head_path(int index);
  inline ::com::telenav::proto::map::BasicPath* add_head_path();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicPath >&
      head_path() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicPath >*
      mutable_head_path();

  // optional .com.telenav.proto.map.BasicPath body_path = 3;
  inline bool has_body_path() const;
  inline void clear_body_path();
  static const int kBodyPathFieldNumber = 3;
  inline const ::com::telenav::proto::map::BasicPath& body_path() const;
  inline ::com::telenav::proto::map::BasicPath* mutable_body_path();
  inline ::com::telenav::proto::map::BasicPath* release_body_path();
  inline void set_allocated_body_path(::com::telenav::proto::map::BasicPath* body_path);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.BasicRoute)
 private:
  inline void set_has_body_path();
  inline void clear_has_body_path();

  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicPath > head_path_;
  ::com::telenav::proto::map::BasicPath* body_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static BasicRoute* default_instance_;
};
// -------------------------------------------------------------------

class BasicPath : public ::google::protobuf::MessageLite {
 public:
  BasicPath();
  virtual ~BasicPath();

  BasicPath(const BasicPath& from);

  inline BasicPath& operator=(const BasicPath& from) {
    CopyFrom(from);
    return *this;
  }

  static const BasicPath& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BasicPath* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BasicPath* other);

  // implements Message ----------------------------------------------

  BasicPath* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BasicPath& from);
  void MergeFrom(const BasicPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 edge_id = 2;
  inline int edge_id_size() const;
  inline void clear_edge_id();
  static const int kEdgeIdFieldNumber = 2;
  inline ::google::protobuf::int64 edge_id(int index) const;
  inline void set_edge_id(int index, ::google::protobuf::int64 value);
  inline void add_edge_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      edge_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_edge_id();

  // optional string first_edge_start_points = 4;
  inline bool has_first_edge_start_points() const;
  inline void clear_first_edge_start_points();
  static const int kFirstEdgeStartPointsFieldNumber = 4;
  inline const ::std::string& first_edge_start_points() const;
  inline void set_first_edge_start_points(const ::std::string& value);
  inline void set_first_edge_start_points(const char* value);
  inline void set_first_edge_start_points(const char* value, size_t size);
  inline ::std::string* mutable_first_edge_start_points();
  inline ::std::string* release_first_edge_start_points();
  inline void set_allocated_first_edge_start_points(::std::string* first_edge_start_points);

  // optional string last_edge_end_points = 5;
  inline bool has_last_edge_end_points() const;
  inline void clear_last_edge_end_points();
  static const int kLastEdgeEndPointsFieldNumber = 5;
  inline const ::std::string& last_edge_end_points() const;
  inline void set_last_edge_end_points(const ::std::string& value);
  inline void set_last_edge_end_points(const char* value);
  inline void set_last_edge_end_points(const char* value, size_t size);
  inline ::std::string* mutable_last_edge_end_points();
  inline ::std::string* release_last_edge_end_points();
  inline void set_allocated_last_edge_end_points(::std::string* last_edge_end_points);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.BasicPath)
 private:
  inline void set_has_first_edge_start_points();
  inline void clear_has_first_edge_start_points();
  inline void set_has_last_edge_end_points();
  inline void clear_has_last_edge_end_points();

  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > edge_id_;
  ::std::string* first_edge_start_points_;
  ::std::string* last_edge_end_points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static BasicPath* default_instance_;
};
// -------------------------------------------------------------------

class Route : public ::google::protobuf::MessageLite {
 public:
  Route();
  virtual ~Route();

  Route(const Route& from);

  inline Route& operator=(const Route& from) {
    CopyFrom(from);
    return *this;
  }

  static const Route& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Route* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Route* other);

  // implements Message ----------------------------------------------

  Route* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Route& from);
  void MergeFrom(const Route& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.map.RouteInfo route_info = 2;
  inline bool has_route_info() const;
  inline void clear_route_info();
  static const int kRouteInfoFieldNumber = 2;
  inline const ::com::telenav::proto::map::RouteInfo& route_info() const;
  inline ::com::telenav::proto::map::RouteInfo* mutable_route_info();
  inline ::com::telenav::proto::map::RouteInfo* release_route_info();
  inline void set_allocated_route_info(::com::telenav::proto::map::RouteInfo* route_info);

  // repeated .com.telenav.proto.map.Path path = 3;
  inline int path_size() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::com::telenav::proto::map::Path& path(int index) const;
  inline ::com::telenav::proto::map::Path* mutable_path(int index);
  inline ::com::telenav::proto::map::Path* add_path();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Path >&
      path() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Path >*
      mutable_path();

  // repeated .com.telenav.proto.map.GuidanceSegment segment = 4;
  inline int segment_size() const;
  inline void clear_segment();
  static const int kSegmentFieldNumber = 4;
  inline const ::com::telenav::proto::map::GuidanceSegment& segment(int index) const;
  inline ::com::telenav::proto::map::GuidanceSegment* mutable_segment(int index);
  inline ::com::telenav::proto::map::GuidanceSegment* add_segment();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::GuidanceSegment >&
      segment() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::GuidanceSegment >*
      mutable_segment();

  // optional bool partial = 5 [default = false];
  inline bool has_partial() const;
  inline void clear_partial();
  static const int kPartialFieldNumber = 5;
  inline bool partial() const;
  inline void set_partial(bool value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.Route)
 private:
  inline void set_has_route_info();
  inline void clear_has_route_info();
  inline void set_has_partial();
  inline void clear_has_partial();

  ::com::telenav::proto::map::RouteInfo* route_info_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Path > path_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::GuidanceSegment > segment_;
  bool partial_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static Route* default_instance_;
};
// -------------------------------------------------------------------

class RouteInfo : public ::google::protobuf::MessageLite {
 public:
  RouteInfo();
  virtual ~RouteInfo();

  RouteInfo(const RouteInfo& from);

  inline RouteInfo& operator=(const RouteInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const RouteInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RouteInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RouteInfo* other);

  // implements Message ----------------------------------------------

  RouteInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RouteInfo& from);
  void MergeFrom(const RouteInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string overview = 1;
  inline bool has_overview() const;
  inline void clear_overview();
  static const int kOverviewFieldNumber = 1;
  inline const ::std::string& overview() const;
  inline void set_overview(const ::std::string& value);
  inline void set_overview(const char* value);
  inline void set_overview(const char* value, size_t size);
  inline ::std::string* mutable_overview();
  inline ::std::string* release_overview();
  inline void set_allocated_overview(::std::string* overview);

  // optional string summary = 2;
  inline bool has_summary() const;
  inline void clear_summary();
  static const int kSummaryFieldNumber = 2;
  inline const ::std::string& summary() const;
  inline void set_summary(const ::std::string& value);
  inline void set_summary(const char* value);
  inline void set_summary(const char* value, size_t size);
  inline ::std::string* mutable_summary();
  inline ::std::string* release_summary();
  inline void set_allocated_summary(::std::string* summary);

  // optional int32 travel_time_in_second = 3;
  inline bool has_travel_time_in_second() const;
  inline void clear_travel_time_in_second();
  static const int kTravelTimeInSecondFieldNumber = 3;
  inline ::google::protobuf::int32 travel_time_in_second() const;
  inline void set_travel_time_in_second(::google::protobuf::int32 value);

  // optional int32 travel_dist_in_meter = 4;
  inline bool has_travel_dist_in_meter() const;
  inline void clear_travel_dist_in_meter();
  static const int kTravelDistInMeterFieldNumber = 4;
  inline ::google::protobuf::int32 travel_dist_in_meter() const;
  inline void set_travel_dist_in_meter(::google::protobuf::int32 value);

  // optional int32 traffic_delay_in_second = 5;
  inline bool has_traffic_delay_in_second() const;
  inline void clear_traffic_delay_in_second();
  static const int kTrafficDelayInSecondFieldNumber = 5;
  inline ::google::protobuf::int32 traffic_delay_in_second() const;
  inline void set_traffic_delay_in_second(::google::protobuf::int32 value);

  // optional bool estimate_only = 8;
  inline bool has_estimate_only() const;
  inline void clear_estimate_only();
  static const int kEstimateOnlyFieldNumber = 8;
  inline bool estimate_only() const;
  inline void set_estimate_only(bool value);

  // repeated .com.telenav.proto.map.Warning warning = 9;
  inline int warning_size() const;
  inline void clear_warning();
  static const int kWarningFieldNumber = 9;
  inline ::com::telenav::proto::map::Warning warning(int index) const;
  inline void set_warning(int index, ::com::telenav::proto::map::Warning value);
  inline void add_warning(::com::telenav::proto::map::Warning value);
  inline const ::google::protobuf::RepeatedField<int>& warning() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_warning();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.RouteInfo)
 private:
  inline void set_has_overview();
  inline void clear_has_overview();
  inline void set_has_summary();
  inline void clear_has_summary();
  inline void set_has_travel_time_in_second();
  inline void clear_has_travel_time_in_second();
  inline void set_has_travel_dist_in_meter();
  inline void clear_has_travel_dist_in_meter();
  inline void set_has_traffic_delay_in_second();
  inline void clear_has_traffic_delay_in_second();
  inline void set_has_estimate_only();
  inline void clear_has_estimate_only();

  ::std::string* overview_;
  ::std::string* summary_;
  ::google::protobuf::int32 travel_time_in_second_;
  ::google::protobuf::int32 travel_dist_in_meter_;
  ::google::protobuf::int32 traffic_delay_in_second_;
  bool estimate_only_;
  ::google::protobuf::RepeatedField<int> warning_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static RouteInfo* default_instance_;
};
// -------------------------------------------------------------------

class Path : public ::google::protobuf::MessageLite {
 public:
  Path();
  virtual ~Path();

  Path(const Path& from);

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }

  static const Path& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Path* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Path* other);

  // implements Message ----------------------------------------------

  Path* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 segment_index = 1;
  inline int segment_index_size() const;
  inline void clear_segment_index();
  static const int kSegmentIndexFieldNumber = 1;
  inline ::google::protobuf::int32 segment_index(int index) const;
  inline void set_segment_index(int index, ::google::protobuf::int32 value);
  inline void add_segment_index(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      segment_index() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_segment_index();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.Path)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > segment_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static Path* default_instance_;
};
// -------------------------------------------------------------------

class GuidanceSegment : public ::google::protobuf::MessageLite {
 public:
  GuidanceSegment();
  virtual ~GuidanceSegment();

  GuidanceSegment(const GuidanceSegment& from);

  inline GuidanceSegment& operator=(const GuidanceSegment& from) {
    CopyFrom(from);
    return *this;
  }

  static const GuidanceSegment& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GuidanceSegment* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GuidanceSegment* other);

  // implements Message ----------------------------------------------

  GuidanceSegment* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GuidanceSegment& from);
  void MergeFrom(const GuidanceSegment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.map.TurnType turn_type = 1;
  inline bool has_turn_type() const;
  inline void clear_turn_type();
  static const int kTurnTypeFieldNumber = 1;
  inline ::com::telenav::proto::map::TurnType turn_type() const;
  inline void set_turn_type(::com::telenav::proto::map::TurnType value);

  // optional bool is_tight_turn = 2 [default = false];
  inline bool has_is_tight_turn() const;
  inline void clear_is_tight_turn();
  static const int kIsTightTurnFieldNumber = 2;
  inline bool is_tight_turn() const;
  inline void set_is_tight_turn(bool value);

  // optional .com.telenav.proto.map.RoadName road_name = 3;
  inline bool has_road_name() const;
  inline void clear_road_name();
  static const int kRoadNameFieldNumber = 3;
  inline const ::com::telenav::proto::map::RoadName& road_name() const;
  inline ::com::telenav::proto::map::RoadName* mutable_road_name();
  inline ::com::telenav::proto::map::RoadName* release_road_name();
  inline void set_allocated_road_name(::com::telenav::proto::map::RoadName* road_name);

  // optional .com.telenav.proto.map.SignPost sign_post = 4;
  inline bool has_sign_post() const;
  inline void clear_sign_post();
  static const int kSignPostFieldNumber = 4;
  inline const ::com::telenav::proto::map::SignPost& sign_post() const;
  inline ::com::telenav::proto::map::SignPost* mutable_sign_post();
  inline ::com::telenav::proto::map::SignPost* release_sign_post();
  inline void set_allocated_sign_post(::com::telenav::proto::map::SignPost* sign_post);

  // optional .com.telenav.proto.map.SignBoard sign_board = 5;
  inline bool has_sign_board() const;
  inline void clear_sign_board();
  static const int kSignBoardFieldNumber = 5;
  inline const ::com::telenav::proto::map::SignBoard& sign_board() const;
  inline ::com::telenav::proto::map::SignBoard* mutable_sign_board();
  inline ::com::telenav::proto::map::SignBoard* release_sign_board();
  inline void set_allocated_sign_board(::com::telenav::proto::map::SignBoard* sign_board);

  // optional int32 nth_turn = 6;
  inline bool has_nth_turn() const;
  inline void clear_nth_turn();
  static const int kNthTurnFieldNumber = 6;
  inline ::google::protobuf::int32 nth_turn() const;
  inline void set_nth_turn(::google::protobuf::int32 value);

  // optional string language = 9;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 9;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional .com.telenav.proto.map.RoadType road_type = 10;
  inline bool has_road_type() const;
  inline void clear_road_type();
  static const int kRoadTypeFieldNumber = 10;
  inline ::com::telenav::proto::map::RoadType road_type() const;
  inline void set_road_type(::com::telenav::proto::map::RoadType value);

  // optional bool is_left_side_drive = 12;
  inline bool has_is_left_side_drive() const;
  inline void clear_is_left_side_drive();
  static const int kIsLeftSideDriveFieldNumber = 12;
  inline bool is_left_side_drive() const;
  inline void set_is_left_side_drive(bool value);

  // repeated .com.telenav.proto.map.LaneInfo lane_info = 13;
  inline int lane_info_size() const;
  inline void clear_lane_info();
  static const int kLaneInfoFieldNumber = 13;
  inline const ::com::telenav::proto::map::LaneInfo& lane_info(int index) const;
  inline ::com::telenav::proto::map::LaneInfo* mutable_lane_info(int index);
  inline ::com::telenav::proto::map::LaneInfo* add_lane_info();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::LaneInfo >&
      lane_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::LaneInfo >*
      mutable_lane_info();

  // optional double length_in_meter = 14;
  inline bool has_length_in_meter() const;
  inline void clear_length_in_meter();
  static const int kLengthInMeterFieldNumber = 14;
  inline double length_in_meter() const;
  inline void set_length_in_meter(double value);

  // repeated .com.telenav.proto.map.JunctionView junction_view = 15;
  inline int junction_view_size() const;
  inline void clear_junction_view();
  static const int kJunctionViewFieldNumber = 15;
  inline const ::com::telenav::proto::map::JunctionView& junction_view(int index) const;
  inline ::com::telenav::proto::map::JunctionView* mutable_junction_view(int index);
  inline ::com::telenav::proto::map::JunctionView* add_junction_view();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::JunctionView >&
      junction_view() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::JunctionView >*
      mutable_junction_view();

  // repeated .com.telenav.proto.map.Warning warning = 19;
  inline int warning_size() const;
  inline void clear_warning();
  static const int kWarningFieldNumber = 19;
  inline ::com::telenav::proto::map::Warning warning(int index) const;
  inline void set_warning(int index, ::com::telenav::proto::map::Warning value);
  inline void add_warning(::com::telenav::proto::map::Warning value);
  inline const ::google::protobuf::RepeatedField<int>& warning() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_warning();

  // repeated .com.telenav.proto.map.Edge edge = 18;
  inline int edge_size() const;
  inline void clear_edge();
  static const int kEdgeFieldNumber = 18;
  inline const ::com::telenav::proto::map::Edge& edge(int index) const;
  inline ::com::telenav::proto::map::Edge* mutable_edge(int index);
  inline ::com::telenav::proto::map::Edge* add_edge();
  inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Edge >&
      edge() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Edge >*
      mutable_edge();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.GuidanceSegment)
 private:
  inline void set_has_turn_type();
  inline void clear_has_turn_type();
  inline void set_has_is_tight_turn();
  inline void clear_has_is_tight_turn();
  inline void set_has_road_name();
  inline void clear_has_road_name();
  inline void set_has_sign_post();
  inline void clear_has_sign_post();
  inline void set_has_sign_board();
  inline void clear_has_sign_board();
  inline void set_has_nth_turn();
  inline void clear_has_nth_turn();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_road_type();
  inline void clear_has_road_type();
  inline void set_has_is_left_side_drive();
  inline void clear_has_is_left_side_drive();
  inline void set_has_length_in_meter();
  inline void clear_has_length_in_meter();

  ::com::telenav::proto::map::RoadName* road_name_;
  ::com::telenav::proto::map::SignPost* sign_post_;
  int turn_type_;
  bool is_tight_turn_;
  bool is_left_side_drive_;
  ::com::telenav::proto::map::SignBoard* sign_board_;
  ::google::protobuf::int32 nth_turn_;
  int road_type_;
  ::std::string* language_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::LaneInfo > lane_info_;
  double length_in_meter_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::JunctionView > junction_view_;
  ::google::protobuf::RepeatedField<int> warning_;
  ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Edge > edge_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static GuidanceSegment* default_instance_;
};
// -------------------------------------------------------------------

class RoadName : public ::google::protobuf::MessageLite {
 public:
  RoadName();
  virtual ~RoadName();

  RoadName(const RoadName& from);

  inline RoadName& operator=(const RoadName& from) {
    CopyFrom(from);
    return *this;
  }

  static const RoadName& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RoadName* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RoadName* other);

  // implements Message ----------------------------------------------

  RoadName* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RoadName& from);
  void MergeFrom(const RoadName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string official_name = 1;
  inline int official_name_size() const;
  inline void clear_official_name();
  static const int kOfficialNameFieldNumber = 1;
  inline const ::std::string& official_name(int index) const;
  inline ::std::string* mutable_official_name(int index);
  inline void set_official_name(int index, const ::std::string& value);
  inline void set_official_name(int index, const char* value);
  inline void set_official_name(int index, const char* value, size_t size);
  inline ::std::string* add_official_name();
  inline void add_official_name(const ::std::string& value);
  inline void add_official_name(const char* value);
  inline void add_official_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& official_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_official_name();

  // repeated string alternate_name = 2;
  inline int alternate_name_size() const;
  inline void clear_alternate_name();
  static const int kAlternateNameFieldNumber = 2;
  inline const ::std::string& alternate_name(int index) const;
  inline ::std::string* mutable_alternate_name(int index);
  inline void set_alternate_name(int index, const ::std::string& value);
  inline void set_alternate_name(int index, const char* value);
  inline void set_alternate_name(int index, const char* value, size_t size);
  inline ::std::string* add_alternate_name();
  inline void add_alternate_name(const ::std::string& value);
  inline void add_alternate_name(const char* value);
  inline void add_alternate_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& alternate_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_alternate_name();

  // repeated string route_number = 3;
  inline int route_number_size() const;
  inline void clear_route_number();
  static const int kRouteNumberFieldNumber = 3;
  inline const ::std::string& route_number(int index) const;
  inline ::std::string* mutable_route_number(int index);
  inline void set_route_number(int index, const ::std::string& value);
  inline void set_route_number(int index, const char* value);
  inline void set_route_number(int index, const char* value, size_t size);
  inline ::std::string* add_route_number();
  inline void add_route_number(const ::std::string& value);
  inline void add_route_number(const char* value);
  inline void add_route_number(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& route_number() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_route_number();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.RoadName)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> official_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> alternate_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> route_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static RoadName* default_instance_;
};
// -------------------------------------------------------------------

class SignPost : public ::google::protobuf::MessageLite {
 public:
  SignPost();
  virtual ~SignPost();

  SignPost(const SignPost& from);

  inline SignPost& operator=(const SignPost& from) {
    CopyFrom(from);
    return *this;
  }

  static const SignPost& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SignPost* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SignPost* other);

  // implements Message ----------------------------------------------

  SignPost* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SignPost& from);
  void MergeFrom(const SignPost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string road_name = 1;
  inline int road_name_size() const;
  inline void clear_road_name();
  static const int kRoadNameFieldNumber = 1;
  inline const ::std::string& road_name(int index) const;
  inline ::std::string* mutable_road_name(int index);
  inline void set_road_name(int index, const ::std::string& value);
  inline void set_road_name(int index, const char* value);
  inline void set_road_name(int index, const char* value, size_t size);
  inline ::std::string* add_road_name();
  inline void add_road_name(const ::std::string& value);
  inline void add_road_name(const char* value);
  inline void add_road_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& road_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_road_name();

  // optional string place_name = 2;
  inline bool has_place_name() const;
  inline void clear_place_name();
  static const int kPlaceNameFieldNumber = 2;
  inline const ::std::string& place_name() const;
  inline void set_place_name(const ::std::string& value);
  inline void set_place_name(const char* value);
  inline void set_place_name(const char* value, size_t size);
  inline ::std::string* mutable_place_name();
  inline ::std::string* release_place_name();
  inline void set_allocated_place_name(::std::string* place_name);

  // optional string exit_label = 3;
  inline bool has_exit_label() const;
  inline void clear_exit_label();
  static const int kExitLabelFieldNumber = 3;
  inline const ::std::string& exit_label() const;
  inline void set_exit_label(const ::std::string& value);
  inline void set_exit_label(const char* value);
  inline void set_exit_label(const char* value, size_t size);
  inline ::std::string* mutable_exit_label();
  inline ::std::string* release_exit_label();
  inline void set_allocated_exit_label(::std::string* exit_label);

  // optional string image_id = 4;
  inline bool has_image_id() const;
  inline void clear_image_id();
  static const int kImageIdFieldNumber = 4;
  inline const ::std::string& image_id() const;
  inline void set_image_id(const ::std::string& value);
  inline void set_image_id(const char* value);
  inline void set_image_id(const char* value, size_t size);
  inline ::std::string* mutable_image_id();
  inline ::std::string* release_image_id();
  inline void set_allocated_image_id(::std::string* image_id);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.SignPost)
 private:
  inline void set_has_place_name();
  inline void clear_has_place_name();
  inline void set_has_exit_label();
  inline void clear_has_exit_label();
  inline void set_has_image_id();
  inline void clear_has_image_id();

  ::google::protobuf::RepeatedPtrField< ::std::string> road_name_;
  ::std::string* place_name_;
  ::std::string* exit_label_;
  ::std::string* image_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static SignPost* default_instance_;
};
// -------------------------------------------------------------------

class SignBoard : public ::google::protobuf::MessageLite {
 public:
  SignBoard();
  virtual ~SignBoard();

  SignBoard(const SignBoard& from);

  inline SignBoard& operator=(const SignBoard& from) {
    CopyFrom(from);
    return *this;
  }

  static const SignBoard& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SignBoard* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SignBoard* other);

  // implements Message ----------------------------------------------

  SignBoard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SignBoard& from);
  void MergeFrom(const SignBoard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.map.SignBoardType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::com::telenav::proto::map::SignBoardType type() const;
  inline void set_type(::com::telenav::proto::map::SignBoardType value);

  // optional string pattern_id = 2;
  inline bool has_pattern_id() const;
  inline void clear_pattern_id();
  static const int kPatternIdFieldNumber = 2;
  inline const ::std::string& pattern_id() const;
  inline void set_pattern_id(const ::std::string& value);
  inline void set_pattern_id(const char* value);
  inline void set_pattern_id(const char* value, size_t size);
  inline ::std::string* mutable_pattern_id();
  inline ::std::string* release_pattern_id();
  inline void set_allocated_pattern_id(::std::string* pattern_id);

  // optional string arrow_id = 3;
  inline bool has_arrow_id() const;
  inline void clear_arrow_id();
  static const int kArrowIdFieldNumber = 3;
  inline const ::std::string& arrow_id() const;
  inline void set_arrow_id(const ::std::string& value);
  inline void set_arrow_id(const char* value);
  inline void set_arrow_id(const char* value, size_t size);
  inline ::std::string* mutable_arrow_id();
  inline ::std::string* release_arrow_id();
  inline void set_allocated_arrow_id(::std::string* arrow_id);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.SignBoard)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pattern_id();
  inline void clear_has_pattern_id();
  inline void set_has_arrow_id();
  inline void clear_has_arrow_id();

  ::std::string* pattern_id_;
  ::std::string* arrow_id_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static SignBoard* default_instance_;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::MessageLite {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }

  static const Edge& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Edge* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Edge* other);

  // implements Message ----------------------------------------------

  Edge* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double speed_limit_in_KPH = 2 [default = -1];
  inline bool has_speed_limit_in_kph() const;
  inline void clear_speed_limit_in_kph();
  static const int kSpeedLimitInKPHFieldNumber = 2;
  inline double speed_limit_in_kph() const;
  inline void set_speed_limit_in_kph(double value);

  // optional double travel_speed_in_mps = 3 [default = -1];
  inline bool has_travel_speed_in_mps() const;
  inline void clear_travel_speed_in_mps();
  static const int kTravelSpeedInMpsFieldNumber = 3;
  inline double travel_speed_in_mps() const;
  inline void set_travel_speed_in_mps(double value);

  // repeated int64 map_edge_id = 4;
  inline int map_edge_id_size() const;
  inline void clear_map_edge_id();
  static const int kMapEdgeIdFieldNumber = 4;
  inline ::google::protobuf::int64 map_edge_id(int index) const;
  inline void set_map_edge_id(int index, ::google::protobuf::int64 value);
  inline void add_map_edge_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      map_edge_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_map_edge_id();

  // optional int32 length_in_meter = 6;
  inline bool has_length_in_meter() const;
  inline void clear_length_in_meter();
  static const int kLengthInMeterFieldNumber = 6;
  inline ::google::protobuf::int32 length_in_meter() const;
  inline void set_length_in_meter(::google::protobuf::int32 value);

  // optional string encoded_polyline = 7;
  inline bool has_encoded_polyline() const;
  inline void clear_encoded_polyline();
  static const int kEncodedPolylineFieldNumber = 7;
  inline const ::std::string& encoded_polyline() const;
  inline void set_encoded_polyline(const ::std::string& value);
  inline void set_encoded_polyline(const char* value);
  inline void set_encoded_polyline(const char* value, size_t size);
  inline ::std::string* mutable_encoded_polyline();
  inline ::std::string* release_encoded_polyline();
  inline void set_allocated_encoded_polyline(::std::string* encoded_polyline);

  // optional string traffic_id = 8;
  inline bool has_traffic_id() const;
  inline void clear_traffic_id();
  static const int kTrafficIdFieldNumber = 8;
  inline const ::std::string& traffic_id() const;
  inline void set_traffic_id(const ::std::string& value);
  inline void set_traffic_id(const char* value);
  inline void set_traffic_id(const char* value, size_t size);
  inline ::std::string* mutable_traffic_id();
  inline ::std::string* release_traffic_id();
  inline void set_allocated_traffic_id(::std::string* traffic_id);

  // optional .com.telenav.proto.map.TimeProfile time_profile = 9;
  inline bool has_time_profile() const;
  inline void clear_time_profile();
  static const int kTimeProfileFieldNumber = 9;
  inline const ::com::telenav::proto::map::TimeProfile& time_profile() const;
  inline ::com::telenav::proto::map::TimeProfile* mutable_time_profile();
  inline ::com::telenav::proto::map::TimeProfile* release_time_profile();
  inline void set_allocated_time_profile(::com::telenav::proto::map::TimeProfile* time_profile);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.Edge)
 private:
  inline void set_has_speed_limit_in_kph();
  inline void clear_has_speed_limit_in_kph();
  inline void set_has_travel_speed_in_mps();
  inline void clear_has_travel_speed_in_mps();
  inline void set_has_length_in_meter();
  inline void clear_has_length_in_meter();
  inline void set_has_encoded_polyline();
  inline void clear_has_encoded_polyline();
  inline void set_has_traffic_id();
  inline void clear_has_traffic_id();
  inline void set_has_time_profile();
  inline void clear_has_time_profile();

  double speed_limit_in_kph_;
  double travel_speed_in_mps_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > map_edge_id_;
  ::std::string* encoded_polyline_;
  ::std::string* traffic_id_;
  ::com::telenav::proto::map::TimeProfile* time_profile_;
  ::google::protobuf::int32 length_in_meter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static Edge* default_instance_;
};
// -------------------------------------------------------------------

class TimeProfile : public ::google::protobuf::MessageLite {
 public:
  TimeProfile();
  virtual ~TimeProfile();

  TimeProfile(const TimeProfile& from);

  inline TimeProfile& operator=(const TimeProfile& from) {
    CopyFrom(from);
    return *this;
  }

  static const TimeProfile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeProfile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeProfile* other);

  // implements Message ----------------------------------------------

  TimeProfile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeProfile& from);
  void MergeFrom(const TimeProfile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 turn_cost = 1;
  inline bool has_turn_cost() const;
  inline void clear_turn_cost();
  static const int kTurnCostFieldNumber = 1;
  inline ::google::protobuf::int32 turn_cost() const;
  inline void set_turn_cost(::google::protobuf::int32 value);

  // optional double real_time_speed = 2;
  inline bool has_real_time_speed() const;
  inline void clear_real_time_speed();
  static const int kRealTimeSpeedFieldNumber = 2;
  inline double real_time_speed() const;
  inline void set_real_time_speed(double value);

  // optional string historical_pattern = 3;
  inline bool has_historical_pattern() const;
  inline void clear_historical_pattern();
  static const int kHistoricalPatternFieldNumber = 3;
  inline const ::std::string& historical_pattern() const;
  inline void set_historical_pattern(const ::std::string& value);
  inline void set_historical_pattern(const char* value);
  inline void set_historical_pattern(const char* value, size_t size);
  inline ::std::string* mutable_historical_pattern();
  inline ::std::string* release_historical_pattern();
  inline void set_allocated_historical_pattern(::std::string* historical_pattern);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.TimeProfile)
 private:
  inline void set_has_turn_cost();
  inline void clear_has_turn_cost();
  inline void set_has_real_time_speed();
  inline void clear_has_real_time_speed();
  inline void set_has_historical_pattern();
  inline void clear_has_historical_pattern();

  double real_time_speed_;
  ::std::string* historical_pattern_;
  ::google::protobuf::int32 turn_cost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static TimeProfile* default_instance_;
};
// -------------------------------------------------------------------

class LaneInfo : public ::google::protobuf::MessageLite {
 public:
  LaneInfo();
  virtual ~LaneInfo();

  LaneInfo(const LaneInfo& from);

  inline LaneInfo& operator=(const LaneInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const LaneInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LaneInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LaneInfo* other);

  // implements Message ----------------------------------------------

  LaneInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LaneInfo& from);
  void MergeFrom(const LaneInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.map.LanePattern pattern = 1;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 1;
  inline ::com::telenav::proto::map::LanePattern pattern() const;
  inline void set_pattern(::com::telenav::proto::map::LanePattern value);

  // optional .com.telenav.proto.map.HighlightedLane highlight = 2;
  inline bool has_highlight() const;
  inline void clear_highlight();
  static const int kHighlightFieldNumber = 2;
  inline ::com::telenav::proto::map::HighlightedLane highlight() const;
  inline void set_highlight(::com::telenav::proto::map::HighlightedLane value);

  // optional bool preferred = 3 [default = false];
  inline bool has_preferred() const;
  inline void clear_preferred();
  static const int kPreferredFieldNumber = 3;
  inline bool preferred() const;
  inline void set_preferred(bool value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.LaneInfo)
 private:
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_highlight();
  inline void clear_has_highlight();
  inline void set_has_preferred();
  inline void clear_has_preferred();

  int pattern_;
  int highlight_;
  bool preferred_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static LaneInfo* default_instance_;
};
// -------------------------------------------------------------------

class JunctionView : public ::google::protobuf::MessageLite {
 public:
  JunctionView();
  virtual ~JunctionView();

  JunctionView(const JunctionView& from);

  inline JunctionView& operator=(const JunctionView& from) {
    CopyFrom(from);
    return *this;
  }

  static const JunctionView& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JunctionView* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JunctionView* other);

  // implements Message ----------------------------------------------

  JunctionView* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JunctionView& from);
  void MergeFrom(const JunctionView& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.telenav.proto.map.JunctionViewType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::com::telenav::proto::map::JunctionViewType type() const;
  inline void set_type(::com::telenav::proto::map::JunctionViewType value);

  // optional string pattern_id = 2;
  inline bool has_pattern_id() const;
  inline void clear_pattern_id();
  static const int kPatternIdFieldNumber = 2;
  inline const ::std::string& pattern_id() const;
  inline void set_pattern_id(const ::std::string& value);
  inline void set_pattern_id(const char* value);
  inline void set_pattern_id(const char* value, size_t size);
  inline ::std::string* mutable_pattern_id();
  inline ::std::string* release_pattern_id();
  inline void set_allocated_pattern_id(::std::string* pattern_id);

  // optional string arrow_id = 3;
  inline bool has_arrow_id() const;
  inline void clear_arrow_id();
  static const int kArrowIdFieldNumber = 3;
  inline const ::std::string& arrow_id() const;
  inline void set_arrow_id(const ::std::string& value);
  inline void set_arrow_id(const char* value);
  inline void set_arrow_id(const char* value, size_t size);
  inline ::std::string* mutable_arrow_id();
  inline ::std::string* release_arrow_id();
  inline void set_allocated_arrow_id(::std::string* arrow_id);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.map.JunctionView)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pattern_id();
  inline void clear_has_pattern_id();
  inline void set_has_arrow_id();
  inline void clear_has_arrow_id();

  ::std::string* pattern_id_;
  ::std::string* arrow_id_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_map_2edirections_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_map_2edirections_2eproto();
  #endif
  friend void protobuf_AssignDesc_map_2edirections_2eproto();
  friend void protobuf_ShutdownFile_map_2edirections_2eproto();

  void InitAsDefaultInstance();
  static JunctionView* default_instance_;
};
// ===================================================================


// ===================================================================

// RouteRequest

// optional .com.telenav.proto.map.Location origin = 1;
inline bool RouteRequest::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteRequest::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteRequest::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouteRequest::clear_origin() {
  if (origin_ != NULL) origin_->::com::telenav::proto::map::Location::Clear();
  clear_has_origin();
}
inline const ::com::telenav::proto::map::Location& RouteRequest::origin() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return origin_ != NULL ? *origin_ : *default_instance().origin_;
#else
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
#endif
}
inline ::com::telenav::proto::map::Location* RouteRequest::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) origin_ = new ::com::telenav::proto::map::Location;
  return origin_;
}
inline ::com::telenav::proto::map::Location* RouteRequest::release_origin() {
  clear_has_origin();
  ::com::telenav::proto::map::Location* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void RouteRequest::set_allocated_origin(::com::telenav::proto::map::Location* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
}

// optional .com.telenav.proto.map.Location destination = 2;
inline bool RouteRequest::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RouteRequest::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RouteRequest::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RouteRequest::clear_destination() {
  if (destination_ != NULL) destination_->::com::telenav::proto::map::Location::Clear();
  clear_has_destination();
}
inline const ::com::telenav::proto::map::Location& RouteRequest::destination() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return destination_ != NULL ? *destination_ : *default_instance().destination_;
#else
  return destination_ != NULL ? *destination_ : *default_instance_->destination_;
#endif
}
inline ::com::telenav::proto::map::Location* RouteRequest::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) destination_ = new ::com::telenav::proto::map::Location;
  return destination_;
}
inline ::com::telenav::proto::map::Location* RouteRequest::release_destination() {
  clear_has_destination();
  ::com::telenav::proto::map::Location* temp = destination_;
  destination_ = NULL;
  return temp;
}
inline void RouteRequest::set_allocated_destination(::com::telenav::proto::map::Location* destination) {
  delete destination_;
  destination_ = destination;
  if (destination) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
}

// optional .com.telenav.proto.map.RouteStyle style = 7 [default = FASTEST];
inline bool RouteRequest::has_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RouteRequest::set_has_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RouteRequest::clear_has_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RouteRequest::clear_style() {
  style_ = 1;
  clear_has_style();
}
inline ::com::telenav::proto::map::RouteStyle RouteRequest::style() const {
  return static_cast< ::com::telenav::proto::map::RouteStyle >(style_);
}
inline void RouteRequest::set_style(::com::telenav::proto::map::RouteStyle value) {
  assert(::com::telenav::proto::map::RouteStyle_IsValid(value));
  set_has_style();
  style_ = value;
}

// optional .com.telenav.proto.map.RouteOption option = 8;
inline bool RouteRequest::has_option() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RouteRequest::set_has_option() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RouteRequest::clear_has_option() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RouteRequest::clear_option() {
  if (option_ != NULL) option_->::com::telenav::proto::map::RouteOption::Clear();
  clear_has_option();
}
inline const ::com::telenav::proto::map::RouteOption& RouteRequest::option() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return option_ != NULL ? *option_ : *default_instance().option_;
#else
  return option_ != NULL ? *option_ : *default_instance_->option_;
#endif
}
inline ::com::telenav::proto::map::RouteOption* RouteRequest::mutable_option() {
  set_has_option();
  if (option_ == NULL) option_ = new ::com::telenav::proto::map::RouteOption;
  return option_;
}
inline ::com::telenav::proto::map::RouteOption* RouteRequest::release_option() {
  clear_has_option();
  ::com::telenav::proto::map::RouteOption* temp = option_;
  option_ = NULL;
  return temp;
}
inline void RouteRequest::set_allocated_option(::com::telenav::proto::map::RouteOption* option) {
  delete option_;
  option_ = option;
  if (option) {
    set_has_option();
  } else {
    clear_has_option();
  }
}

// optional int32 max_route_number = 9 [default = 1];
inline bool RouteRequest::has_max_route_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RouteRequest::set_has_max_route_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RouteRequest::clear_has_max_route_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RouteRequest::clear_max_route_number() {
  max_route_number_ = 1;
  clear_has_max_route_number();
}
inline ::google::protobuf::int32 RouteRequest::max_route_number() const {
  return max_route_number_;
}
inline void RouteRequest::set_max_route_number(::google::protobuf::int32 value) {
  set_has_max_route_number();
  max_route_number_ = value;
}

// optional int32 heading = 10 [default = -1];
inline bool RouteRequest::has_heading() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RouteRequest::set_has_heading() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RouteRequest::clear_has_heading() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RouteRequest::clear_heading() {
  heading_ = -1;
  clear_has_heading();
}
inline ::google::protobuf::int32 RouteRequest::heading() const {
  return heading_;
}
inline void RouteRequest::set_heading(::google::protobuf::int32 value) {
  set_has_heading();
  heading_ = value;
}

// optional int32 speed_in_mps = 11;
inline bool RouteRequest::has_speed_in_mps() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RouteRequest::set_has_speed_in_mps() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RouteRequest::clear_has_speed_in_mps() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RouteRequest::clear_speed_in_mps() {
  speed_in_mps_ = 0;
  clear_has_speed_in_mps();
}
inline ::google::protobuf::int32 RouteRequest::speed_in_mps() const {
  return speed_in_mps_;
}
inline void RouteRequest::set_speed_in_mps(::google::protobuf::int32 value) {
  set_has_speed_in_mps();
  speed_in_mps_ = value;
}

// repeated .com.telenav.proto.LatLon dest_candidate = 12;
inline int RouteRequest::dest_candidate_size() const {
  return dest_candidate_.size();
}
inline void RouteRequest::clear_dest_candidate() {
  dest_candidate_.Clear();
}
inline const ::com::telenav::proto::LatLon& RouteRequest::dest_candidate(int index) const {
  return dest_candidate_.Get(index);
}
inline ::com::telenav::proto::LatLon* RouteRequest::mutable_dest_candidate(int index) {
  return dest_candidate_.Mutable(index);
}
inline ::com::telenav::proto::LatLon* RouteRequest::add_dest_candidate() {
  return dest_candidate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::LatLon >&
RouteRequest::dest_candidate() const {
  return dest_candidate_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::LatLon >*
RouteRequest::mutable_dest_candidate() {
  return &dest_candidate_;
}

// optional .com.telenav.proto.map.OutputOption output_option = 13;
inline bool RouteRequest::has_output_option() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RouteRequest::set_has_output_option() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RouteRequest::clear_has_output_option() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RouteRequest::clear_output_option() {
  if (output_option_ != NULL) output_option_->::com::telenav::proto::map::OutputOption::Clear();
  clear_has_output_option();
}
inline const ::com::telenav::proto::map::OutputOption& RouteRequest::output_option() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return output_option_ != NULL ? *output_option_ : *default_instance().output_option_;
#else
  return output_option_ != NULL ? *output_option_ : *default_instance_->output_option_;
#endif
}
inline ::com::telenav::proto::map::OutputOption* RouteRequest::mutable_output_option() {
  set_has_output_option();
  if (output_option_ == NULL) output_option_ = new ::com::telenav::proto::map::OutputOption;
  return output_option_;
}
inline ::com::telenav::proto::map::OutputOption* RouteRequest::release_output_option() {
  clear_has_output_option();
  ::com::telenav::proto::map::OutputOption* temp = output_option_;
  output_option_ = NULL;
  return temp;
}
inline void RouteRequest::set_allocated_output_option(::com::telenav::proto::map::OutputOption* output_option) {
  delete output_option_;
  output_option_ = output_option;
  if (output_option) {
    set_has_output_option();
  } else {
    clear_has_output_option();
  }
}

// optional int32 deviation_count = 18;
inline bool RouteRequest::has_deviation_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RouteRequest::set_has_deviation_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RouteRequest::clear_has_deviation_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RouteRequest::clear_deviation_count() {
  deviation_count_ = 0;
  clear_has_deviation_count();
}
inline ::google::protobuf::int32 RouteRequest::deviation_count() const {
  return deviation_count_;
}
inline void RouteRequest::set_deviation_count(::google::protobuf::int32 value) {
  set_has_deviation_count();
  deviation_count_ = value;
}

// optional string data_set = 19;
inline bool RouteRequest::has_data_set() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RouteRequest::set_has_data_set() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RouteRequest::clear_has_data_set() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RouteRequest::clear_data_set() {
  if (data_set_ != &::google::protobuf::internal::kEmptyString) {
    data_set_->clear();
  }
  clear_has_data_set();
}
inline const ::std::string& RouteRequest::data_set() const {
  return *data_set_;
}
inline void RouteRequest::set_data_set(const ::std::string& value) {
  set_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    data_set_ = new ::std::string;
  }
  data_set_->assign(value);
}
inline void RouteRequest::set_data_set(const char* value) {
  set_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    data_set_ = new ::std::string;
  }
  data_set_->assign(value);
}
inline void RouteRequest::set_data_set(const char* value, size_t size) {
  set_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    data_set_ = new ::std::string;
  }
  data_set_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteRequest::mutable_data_set() {
  set_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    data_set_ = new ::std::string;
  }
  return data_set_;
}
inline ::std::string* RouteRequest::release_data_set() {
  clear_has_data_set();
  if (data_set_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_set_;
    data_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouteRequest::set_allocated_data_set(::std::string* data_set) {
  if (data_set_ != &::google::protobuf::internal::kEmptyString) {
    delete data_set_;
  }
  if (data_set) {
    set_has_data_set();
    data_set_ = data_set;
  } else {
    clear_has_data_set();
    data_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.telenav.proto.Context context = 16;
inline bool RouteRequest::has_context() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RouteRequest::set_has_context() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RouteRequest::clear_has_context() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RouteRequest::clear_context() {
  if (context_ != NULL) context_->::com::telenav::proto::Context::Clear();
  clear_has_context();
}
inline const ::com::telenav::proto::Context& RouteRequest::context() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return context_ != NULL ? *context_ : *default_instance().context_;
#else
  return context_ != NULL ? *context_ : *default_instance_->context_;
#endif
}
inline ::com::telenav::proto::Context* RouteRequest::mutable_context() {
  set_has_context();
  if (context_ == NULL) context_ = new ::com::telenav::proto::Context;
  return context_;
}
inline ::com::telenav::proto::Context* RouteRequest::release_context() {
  clear_has_context();
  ::com::telenav::proto::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline void RouteRequest::set_allocated_context(::com::telenav::proto::Context* context) {
  delete context_;
  context_ = context;
  if (context) {
    set_has_context();
  } else {
    clear_has_context();
  }
}

// optional int64 route_start_time = 20;
inline bool RouteRequest::has_route_start_time() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RouteRequest::set_has_route_start_time() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RouteRequest::clear_has_route_start_time() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RouteRequest::clear_route_start_time() {
  route_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_route_start_time();
}
inline ::google::protobuf::int64 RouteRequest::route_start_time() const {
  return route_start_time_;
}
inline void RouteRequest::set_route_start_time(::google::protobuf::int64 value) {
  set_has_route_start_time();
  route_start_time_ = value;
}

// optional bool use_time_restriction_for_road = 21;
inline bool RouteRequest::has_use_time_restriction_for_road() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RouteRequest::set_has_use_time_restriction_for_road() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RouteRequest::clear_has_use_time_restriction_for_road() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RouteRequest::clear_use_time_restriction_for_road() {
  use_time_restriction_for_road_ = false;
  clear_has_use_time_restriction_for_road();
}
inline bool RouteRequest::use_time_restriction_for_road() const {
  return use_time_restriction_for_road_;
}
inline void RouteRequest::set_use_time_restriction_for_road(bool value) {
  set_has_use_time_restriction_for_road();
  use_time_restriction_for_road_ = value;
}

// optional .com.telenav.proto.map.EcoMode eco_mode = 22 [default = HIGH_ECO_MODE];
inline bool RouteRequest::has_eco_mode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RouteRequest::set_has_eco_mode() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RouteRequest::clear_has_eco_mode() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RouteRequest::clear_eco_mode() {
  eco_mode_ = 3;
  clear_has_eco_mode();
}
inline ::com::telenav::proto::map::EcoMode RouteRequest::eco_mode() const {
  return static_cast< ::com::telenav::proto::map::EcoMode >(eco_mode_);
}
inline void RouteRequest::set_eco_mode(::com::telenav::proto::map::EcoMode value) {
  assert(::com::telenav::proto::map::EcoMode_IsValid(value));
  set_has_eco_mode();
  eco_mode_ = value;
}

// repeated .com.telenav.proto.map.Location waypoint = 23;
inline int RouteRequest::waypoint_size() const {
  return waypoint_.size();
}
inline void RouteRequest::clear_waypoint() {
  waypoint_.Clear();
}
inline const ::com::telenav::proto::map::Location& RouteRequest::waypoint(int index) const {
  return waypoint_.Get(index);
}
inline ::com::telenav::proto::map::Location* RouteRequest::mutable_waypoint(int index) {
  return waypoint_.Mutable(index);
}
inline ::com::telenav::proto::map::Location* RouteRequest::add_waypoint() {
  return waypoint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Location >&
RouteRequest::waypoint() const {
  return waypoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Location >*
RouteRequest::mutable_waypoint() {
  return &waypoint_;
}

// -------------------------------------------------------------------

// RouteOption

// optional bool avoid_hov_lane = 1;
inline bool RouteOption::has_avoid_hov_lane() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteOption::set_has_avoid_hov_lane() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteOption::clear_has_avoid_hov_lane() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouteOption::clear_avoid_hov_lane() {
  avoid_hov_lane_ = false;
  clear_has_avoid_hov_lane();
}
inline bool RouteOption::avoid_hov_lane() const {
  return avoid_hov_lane_;
}
inline void RouteOption::set_avoid_hov_lane(bool value) {
  set_has_avoid_hov_lane();
  avoid_hov_lane_ = value;
}

// optional bool avoid_highway = 2;
inline bool RouteOption::has_avoid_highway() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RouteOption::set_has_avoid_highway() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RouteOption::clear_has_avoid_highway() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RouteOption::clear_avoid_highway() {
  avoid_highway_ = false;
  clear_has_avoid_highway();
}
inline bool RouteOption::avoid_highway() const {
  return avoid_highway_;
}
inline void RouteOption::set_avoid_highway(bool value) {
  set_has_avoid_highway();
  avoid_highway_ = value;
}

// optional bool avoid_toll_road = 3;
inline bool RouteOption::has_avoid_toll_road() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RouteOption::set_has_avoid_toll_road() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RouteOption::clear_has_avoid_toll_road() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RouteOption::clear_avoid_toll_road() {
  avoid_toll_road_ = false;
  clear_has_avoid_toll_road();
}
inline bool RouteOption::avoid_toll_road() const {
  return avoid_toll_road_;
}
inline void RouteOption::set_avoid_toll_road(bool value) {
  set_has_avoid_toll_road();
  avoid_toll_road_ = value;
}

// optional bool avoid_ferry = 4;
inline bool RouteOption::has_avoid_ferry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RouteOption::set_has_avoid_ferry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RouteOption::clear_has_avoid_ferry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RouteOption::clear_avoid_ferry() {
  avoid_ferry_ = false;
  clear_has_avoid_ferry();
}
inline bool RouteOption::avoid_ferry() const {
  return avoid_ferry_;
}
inline void RouteOption::set_avoid_ferry(bool value) {
  set_has_avoid_ferry();
  avoid_ferry_ = value;
}

// optional bool avoid_car_train = 5;
inline bool RouteOption::has_avoid_car_train() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RouteOption::set_has_avoid_car_train() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RouteOption::clear_has_avoid_car_train() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RouteOption::clear_avoid_car_train() {
  avoid_car_train_ = false;
  clear_has_avoid_car_train();
}
inline bool RouteOption::avoid_car_train() const {
  return avoid_car_train_;
}
inline void RouteOption::set_avoid_car_train(bool value) {
  set_has_avoid_car_train();
  avoid_car_train_ = value;
}

// optional bool avoid_unpaved_road = 6;
inline bool RouteOption::has_avoid_unpaved_road() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RouteOption::set_has_avoid_unpaved_road() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RouteOption::clear_has_avoid_unpaved_road() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RouteOption::clear_avoid_unpaved_road() {
  avoid_unpaved_road_ = false;
  clear_has_avoid_unpaved_road();
}
inline bool RouteOption::avoid_unpaved_road() const {
  return avoid_unpaved_road_;
}
inline void RouteOption::set_avoid_unpaved_road(bool value) {
  set_has_avoid_unpaved_road();
  avoid_unpaved_road_ = value;
}

// optional bool avoid_tunnel = 7;
inline bool RouteOption::has_avoid_tunnel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RouteOption::set_has_avoid_tunnel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RouteOption::clear_has_avoid_tunnel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RouteOption::clear_avoid_tunnel() {
  avoid_tunnel_ = false;
  clear_has_avoid_tunnel();
}
inline bool RouteOption::avoid_tunnel() const {
  return avoid_tunnel_;
}
inline void RouteOption::set_avoid_tunnel(bool value) {
  set_has_avoid_tunnel();
  avoid_tunnel_ = value;
}

// optional bool avoid_uturn = 8;
inline bool RouteOption::has_avoid_uturn() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RouteOption::set_has_avoid_uturn() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RouteOption::clear_has_avoid_uturn() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RouteOption::clear_avoid_uturn() {
  avoid_uturn_ = false;
  clear_has_avoid_uturn();
}
inline bool RouteOption::avoid_uturn() const {
  return avoid_uturn_;
}
inline void RouteOption::set_avoid_uturn(bool value) {
  set_has_avoid_uturn();
  avoid_uturn_ = value;
}

// optional bool avoid_traffic = 9;
inline bool RouteOption::has_avoid_traffic() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RouteOption::set_has_avoid_traffic() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RouteOption::clear_has_avoid_traffic() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RouteOption::clear_avoid_traffic() {
  avoid_traffic_ = false;
  clear_has_avoid_traffic();
}
inline bool RouteOption::avoid_traffic() const {
  return avoid_traffic_;
}
inline void RouteOption::set_avoid_traffic(bool value) {
  set_has_avoid_traffic();
  avoid_traffic_ = value;
}

// repeated int64 must_avoid_edge_id = 10;
inline int RouteOption::must_avoid_edge_id_size() const {
  return must_avoid_edge_id_.size();
}
inline void RouteOption::clear_must_avoid_edge_id() {
  must_avoid_edge_id_.Clear();
}
inline ::google::protobuf::int64 RouteOption::must_avoid_edge_id(int index) const {
  return must_avoid_edge_id_.Get(index);
}
inline void RouteOption::set_must_avoid_edge_id(int index, ::google::protobuf::int64 value) {
  must_avoid_edge_id_.Set(index, value);
}
inline void RouteOption::add_must_avoid_edge_id(::google::protobuf::int64 value) {
  must_avoid_edge_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
RouteOption::must_avoid_edge_id() const {
  return must_avoid_edge_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
RouteOption::mutable_must_avoid_edge_id() {
  return &must_avoid_edge_id_;
}

// repeated int64 try_avoid_edge_Id = 11;
inline int RouteOption::try_avoid_edge_id_size() const {
  return try_avoid_edge_id_.size();
}
inline void RouteOption::clear_try_avoid_edge_id() {
  try_avoid_edge_id_.Clear();
}
inline ::google::protobuf::int64 RouteOption::try_avoid_edge_id(int index) const {
  return try_avoid_edge_id_.Get(index);
}
inline void RouteOption::set_try_avoid_edge_id(int index, ::google::protobuf::int64 value) {
  try_avoid_edge_id_.Set(index, value);
}
inline void RouteOption::add_try_avoid_edge_id(::google::protobuf::int64 value) {
  try_avoid_edge_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
RouteOption::try_avoid_edge_id() const {
  return try_avoid_edge_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
RouteOption::mutable_try_avoid_edge_id() {
  return &try_avoid_edge_id_;
}

// repeated int64 preferred_edge_Id = 12;
inline int RouteOption::preferred_edge_id_size() const {
  return preferred_edge_id_.size();
}
inline void RouteOption::clear_preferred_edge_id() {
  preferred_edge_id_.Clear();
}
inline ::google::protobuf::int64 RouteOption::preferred_edge_id(int index) const {
  return preferred_edge_id_.Get(index);
}
inline void RouteOption::set_preferred_edge_id(int index, ::google::protobuf::int64 value) {
  preferred_edge_id_.Set(index, value);
}
inline void RouteOption::add_preferred_edge_id(::google::protobuf::int64 value) {
  preferred_edge_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
RouteOption::preferred_edge_id() const {
  return preferred_edge_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
RouteOption::mutable_preferred_edge_id() {
  return &preferred_edge_id_;
}

// repeated string avoid_traffic_id = 13;
inline int RouteOption::avoid_traffic_id_size() const {
  return avoid_traffic_id_.size();
}
inline void RouteOption::clear_avoid_traffic_id() {
  avoid_traffic_id_.Clear();
}
inline const ::std::string& RouteOption::avoid_traffic_id(int index) const {
  return avoid_traffic_id_.Get(index);
}
inline ::std::string* RouteOption::mutable_avoid_traffic_id(int index) {
  return avoid_traffic_id_.Mutable(index);
}
inline void RouteOption::set_avoid_traffic_id(int index, const ::std::string& value) {
  avoid_traffic_id_.Mutable(index)->assign(value);
}
inline void RouteOption::set_avoid_traffic_id(int index, const char* value) {
  avoid_traffic_id_.Mutable(index)->assign(value);
}
inline void RouteOption::set_avoid_traffic_id(int index, const char* value, size_t size) {
  avoid_traffic_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteOption::add_avoid_traffic_id() {
  return avoid_traffic_id_.Add();
}
inline void RouteOption::add_avoid_traffic_id(const ::std::string& value) {
  avoid_traffic_id_.Add()->assign(value);
}
inline void RouteOption::add_avoid_traffic_id(const char* value) {
  avoid_traffic_id_.Add()->assign(value);
}
inline void RouteOption::add_avoid_traffic_id(const char* value, size_t size) {
  avoid_traffic_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RouteOption::avoid_traffic_id() const {
  return avoid_traffic_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RouteOption::mutable_avoid_traffic_id() {
  return &avoid_traffic_id_;
}

// -------------------------------------------------------------------

// Location

// optional .com.telenav.proto.LatLon lat_lon = 1;
inline bool Location::has_lat_lon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location::set_has_lat_lon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location::clear_has_lat_lon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location::clear_lat_lon() {
  if (lat_lon_ != NULL) lat_lon_->::com::telenav::proto::LatLon::Clear();
  clear_has_lat_lon();
}
inline const ::com::telenav::proto::LatLon& Location::lat_lon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return lat_lon_ != NULL ? *lat_lon_ : *default_instance().lat_lon_;
#else
  return lat_lon_ != NULL ? *lat_lon_ : *default_instance_->lat_lon_;
#endif
}
inline ::com::telenav::proto::LatLon* Location::mutable_lat_lon() {
  set_has_lat_lon();
  if (lat_lon_ == NULL) lat_lon_ = new ::com::telenav::proto::LatLon;
  return lat_lon_;
}
inline ::com::telenav::proto::LatLon* Location::release_lat_lon() {
  clear_has_lat_lon();
  ::com::telenav::proto::LatLon* temp = lat_lon_;
  lat_lon_ = NULL;
  return temp;
}
inline void Location::set_allocated_lat_lon(::com::telenav::proto::LatLon* lat_lon) {
  delete lat_lon_;
  lat_lon_ = lat_lon;
  if (lat_lon) {
    set_has_lat_lon();
  } else {
    clear_has_lat_lon();
  }
}

// optional .com.telenav.proto.Address address = 2;
inline bool Location::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location::clear_address() {
  if (address_ != NULL) address_->::com::telenav::proto::Address::Clear();
  clear_has_address();
}
inline const ::com::telenav::proto::Address& Location::address() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return address_ != NULL ? *address_ : *default_instance().address_;
#else
  return address_ != NULL ? *address_ : *default_instance_->address_;
#endif
}
inline ::com::telenav::proto::Address* Location::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::com::telenav::proto::Address;
  return address_;
}
inline ::com::telenav::proto::Address* Location::release_address() {
  clear_has_address();
  ::com::telenav::proto::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void Location::set_allocated_address(::com::telenav::proto::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
}

// repeated int64 edge_id = 3;
inline int Location::edge_id_size() const {
  return edge_id_.size();
}
inline void Location::clear_edge_id() {
  edge_id_.Clear();
}
inline ::google::protobuf::int64 Location::edge_id(int index) const {
  return edge_id_.Get(index);
}
inline void Location::set_edge_id(int index, ::google::protobuf::int64 value) {
  edge_id_.Set(index, value);
}
inline void Location::add_edge_id(::google::protobuf::int64 value) {
  edge_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Location::edge_id() const {
  return edge_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Location::mutable_edge_id() {
  return &edge_id_;
}

// -------------------------------------------------------------------

// OutputOption

// optional bool eta_only = 1 [default = false];
inline bool OutputOption::has_eta_only() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OutputOption::set_has_eta_only() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OutputOption::clear_has_eta_only() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OutputOption::clear_eta_only() {
  eta_only_ = false;
  clear_has_eta_only();
}
inline bool OutputOption::eta_only() const {
  return eta_only_;
}
inline void OutputOption::set_eta_only(bool value) {
  set_has_eta_only();
  eta_only_ = value;
}

// optional bool edge_detail = 2 [default = false];
inline bool OutputOption::has_edge_detail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OutputOption::set_has_edge_detail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OutputOption::clear_has_edge_detail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OutputOption::clear_edge_detail() {
  edge_detail_ = false;
  clear_has_edge_detail();
}
inline bool OutputOption::edge_detail() const {
  return edge_detail_;
}
inline void OutputOption::set_edge_detail(bool value) {
  set_has_edge_detail();
  edge_detail_ = value;
}

// optional bool basic_route = 3 [default = false];
inline bool OutputOption::has_basic_route() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OutputOption::set_has_basic_route() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OutputOption::clear_has_basic_route() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OutputOption::clear_basic_route() {
  basic_route_ = false;
  clear_has_basic_route();
}
inline bool OutputOption::basic_route() const {
  return basic_route_;
}
inline void OutputOption::set_basic_route(bool value) {
  set_has_basic_route();
  basic_route_ = value;
}

// optional bool traffic_id = 4 [default = true];
inline bool OutputOption::has_traffic_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OutputOption::set_has_traffic_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OutputOption::clear_has_traffic_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OutputOption::clear_traffic_id() {
  traffic_id_ = true;
  clear_has_traffic_id();
}
inline bool OutputOption::traffic_id() const {
  return traffic_id_;
}
inline void OutputOption::set_traffic_id(bool value) {
  set_has_traffic_id();
  traffic_id_ = value;
}

// optional bool lane_info = 5 [default = true];
inline bool OutputOption::has_lane_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OutputOption::set_has_lane_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OutputOption::clear_has_lane_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OutputOption::clear_lane_info() {
  lane_info_ = true;
  clear_has_lane_info();
}
inline bool OutputOption::lane_info() const {
  return lane_info_;
}
inline void OutputOption::set_lane_info(bool value) {
  set_has_lane_info();
  lane_info_ = value;
}

// optional bool speed_limit = 6 [default = true];
inline bool OutputOption::has_speed_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OutputOption::set_has_speed_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OutputOption::clear_has_speed_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OutputOption::clear_speed_limit() {
  speed_limit_ = true;
  clear_has_speed_limit();
}
inline bool OutputOption::speed_limit() const {
  return speed_limit_;
}
inline void OutputOption::set_speed_limit(bool value) {
  set_has_speed_limit();
  speed_limit_ = value;
}

// optional bool overview = 9 [default = false];
inline bool OutputOption::has_overview() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OutputOption::set_has_overview() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OutputOption::clear_has_overview() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OutputOption::clear_overview() {
  overview_ = false;
  clear_has_overview();
}
inline bool OutputOption::overview() const {
  return overview_;
}
inline void OutputOption::set_overview(bool value) {
  set_has_overview();
  overview_ = value;
}

// optional bool route_info = 10 [default = true];
inline bool OutputOption::has_route_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OutputOption::set_has_route_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OutputOption::clear_has_route_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OutputOption::clear_route_info() {
  route_info_ = true;
  clear_has_route_info();
}
inline bool OutputOption::route_info() const {
  return route_info_;
}
inline void OutputOption::set_route_info(bool value) {
  set_has_route_info();
  route_info_ = value;
}

// optional int32 overview_decimated_level = 11;
inline bool OutputOption::has_overview_decimated_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OutputOption::set_has_overview_decimated_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OutputOption::clear_has_overview_decimated_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OutputOption::clear_overview_decimated_level() {
  overview_decimated_level_ = 0;
  clear_has_overview_decimated_level();
}
inline ::google::protobuf::int32 OutputOption::overview_decimated_level() const {
  return overview_decimated_level_;
}
inline void OutputOption::set_overview_decimated_level(::google::protobuf::int32 value) {
  set_has_overview_decimated_level();
  overview_decimated_level_ = value;
}

// -------------------------------------------------------------------

// GuidanceRequest

// repeated .com.telenav.proto.map.BasicPath basic_path = 1;
inline int GuidanceRequest::basic_path_size() const {
  return basic_path_.size();
}
inline void GuidanceRequest::clear_basic_path() {
  basic_path_.Clear();
}
inline const ::com::telenav::proto::map::BasicPath& GuidanceRequest::basic_path(int index) const {
  return basic_path_.Get(index);
}
inline ::com::telenav::proto::map::BasicPath* GuidanceRequest::mutable_basic_path(int index) {
  return basic_path_.Mutable(index);
}
inline ::com::telenav::proto::map::BasicPath* GuidanceRequest::add_basic_path() {
  return basic_path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicPath >&
GuidanceRequest::basic_path() const {
  return basic_path_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicPath >*
GuidanceRequest::mutable_basic_path() {
  return &basic_path_;
}

// optional int32 start_index = 2;
inline bool GuidanceRequest::has_start_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuidanceRequest::set_has_start_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuidanceRequest::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuidanceRequest::clear_start_index() {
  start_index_ = 0;
  clear_has_start_index();
}
inline ::google::protobuf::int32 GuidanceRequest::start_index() const {
  return start_index_;
}
inline void GuidanceRequest::set_start_index(::google::protobuf::int32 value) {
  set_has_start_index();
  start_index_ = value;
}

// optional int32 end_index = 3;
inline bool GuidanceRequest::has_end_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuidanceRequest::set_has_end_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuidanceRequest::clear_has_end_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuidanceRequest::clear_end_index() {
  end_index_ = 0;
  clear_has_end_index();
}
inline ::google::protobuf::int32 GuidanceRequest::end_index() const {
  return end_index_;
}
inline void GuidanceRequest::set_end_index(::google::protobuf::int32 value) {
  set_has_end_index();
  end_index_ = value;
}

// optional int32 length_in_meter = 4;
inline bool GuidanceRequest::has_length_in_meter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuidanceRequest::set_has_length_in_meter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuidanceRequest::clear_has_length_in_meter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuidanceRequest::clear_length_in_meter() {
  length_in_meter_ = 0;
  clear_has_length_in_meter();
}
inline ::google::protobuf::int32 GuidanceRequest::length_in_meter() const {
  return length_in_meter_;
}
inline void GuidanceRequest::set_length_in_meter(::google::protobuf::int32 value) {
  set_has_length_in_meter();
  length_in_meter_ = value;
}

// -------------------------------------------------------------------

// BasicRouteResponse

// optional .com.telenav.proto.ServiceStatus status = 1;
inline bool BasicRouteResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasicRouteResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasicRouteResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasicRouteResponse::clear_status() {
  if (status_ != NULL) status_->::com::telenav::proto::ServiceStatus::Clear();
  clear_has_status();
}
inline const ::com::telenav::proto::ServiceStatus& BasicRouteResponse::status() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return status_ != NULL ? *status_ : *default_instance().status_;
#else
  return status_ != NULL ? *status_ : *default_instance_->status_;
#endif
}
inline ::com::telenav::proto::ServiceStatus* BasicRouteResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::com::telenav::proto::ServiceStatus;
  return status_;
}
inline ::com::telenav::proto::ServiceStatus* BasicRouteResponse::release_status() {
  clear_has_status();
  ::com::telenav::proto::ServiceStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void BasicRouteResponse::set_allocated_status(::com::telenav::proto::ServiceStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional string data_version = 3;
inline bool BasicRouteResponse::has_data_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasicRouteResponse::set_has_data_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasicRouteResponse::clear_has_data_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasicRouteResponse::clear_data_version() {
  if (data_version_ != &::google::protobuf::internal::kEmptyString) {
    data_version_->clear();
  }
  clear_has_data_version();
}
inline const ::std::string& BasicRouteResponse::data_version() const {
  return *data_version_;
}
inline void BasicRouteResponse::set_data_version(const ::std::string& value) {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  data_version_->assign(value);
}
inline void BasicRouteResponse::set_data_version(const char* value) {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  data_version_->assign(value);
}
inline void BasicRouteResponse::set_data_version(const char* value, size_t size) {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  data_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicRouteResponse::mutable_data_version() {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  return data_version_;
}
inline ::std::string* BasicRouteResponse::release_data_version() {
  clear_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_version_;
    data_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicRouteResponse::set_allocated_data_version(::std::string* data_version) {
  if (data_version_ != &::google::protobuf::internal::kEmptyString) {
    delete data_version_;
  }
  if (data_version) {
    set_has_data_version();
    data_version_ = data_version;
  } else {
    clear_has_data_version();
    data_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.telenav.proto.map.RouteInfo route_info = 4;
inline int BasicRouteResponse::route_info_size() const {
  return route_info_.size();
}
inline void BasicRouteResponse::clear_route_info() {
  route_info_.Clear();
}
inline const ::com::telenav::proto::map::RouteInfo& BasicRouteResponse::route_info(int index) const {
  return route_info_.Get(index);
}
inline ::com::telenav::proto::map::RouteInfo* BasicRouteResponse::mutable_route_info(int index) {
  return route_info_.Mutable(index);
}
inline ::com::telenav::proto::map::RouteInfo* BasicRouteResponse::add_route_info() {
  return route_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::RouteInfo >&
BasicRouteResponse::route_info() const {
  return route_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::RouteInfo >*
BasicRouteResponse::mutable_route_info() {
  return &route_info_;
}

// repeated .com.telenav.proto.map.BasicRoute route = 5;
inline int BasicRouteResponse::route_size() const {
  return route_.size();
}
inline void BasicRouteResponse::clear_route() {
  route_.Clear();
}
inline const ::com::telenav::proto::map::BasicRoute& BasicRouteResponse::route(int index) const {
  return route_.Get(index);
}
inline ::com::telenav::proto::map::BasicRoute* BasicRouteResponse::mutable_route(int index) {
  return route_.Mutable(index);
}
inline ::com::telenav::proto::map::BasicRoute* BasicRouteResponse::add_route() {
  return route_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicRoute >&
BasicRouteResponse::route() const {
  return route_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicRoute >*
BasicRouteResponse::mutable_route() {
  return &route_;
}

// -------------------------------------------------------------------

// RouteResponse

// optional .com.telenav.proto.ServiceStatus status = 1;
inline bool RouteResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouteResponse::clear_status() {
  if (status_ != NULL) status_->::com::telenav::proto::ServiceStatus::Clear();
  clear_has_status();
}
inline const ::com::telenav::proto::ServiceStatus& RouteResponse::status() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return status_ != NULL ? *status_ : *default_instance().status_;
#else
  return status_ != NULL ? *status_ : *default_instance_->status_;
#endif
}
inline ::com::telenav::proto::ServiceStatus* RouteResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::com::telenav::proto::ServiceStatus;
  return status_;
}
inline ::com::telenav::proto::ServiceStatus* RouteResponse::release_status() {
  clear_has_status();
  ::com::telenav::proto::ServiceStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void RouteResponse::set_allocated_status(::com::telenav::proto::ServiceStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional string data_version = 3;
inline bool RouteResponse::has_data_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RouteResponse::set_has_data_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RouteResponse::clear_has_data_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RouteResponse::clear_data_version() {
  if (data_version_ != &::google::protobuf::internal::kEmptyString) {
    data_version_->clear();
  }
  clear_has_data_version();
}
inline const ::std::string& RouteResponse::data_version() const {
  return *data_version_;
}
inline void RouteResponse::set_data_version(const ::std::string& value) {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  data_version_->assign(value);
}
inline void RouteResponse::set_data_version(const char* value) {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  data_version_->assign(value);
}
inline void RouteResponse::set_data_version(const char* value, size_t size) {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  data_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteResponse::mutable_data_version() {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  return data_version_;
}
inline ::std::string* RouteResponse::release_data_version() {
  clear_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_version_;
    data_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouteResponse::set_allocated_data_version(::std::string* data_version) {
  if (data_version_ != &::google::protobuf::internal::kEmptyString) {
    delete data_version_;
  }
  if (data_version) {
    set_has_data_version();
    data_version_ = data_version;
  } else {
    clear_has_data_version();
    data_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.telenav.proto.map.Route route = 4;
inline int RouteResponse::route_size() const {
  return route_.size();
}
inline void RouteResponse::clear_route() {
  route_.Clear();
}
inline const ::com::telenav::proto::map::Route& RouteResponse::route(int index) const {
  return route_.Get(index);
}
inline ::com::telenav::proto::map::Route* RouteResponse::mutable_route(int index) {
  return route_.Mutable(index);
}
inline ::com::telenav::proto::map::Route* RouteResponse::add_route() {
  return route_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Route >&
RouteResponse::route() const {
  return route_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Route >*
RouteResponse::mutable_route() {
  return &route_;
}

// -------------------------------------------------------------------

// FindMeRequest

// repeated .com.telenav.proto.map.GpsFix gps_fix = 1;
inline int FindMeRequest::gps_fix_size() const {
  return gps_fix_.size();
}
inline void FindMeRequest::clear_gps_fix() {
  gps_fix_.Clear();
}
inline const ::com::telenav::proto::map::GpsFix& FindMeRequest::gps_fix(int index) const {
  return gps_fix_.Get(index);
}
inline ::com::telenav::proto::map::GpsFix* FindMeRequest::mutable_gps_fix(int index) {
  return gps_fix_.Mutable(index);
}
inline ::com::telenav::proto::map::GpsFix* FindMeRequest::add_gps_fix() {
  return gps_fix_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::GpsFix >&
FindMeRequest::gps_fix() const {
  return gps_fix_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::GpsFix >*
FindMeRequest::mutable_gps_fix() {
  return &gps_fix_;
}

// optional int32 latch_heading = 2 [default = -999];
inline bool FindMeRequest::has_latch_heading() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindMeRequest::set_has_latch_heading() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindMeRequest::clear_has_latch_heading() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindMeRequest::clear_latch_heading() {
  latch_heading_ = -999;
  clear_has_latch_heading();
}
inline ::google::protobuf::int32 FindMeRequest::latch_heading() const {
  return latch_heading_;
}
inline void FindMeRequest::set_latch_heading(::google::protobuf::int32 value) {
  set_has_latch_heading();
  latch_heading_ = value;
}

// optional .com.telenav.proto.Context context = 3;
inline bool FindMeRequest::has_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FindMeRequest::set_has_context() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FindMeRequest::clear_has_context() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FindMeRequest::clear_context() {
  if (context_ != NULL) context_->::com::telenav::proto::Context::Clear();
  clear_has_context();
}
inline const ::com::telenav::proto::Context& FindMeRequest::context() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return context_ != NULL ? *context_ : *default_instance().context_;
#else
  return context_ != NULL ? *context_ : *default_instance_->context_;
#endif
}
inline ::com::telenav::proto::Context* FindMeRequest::mutable_context() {
  set_has_context();
  if (context_ == NULL) context_ = new ::com::telenav::proto::Context;
  return context_;
}
inline ::com::telenav::proto::Context* FindMeRequest::release_context() {
  clear_has_context();
  ::com::telenav::proto::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline void FindMeRequest::set_allocated_context(::com::telenav::proto::Context* context) {
  delete context_;
  context_ = context;
  if (context) {
    set_has_context();
  } else {
    clear_has_context();
  }
}

// -------------------------------------------------------------------

// FindMeResponse

// optional .com.telenav.proto.ServiceStatus status = 1;
inline bool FindMeResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindMeResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindMeResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindMeResponse::clear_status() {
  if (status_ != NULL) status_->::com::telenav::proto::ServiceStatus::Clear();
  clear_has_status();
}
inline const ::com::telenav::proto::ServiceStatus& FindMeResponse::status() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return status_ != NULL ? *status_ : *default_instance().status_;
#else
  return status_ != NULL ? *status_ : *default_instance_->status_;
#endif
}
inline ::com::telenav::proto::ServiceStatus* FindMeResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::com::telenav::proto::ServiceStatus;
  return status_;
}
inline ::com::telenav::proto::ServiceStatus* FindMeResponse::release_status() {
  clear_has_status();
  ::com::telenav::proto::ServiceStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void FindMeResponse::set_allocated_status(::com::telenav::proto::ServiceStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional string data_version = 3;
inline bool FindMeResponse::has_data_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindMeResponse::set_has_data_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindMeResponse::clear_has_data_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindMeResponse::clear_data_version() {
  if (data_version_ != &::google::protobuf::internal::kEmptyString) {
    data_version_->clear();
  }
  clear_has_data_version();
}
inline const ::std::string& FindMeResponse::data_version() const {
  return *data_version_;
}
inline void FindMeResponse::set_data_version(const ::std::string& value) {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  data_version_->assign(value);
}
inline void FindMeResponse::set_data_version(const char* value) {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  data_version_->assign(value);
}
inline void FindMeResponse::set_data_version(const char* value, size_t size) {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  data_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindMeResponse::mutable_data_version() {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  return data_version_;
}
inline ::std::string* FindMeResponse::release_data_version() {
  clear_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_version_;
    data_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FindMeResponse::set_allocated_data_version(::std::string* data_version) {
  if (data_version_ != &::google::protobuf::internal::kEmptyString) {
    delete data_version_;
  }
  if (data_version) {
    set_has_data_version();
    data_version_ = data_version;
  } else {
    clear_has_data_version();
    data_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.telenav.proto.map.Candidate candidate = 4;
inline int FindMeResponse::candidate_size() const {
  return candidate_.size();
}
inline void FindMeResponse::clear_candidate() {
  candidate_.Clear();
}
inline const ::com::telenav::proto::map::Candidate& FindMeResponse::candidate(int index) const {
  return candidate_.Get(index);
}
inline ::com::telenav::proto::map::Candidate* FindMeResponse::mutable_candidate(int index) {
  return candidate_.Mutable(index);
}
inline ::com::telenav::proto::map::Candidate* FindMeResponse::add_candidate() {
  return candidate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Candidate >&
FindMeResponse::candidate() const {
  return candidate_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Candidate >*
FindMeResponse::mutable_candidate() {
  return &candidate_;
}

// -------------------------------------------------------------------

// SystemInfoResponse

// optional .com.telenav.proto.ServiceStatus status = 1;
inline bool SystemInfoResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemInfoResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemInfoResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemInfoResponse::clear_status() {
  if (status_ != NULL) status_->::com::telenav::proto::ServiceStatus::Clear();
  clear_has_status();
}
inline const ::com::telenav::proto::ServiceStatus& SystemInfoResponse::status() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return status_ != NULL ? *status_ : *default_instance().status_;
#else
  return status_ != NULL ? *status_ : *default_instance_->status_;
#endif
}
inline ::com::telenav::proto::ServiceStatus* SystemInfoResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::com::telenav::proto::ServiceStatus;
  return status_;
}
inline ::com::telenav::proto::ServiceStatus* SystemInfoResponse::release_status() {
  clear_has_status();
  ::com::telenav::proto::ServiceStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void SystemInfoResponse::set_allocated_status(::com::telenav::proto::ServiceStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional string app_version = 2;
inline bool SystemInfoResponse::has_app_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemInfoResponse::set_has_app_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemInfoResponse::clear_has_app_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemInfoResponse::clear_app_version() {
  if (app_version_ != &::google::protobuf::internal::kEmptyString) {
    app_version_->clear();
  }
  clear_has_app_version();
}
inline const ::std::string& SystemInfoResponse::app_version() const {
  return *app_version_;
}
inline void SystemInfoResponse::set_app_version(const ::std::string& value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
}
inline void SystemInfoResponse::set_app_version(const char* value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
}
inline void SystemInfoResponse::set_app_version(const char* value, size_t size) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemInfoResponse::mutable_app_version() {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    app_version_ = new ::std::string;
  }
  return app_version_;
}
inline ::std::string* SystemInfoResponse::release_app_version() {
  clear_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_version_;
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemInfoResponse::set_allocated_app_version(::std::string* app_version) {
  if (app_version_ != &::google::protobuf::internal::kEmptyString) {
    delete app_version_;
  }
  if (app_version) {
    set_has_app_version();
    app_version_ = app_version;
  } else {
    clear_has_app_version();
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string data_version = 3;
inline bool SystemInfoResponse::has_data_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemInfoResponse::set_has_data_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemInfoResponse::clear_has_data_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemInfoResponse::clear_data_version() {
  if (data_version_ != &::google::protobuf::internal::kEmptyString) {
    data_version_->clear();
  }
  clear_has_data_version();
}
inline const ::std::string& SystemInfoResponse::data_version() const {
  return *data_version_;
}
inline void SystemInfoResponse::set_data_version(const ::std::string& value) {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  data_version_->assign(value);
}
inline void SystemInfoResponse::set_data_version(const char* value) {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  data_version_->assign(value);
}
inline void SystemInfoResponse::set_data_version(const char* value, size_t size) {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  data_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemInfoResponse::mutable_data_version() {
  set_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    data_version_ = new ::std::string;
  }
  return data_version_;
}
inline ::std::string* SystemInfoResponse::release_data_version() {
  clear_has_data_version();
  if (data_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_version_;
    data_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemInfoResponse::set_allocated_data_version(::std::string* data_version) {
  if (data_version_ != &::google::protobuf::internal::kEmptyString) {
    delete data_version_;
  }
  if (data_version) {
    set_has_data_version();
    data_version_ = data_version;
  } else {
    clear_has_data_version();
    data_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 up_time = 4;
inline bool SystemInfoResponse::has_up_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SystemInfoResponse::set_has_up_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SystemInfoResponse::clear_has_up_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SystemInfoResponse::clear_up_time() {
  up_time_ = GOOGLE_LONGLONG(0);
  clear_has_up_time();
}
inline ::google::protobuf::int64 SystemInfoResponse::up_time() const {
  return up_time_;
}
inline void SystemInfoResponse::set_up_time(::google::protobuf::int64 value) {
  set_has_up_time();
  up_time_ = value;
}

// -------------------------------------------------------------------

// GpsFix

// optional double lat = 1;
inline bool GpsFix::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpsFix::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpsFix::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpsFix::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double GpsFix::lat() const {
  return lat_;
}
inline void GpsFix::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional double lon = 2;
inline bool GpsFix::has_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpsFix::set_has_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpsFix::clear_has_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpsFix::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double GpsFix::lon() const {
  return lon_;
}
inline void GpsFix::set_lon(double value) {
  set_has_lon();
  lon_ = value;
}

// optional double alt = 3;
inline bool GpsFix::has_alt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpsFix::set_has_alt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpsFix::clear_has_alt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpsFix::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline double GpsFix::alt() const {
  return alt_;
}
inline void GpsFix::set_alt(double value) {
  set_has_alt();
  alt_ = value;
}

// optional int64 time_stamp = 4;
inline bool GpsFix::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GpsFix::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GpsFix::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GpsFix::clear_time_stamp() {
  time_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_time_stamp();
}
inline ::google::protobuf::int64 GpsFix::time_stamp() const {
  return time_stamp_;
}
inline void GpsFix::set_time_stamp(::google::protobuf::int64 value) {
  set_has_time_stamp();
  time_stamp_ = value;
}

// optional int32 speed = 5;
inline bool GpsFix::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GpsFix::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GpsFix::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GpsFix::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 GpsFix::speed() const {
  return speed_;
}
inline void GpsFix::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
}

// optional int32 heading = 6;
inline bool GpsFix::has_heading() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GpsFix::set_has_heading() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GpsFix::clear_has_heading() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GpsFix::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline ::google::protobuf::int32 GpsFix::heading() const {
  return heading_;
}
inline void GpsFix::set_heading(::google::protobuf::int32 value) {
  set_has_heading();
  heading_ = value;
}

// optional int32 error = 7;
inline bool GpsFix::has_error() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GpsFix::set_has_error() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GpsFix::clear_has_error() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GpsFix::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::google::protobuf::int32 GpsFix::error() const {
  return error_;
}
inline void GpsFix::set_error(::google::protobuf::int32 value) {
  set_has_error();
  error_ = value;
}

// -------------------------------------------------------------------

// Candidate

// optional .com.telenav.proto.LatLon lat_lon = 1;
inline bool Candidate::has_lat_lon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Candidate::set_has_lat_lon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Candidate::clear_has_lat_lon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Candidate::clear_lat_lon() {
  if (lat_lon_ != NULL) lat_lon_->::com::telenav::proto::LatLon::Clear();
  clear_has_lat_lon();
}
inline const ::com::telenav::proto::LatLon& Candidate::lat_lon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return lat_lon_ != NULL ? *lat_lon_ : *default_instance().lat_lon_;
#else
  return lat_lon_ != NULL ? *lat_lon_ : *default_instance_->lat_lon_;
#endif
}
inline ::com::telenav::proto::LatLon* Candidate::mutable_lat_lon() {
  set_has_lat_lon();
  if (lat_lon_ == NULL) lat_lon_ = new ::com::telenav::proto::LatLon;
  return lat_lon_;
}
inline ::com::telenav::proto::LatLon* Candidate::release_lat_lon() {
  clear_has_lat_lon();
  ::com::telenav::proto::LatLon* temp = lat_lon_;
  lat_lon_ = NULL;
  return temp;
}
inline void Candidate::set_allocated_lat_lon(::com::telenav::proto::LatLon* lat_lon) {
  delete lat_lon_;
  lat_lon_ = lat_lon;
  if (lat_lon) {
    set_has_lat_lon();
  } else {
    clear_has_lat_lon();
  }
}

// optional .com.telenav.proto.Address address = 2;
inline bool Candidate::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Candidate::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Candidate::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Candidate::clear_address() {
  if (address_ != NULL) address_->::com::telenav::proto::Address::Clear();
  clear_has_address();
}
inline const ::com::telenav::proto::Address& Candidate::address() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return address_ != NULL ? *address_ : *default_instance().address_;
#else
  return address_ != NULL ? *address_ : *default_instance_->address_;
#endif
}
inline ::com::telenav::proto::Address* Candidate::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::com::telenav::proto::Address;
  return address_;
}
inline ::com::telenav::proto::Address* Candidate::release_address() {
  clear_has_address();
  ::com::telenav::proto::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void Candidate::set_allocated_address(::com::telenav::proto::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
}

// optional int32 heading = 3;
inline bool Candidate::has_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Candidate::set_has_heading() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Candidate::clear_has_heading() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Candidate::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline ::google::protobuf::int32 Candidate::heading() const {
  return heading_;
}
inline void Candidate::set_heading(::google::protobuf::int32 value) {
  set_has_heading();
  heading_ = value;
}

// optional int32 speed_in_mps = 4;
inline bool Candidate::has_speed_in_mps() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Candidate::set_has_speed_in_mps() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Candidate::clear_has_speed_in_mps() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Candidate::clear_speed_in_mps() {
  speed_in_mps_ = 0;
  clear_has_speed_in_mps();
}
inline ::google::protobuf::int32 Candidate::speed_in_mps() const {
  return speed_in_mps_;
}
inline void Candidate::set_speed_in_mps(::google::protobuf::int32 value) {
  set_has_speed_in_mps();
  speed_in_mps_ = value;
}

// -------------------------------------------------------------------

// BasicRoute

// repeated .com.telenav.proto.map.BasicPath head_path = 2;
inline int BasicRoute::head_path_size() const {
  return head_path_.size();
}
inline void BasicRoute::clear_head_path() {
  head_path_.Clear();
}
inline const ::com::telenav::proto::map::BasicPath& BasicRoute::head_path(int index) const {
  return head_path_.Get(index);
}
inline ::com::telenav::proto::map::BasicPath* BasicRoute::mutable_head_path(int index) {
  return head_path_.Mutable(index);
}
inline ::com::telenav::proto::map::BasicPath* BasicRoute::add_head_path() {
  return head_path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicPath >&
BasicRoute::head_path() const {
  return head_path_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::BasicPath >*
BasicRoute::mutable_head_path() {
  return &head_path_;
}

// optional .com.telenav.proto.map.BasicPath body_path = 3;
inline bool BasicRoute::has_body_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasicRoute::set_has_body_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasicRoute::clear_has_body_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasicRoute::clear_body_path() {
  if (body_path_ != NULL) body_path_->::com::telenav::proto::map::BasicPath::Clear();
  clear_has_body_path();
}
inline const ::com::telenav::proto::map::BasicPath& BasicRoute::body_path() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return body_path_ != NULL ? *body_path_ : *default_instance().body_path_;
#else
  return body_path_ != NULL ? *body_path_ : *default_instance_->body_path_;
#endif
}
inline ::com::telenav::proto::map::BasicPath* BasicRoute::mutable_body_path() {
  set_has_body_path();
  if (body_path_ == NULL) body_path_ = new ::com::telenav::proto::map::BasicPath;
  return body_path_;
}
inline ::com::telenav::proto::map::BasicPath* BasicRoute::release_body_path() {
  clear_has_body_path();
  ::com::telenav::proto::map::BasicPath* temp = body_path_;
  body_path_ = NULL;
  return temp;
}
inline void BasicRoute::set_allocated_body_path(::com::telenav::proto::map::BasicPath* body_path) {
  delete body_path_;
  body_path_ = body_path;
  if (body_path) {
    set_has_body_path();
  } else {
    clear_has_body_path();
  }
}

// -------------------------------------------------------------------

// BasicPath

// repeated int64 edge_id = 2;
inline int BasicPath::edge_id_size() const {
  return edge_id_.size();
}
inline void BasicPath::clear_edge_id() {
  edge_id_.Clear();
}
inline ::google::protobuf::int64 BasicPath::edge_id(int index) const {
  return edge_id_.Get(index);
}
inline void BasicPath::set_edge_id(int index, ::google::protobuf::int64 value) {
  edge_id_.Set(index, value);
}
inline void BasicPath::add_edge_id(::google::protobuf::int64 value) {
  edge_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
BasicPath::edge_id() const {
  return edge_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
BasicPath::mutable_edge_id() {
  return &edge_id_;
}

// optional string first_edge_start_points = 4;
inline bool BasicPath::has_first_edge_start_points() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasicPath::set_has_first_edge_start_points() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasicPath::clear_has_first_edge_start_points() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasicPath::clear_first_edge_start_points() {
  if (first_edge_start_points_ != &::google::protobuf::internal::kEmptyString) {
    first_edge_start_points_->clear();
  }
  clear_has_first_edge_start_points();
}
inline const ::std::string& BasicPath::first_edge_start_points() const {
  return *first_edge_start_points_;
}
inline void BasicPath::set_first_edge_start_points(const ::std::string& value) {
  set_has_first_edge_start_points();
  if (first_edge_start_points_ == &::google::protobuf::internal::kEmptyString) {
    first_edge_start_points_ = new ::std::string;
  }
  first_edge_start_points_->assign(value);
}
inline void BasicPath::set_first_edge_start_points(const char* value) {
  set_has_first_edge_start_points();
  if (first_edge_start_points_ == &::google::protobuf::internal::kEmptyString) {
    first_edge_start_points_ = new ::std::string;
  }
  first_edge_start_points_->assign(value);
}
inline void BasicPath::set_first_edge_start_points(const char* value, size_t size) {
  set_has_first_edge_start_points();
  if (first_edge_start_points_ == &::google::protobuf::internal::kEmptyString) {
    first_edge_start_points_ = new ::std::string;
  }
  first_edge_start_points_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicPath::mutable_first_edge_start_points() {
  set_has_first_edge_start_points();
  if (first_edge_start_points_ == &::google::protobuf::internal::kEmptyString) {
    first_edge_start_points_ = new ::std::string;
  }
  return first_edge_start_points_;
}
inline ::std::string* BasicPath::release_first_edge_start_points() {
  clear_has_first_edge_start_points();
  if (first_edge_start_points_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = first_edge_start_points_;
    first_edge_start_points_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicPath::set_allocated_first_edge_start_points(::std::string* first_edge_start_points) {
  if (first_edge_start_points_ != &::google::protobuf::internal::kEmptyString) {
    delete first_edge_start_points_;
  }
  if (first_edge_start_points) {
    set_has_first_edge_start_points();
    first_edge_start_points_ = first_edge_start_points;
  } else {
    clear_has_first_edge_start_points();
    first_edge_start_points_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string last_edge_end_points = 5;
inline bool BasicPath::has_last_edge_end_points() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BasicPath::set_has_last_edge_end_points() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BasicPath::clear_has_last_edge_end_points() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BasicPath::clear_last_edge_end_points() {
  if (last_edge_end_points_ != &::google::protobuf::internal::kEmptyString) {
    last_edge_end_points_->clear();
  }
  clear_has_last_edge_end_points();
}
inline const ::std::string& BasicPath::last_edge_end_points() const {
  return *last_edge_end_points_;
}
inline void BasicPath::set_last_edge_end_points(const ::std::string& value) {
  set_has_last_edge_end_points();
  if (last_edge_end_points_ == &::google::protobuf::internal::kEmptyString) {
    last_edge_end_points_ = new ::std::string;
  }
  last_edge_end_points_->assign(value);
}
inline void BasicPath::set_last_edge_end_points(const char* value) {
  set_has_last_edge_end_points();
  if (last_edge_end_points_ == &::google::protobuf::internal::kEmptyString) {
    last_edge_end_points_ = new ::std::string;
  }
  last_edge_end_points_->assign(value);
}
inline void BasicPath::set_last_edge_end_points(const char* value, size_t size) {
  set_has_last_edge_end_points();
  if (last_edge_end_points_ == &::google::protobuf::internal::kEmptyString) {
    last_edge_end_points_ = new ::std::string;
  }
  last_edge_end_points_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicPath::mutable_last_edge_end_points() {
  set_has_last_edge_end_points();
  if (last_edge_end_points_ == &::google::protobuf::internal::kEmptyString) {
    last_edge_end_points_ = new ::std::string;
  }
  return last_edge_end_points_;
}
inline ::std::string* BasicPath::release_last_edge_end_points() {
  clear_has_last_edge_end_points();
  if (last_edge_end_points_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_edge_end_points_;
    last_edge_end_points_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicPath::set_allocated_last_edge_end_points(::std::string* last_edge_end_points) {
  if (last_edge_end_points_ != &::google::protobuf::internal::kEmptyString) {
    delete last_edge_end_points_;
  }
  if (last_edge_end_points) {
    set_has_last_edge_end_points();
    last_edge_end_points_ = last_edge_end_points;
  } else {
    clear_has_last_edge_end_points();
    last_edge_end_points_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Route

// optional .com.telenav.proto.map.RouteInfo route_info = 2;
inline bool Route::has_route_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Route::set_has_route_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Route::clear_has_route_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Route::clear_route_info() {
  if (route_info_ != NULL) route_info_->::com::telenav::proto::map::RouteInfo::Clear();
  clear_has_route_info();
}
inline const ::com::telenav::proto::map::RouteInfo& Route::route_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return route_info_ != NULL ? *route_info_ : *default_instance().route_info_;
#else
  return route_info_ != NULL ? *route_info_ : *default_instance_->route_info_;
#endif
}
inline ::com::telenav::proto::map::RouteInfo* Route::mutable_route_info() {
  set_has_route_info();
  if (route_info_ == NULL) route_info_ = new ::com::telenav::proto::map::RouteInfo;
  return route_info_;
}
inline ::com::telenav::proto::map::RouteInfo* Route::release_route_info() {
  clear_has_route_info();
  ::com::telenav::proto::map::RouteInfo* temp = route_info_;
  route_info_ = NULL;
  return temp;
}
inline void Route::set_allocated_route_info(::com::telenav::proto::map::RouteInfo* route_info) {
  delete route_info_;
  route_info_ = route_info;
  if (route_info) {
    set_has_route_info();
  } else {
    clear_has_route_info();
  }
}

// repeated .com.telenav.proto.map.Path path = 3;
inline int Route::path_size() const {
  return path_.size();
}
inline void Route::clear_path() {
  path_.Clear();
}
inline const ::com::telenav::proto::map::Path& Route::path(int index) const {
  return path_.Get(index);
}
inline ::com::telenav::proto::map::Path* Route::mutable_path(int index) {
  return path_.Mutable(index);
}
inline ::com::telenav::proto::map::Path* Route::add_path() {
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Path >&
Route::path() const {
  return path_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Path >*
Route::mutable_path() {
  return &path_;
}

// repeated .com.telenav.proto.map.GuidanceSegment segment = 4;
inline int Route::segment_size() const {
  return segment_.size();
}
inline void Route::clear_segment() {
  segment_.Clear();
}
inline const ::com::telenav::proto::map::GuidanceSegment& Route::segment(int index) const {
  return segment_.Get(index);
}
inline ::com::telenav::proto::map::GuidanceSegment* Route::mutable_segment(int index) {
  return segment_.Mutable(index);
}
inline ::com::telenav::proto::map::GuidanceSegment* Route::add_segment() {
  return segment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::GuidanceSegment >&
Route::segment() const {
  return segment_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::GuidanceSegment >*
Route::mutable_segment() {
  return &segment_;
}

// optional bool partial = 5 [default = false];
inline bool Route::has_partial() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Route::set_has_partial() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Route::clear_has_partial() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Route::clear_partial() {
  partial_ = false;
  clear_has_partial();
}
inline bool Route::partial() const {
  return partial_;
}
inline void Route::set_partial(bool value) {
  set_has_partial();
  partial_ = value;
}

// -------------------------------------------------------------------

// RouteInfo

// optional string overview = 1;
inline bool RouteInfo::has_overview() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteInfo::set_has_overview() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteInfo::clear_has_overview() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouteInfo::clear_overview() {
  if (overview_ != &::google::protobuf::internal::kEmptyString) {
    overview_->clear();
  }
  clear_has_overview();
}
inline const ::std::string& RouteInfo::overview() const {
  return *overview_;
}
inline void RouteInfo::set_overview(const ::std::string& value) {
  set_has_overview();
  if (overview_ == &::google::protobuf::internal::kEmptyString) {
    overview_ = new ::std::string;
  }
  overview_->assign(value);
}
inline void RouteInfo::set_overview(const char* value) {
  set_has_overview();
  if (overview_ == &::google::protobuf::internal::kEmptyString) {
    overview_ = new ::std::string;
  }
  overview_->assign(value);
}
inline void RouteInfo::set_overview(const char* value, size_t size) {
  set_has_overview();
  if (overview_ == &::google::protobuf::internal::kEmptyString) {
    overview_ = new ::std::string;
  }
  overview_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteInfo::mutable_overview() {
  set_has_overview();
  if (overview_ == &::google::protobuf::internal::kEmptyString) {
    overview_ = new ::std::string;
  }
  return overview_;
}
inline ::std::string* RouteInfo::release_overview() {
  clear_has_overview();
  if (overview_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = overview_;
    overview_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouteInfo::set_allocated_overview(::std::string* overview) {
  if (overview_ != &::google::protobuf::internal::kEmptyString) {
    delete overview_;
  }
  if (overview) {
    set_has_overview();
    overview_ = overview;
  } else {
    clear_has_overview();
    overview_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string summary = 2;
inline bool RouteInfo::has_summary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RouteInfo::set_has_summary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RouteInfo::clear_has_summary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RouteInfo::clear_summary() {
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    summary_->clear();
  }
  clear_has_summary();
}
inline const ::std::string& RouteInfo::summary() const {
  return *summary_;
}
inline void RouteInfo::set_summary(const ::std::string& value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
}
inline void RouteInfo::set_summary(const char* value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
}
inline void RouteInfo::set_summary(const char* value, size_t size) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteInfo::mutable_summary() {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  return summary_;
}
inline ::std::string* RouteInfo::release_summary() {
  clear_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = summary_;
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouteInfo::set_allocated_summary(::std::string* summary) {
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    delete summary_;
  }
  if (summary) {
    set_has_summary();
    summary_ = summary;
  } else {
    clear_has_summary();
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 travel_time_in_second = 3;
inline bool RouteInfo::has_travel_time_in_second() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RouteInfo::set_has_travel_time_in_second() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RouteInfo::clear_has_travel_time_in_second() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RouteInfo::clear_travel_time_in_second() {
  travel_time_in_second_ = 0;
  clear_has_travel_time_in_second();
}
inline ::google::protobuf::int32 RouteInfo::travel_time_in_second() const {
  return travel_time_in_second_;
}
inline void RouteInfo::set_travel_time_in_second(::google::protobuf::int32 value) {
  set_has_travel_time_in_second();
  travel_time_in_second_ = value;
}

// optional int32 travel_dist_in_meter = 4;
inline bool RouteInfo::has_travel_dist_in_meter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RouteInfo::set_has_travel_dist_in_meter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RouteInfo::clear_has_travel_dist_in_meter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RouteInfo::clear_travel_dist_in_meter() {
  travel_dist_in_meter_ = 0;
  clear_has_travel_dist_in_meter();
}
inline ::google::protobuf::int32 RouteInfo::travel_dist_in_meter() const {
  return travel_dist_in_meter_;
}
inline void RouteInfo::set_travel_dist_in_meter(::google::protobuf::int32 value) {
  set_has_travel_dist_in_meter();
  travel_dist_in_meter_ = value;
}

// optional int32 traffic_delay_in_second = 5;
inline bool RouteInfo::has_traffic_delay_in_second() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RouteInfo::set_has_traffic_delay_in_second() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RouteInfo::clear_has_traffic_delay_in_second() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RouteInfo::clear_traffic_delay_in_second() {
  traffic_delay_in_second_ = 0;
  clear_has_traffic_delay_in_second();
}
inline ::google::protobuf::int32 RouteInfo::traffic_delay_in_second() const {
  return traffic_delay_in_second_;
}
inline void RouteInfo::set_traffic_delay_in_second(::google::protobuf::int32 value) {
  set_has_traffic_delay_in_second();
  traffic_delay_in_second_ = value;
}

// optional bool estimate_only = 8;
inline bool RouteInfo::has_estimate_only() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RouteInfo::set_has_estimate_only() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RouteInfo::clear_has_estimate_only() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RouteInfo::clear_estimate_only() {
  estimate_only_ = false;
  clear_has_estimate_only();
}
inline bool RouteInfo::estimate_only() const {
  return estimate_only_;
}
inline void RouteInfo::set_estimate_only(bool value) {
  set_has_estimate_only();
  estimate_only_ = value;
}

// repeated .com.telenav.proto.map.Warning warning = 9;
inline int RouteInfo::warning_size() const {
  return warning_.size();
}
inline void RouteInfo::clear_warning() {
  warning_.Clear();
}
inline ::com::telenav::proto::map::Warning RouteInfo::warning(int index) const {
  return static_cast< ::com::telenav::proto::map::Warning >(warning_.Get(index));
}
inline void RouteInfo::set_warning(int index, ::com::telenav::proto::map::Warning value) {
  assert(::com::telenav::proto::map::Warning_IsValid(value));
  warning_.Set(index, value);
}
inline void RouteInfo::add_warning(::com::telenav::proto::map::Warning value) {
  assert(::com::telenav::proto::map::Warning_IsValid(value));
  warning_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
RouteInfo::warning() const {
  return warning_;
}
inline ::google::protobuf::RepeatedField<int>*
RouteInfo::mutable_warning() {
  return &warning_;
}

// -------------------------------------------------------------------

// Path

// repeated int32 segment_index = 1;
inline int Path::segment_index_size() const {
  return segment_index_.size();
}
inline void Path::clear_segment_index() {
  segment_index_.Clear();
}
inline ::google::protobuf::int32 Path::segment_index(int index) const {
  return segment_index_.Get(index);
}
inline void Path::set_segment_index(int index, ::google::protobuf::int32 value) {
  segment_index_.Set(index, value);
}
inline void Path::add_segment_index(::google::protobuf::int32 value) {
  segment_index_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Path::segment_index() const {
  return segment_index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Path::mutable_segment_index() {
  return &segment_index_;
}

// -------------------------------------------------------------------

// GuidanceSegment

// optional .com.telenav.proto.map.TurnType turn_type = 1;
inline bool GuidanceSegment::has_turn_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuidanceSegment::set_has_turn_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuidanceSegment::clear_has_turn_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuidanceSegment::clear_turn_type() {
  turn_type_ = 0;
  clear_has_turn_type();
}
inline ::com::telenav::proto::map::TurnType GuidanceSegment::turn_type() const {
  return static_cast< ::com::telenav::proto::map::TurnType >(turn_type_);
}
inline void GuidanceSegment::set_turn_type(::com::telenav::proto::map::TurnType value) {
  assert(::com::telenav::proto::map::TurnType_IsValid(value));
  set_has_turn_type();
  turn_type_ = value;
}

// optional bool is_tight_turn = 2 [default = false];
inline bool GuidanceSegment::has_is_tight_turn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuidanceSegment::set_has_is_tight_turn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuidanceSegment::clear_has_is_tight_turn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuidanceSegment::clear_is_tight_turn() {
  is_tight_turn_ = false;
  clear_has_is_tight_turn();
}
inline bool GuidanceSegment::is_tight_turn() const {
  return is_tight_turn_;
}
inline void GuidanceSegment::set_is_tight_turn(bool value) {
  set_has_is_tight_turn();
  is_tight_turn_ = value;
}

// optional .com.telenav.proto.map.RoadName road_name = 3;
inline bool GuidanceSegment::has_road_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuidanceSegment::set_has_road_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuidanceSegment::clear_has_road_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuidanceSegment::clear_road_name() {
  if (road_name_ != NULL) road_name_->::com::telenav::proto::map::RoadName::Clear();
  clear_has_road_name();
}
inline const ::com::telenav::proto::map::RoadName& GuidanceSegment::road_name() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return road_name_ != NULL ? *road_name_ : *default_instance().road_name_;
#else
  return road_name_ != NULL ? *road_name_ : *default_instance_->road_name_;
#endif
}
inline ::com::telenav::proto::map::RoadName* GuidanceSegment::mutable_road_name() {
  set_has_road_name();
  if (road_name_ == NULL) road_name_ = new ::com::telenav::proto::map::RoadName;
  return road_name_;
}
inline ::com::telenav::proto::map::RoadName* GuidanceSegment::release_road_name() {
  clear_has_road_name();
  ::com::telenav::proto::map::RoadName* temp = road_name_;
  road_name_ = NULL;
  return temp;
}
inline void GuidanceSegment::set_allocated_road_name(::com::telenav::proto::map::RoadName* road_name) {
  delete road_name_;
  road_name_ = road_name;
  if (road_name) {
    set_has_road_name();
  } else {
    clear_has_road_name();
  }
}

// optional .com.telenav.proto.map.SignPost sign_post = 4;
inline bool GuidanceSegment::has_sign_post() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuidanceSegment::set_has_sign_post() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuidanceSegment::clear_has_sign_post() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuidanceSegment::clear_sign_post() {
  if (sign_post_ != NULL) sign_post_->::com::telenav::proto::map::SignPost::Clear();
  clear_has_sign_post();
}
inline const ::com::telenav::proto::map::SignPost& GuidanceSegment::sign_post() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_post_ != NULL ? *sign_post_ : *default_instance().sign_post_;
#else
  return sign_post_ != NULL ? *sign_post_ : *default_instance_->sign_post_;
#endif
}
inline ::com::telenav::proto::map::SignPost* GuidanceSegment::mutable_sign_post() {
  set_has_sign_post();
  if (sign_post_ == NULL) sign_post_ = new ::com::telenav::proto::map::SignPost;
  return sign_post_;
}
inline ::com::telenav::proto::map::SignPost* GuidanceSegment::release_sign_post() {
  clear_has_sign_post();
  ::com::telenav::proto::map::SignPost* temp = sign_post_;
  sign_post_ = NULL;
  return temp;
}
inline void GuidanceSegment::set_allocated_sign_post(::com::telenav::proto::map::SignPost* sign_post) {
  delete sign_post_;
  sign_post_ = sign_post;
  if (sign_post) {
    set_has_sign_post();
  } else {
    clear_has_sign_post();
  }
}

// optional .com.telenav.proto.map.SignBoard sign_board = 5;
inline bool GuidanceSegment::has_sign_board() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuidanceSegment::set_has_sign_board() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuidanceSegment::clear_has_sign_board() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuidanceSegment::clear_sign_board() {
  if (sign_board_ != NULL) sign_board_->::com::telenav::proto::map::SignBoard::Clear();
  clear_has_sign_board();
}
inline const ::com::telenav::proto::map::SignBoard& GuidanceSegment::sign_board() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_board_ != NULL ? *sign_board_ : *default_instance().sign_board_;
#else
  return sign_board_ != NULL ? *sign_board_ : *default_instance_->sign_board_;
#endif
}
inline ::com::telenav::proto::map::SignBoard* GuidanceSegment::mutable_sign_board() {
  set_has_sign_board();
  if (sign_board_ == NULL) sign_board_ = new ::com::telenav::proto::map::SignBoard;
  return sign_board_;
}
inline ::com::telenav::proto::map::SignBoard* GuidanceSegment::release_sign_board() {
  clear_has_sign_board();
  ::com::telenav::proto::map::SignBoard* temp = sign_board_;
  sign_board_ = NULL;
  return temp;
}
inline void GuidanceSegment::set_allocated_sign_board(::com::telenav::proto::map::SignBoard* sign_board) {
  delete sign_board_;
  sign_board_ = sign_board;
  if (sign_board) {
    set_has_sign_board();
  } else {
    clear_has_sign_board();
  }
}

// optional int32 nth_turn = 6;
inline bool GuidanceSegment::has_nth_turn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuidanceSegment::set_has_nth_turn() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuidanceSegment::clear_has_nth_turn() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuidanceSegment::clear_nth_turn() {
  nth_turn_ = 0;
  clear_has_nth_turn();
}
inline ::google::protobuf::int32 GuidanceSegment::nth_turn() const {
  return nth_turn_;
}
inline void GuidanceSegment::set_nth_turn(::google::protobuf::int32 value) {
  set_has_nth_turn();
  nth_turn_ = value;
}

// optional string language = 9;
inline bool GuidanceSegment::has_language() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GuidanceSegment::set_has_language() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GuidanceSegment::clear_has_language() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GuidanceSegment::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& GuidanceSegment::language() const {
  return *language_;
}
inline void GuidanceSegment::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void GuidanceSegment::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void GuidanceSegment::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GuidanceSegment::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* GuidanceSegment::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GuidanceSegment::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.telenav.proto.map.RoadType road_type = 10;
inline bool GuidanceSegment::has_road_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GuidanceSegment::set_has_road_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GuidanceSegment::clear_has_road_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GuidanceSegment::clear_road_type() {
  road_type_ = 0;
  clear_has_road_type();
}
inline ::com::telenav::proto::map::RoadType GuidanceSegment::road_type() const {
  return static_cast< ::com::telenav::proto::map::RoadType >(road_type_);
}
inline void GuidanceSegment::set_road_type(::com::telenav::proto::map::RoadType value) {
  assert(::com::telenav::proto::map::RoadType_IsValid(value));
  set_has_road_type();
  road_type_ = value;
}

// optional bool is_left_side_drive = 12;
inline bool GuidanceSegment::has_is_left_side_drive() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GuidanceSegment::set_has_is_left_side_drive() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GuidanceSegment::clear_has_is_left_side_drive() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GuidanceSegment::clear_is_left_side_drive() {
  is_left_side_drive_ = false;
  clear_has_is_left_side_drive();
}
inline bool GuidanceSegment::is_left_side_drive() const {
  return is_left_side_drive_;
}
inline void GuidanceSegment::set_is_left_side_drive(bool value) {
  set_has_is_left_side_drive();
  is_left_side_drive_ = value;
}

// repeated .com.telenav.proto.map.LaneInfo lane_info = 13;
inline int GuidanceSegment::lane_info_size() const {
  return lane_info_.size();
}
inline void GuidanceSegment::clear_lane_info() {
  lane_info_.Clear();
}
inline const ::com::telenav::proto::map::LaneInfo& GuidanceSegment::lane_info(int index) const {
  return lane_info_.Get(index);
}
inline ::com::telenav::proto::map::LaneInfo* GuidanceSegment::mutable_lane_info(int index) {
  return lane_info_.Mutable(index);
}
inline ::com::telenav::proto::map::LaneInfo* GuidanceSegment::add_lane_info() {
  return lane_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::LaneInfo >&
GuidanceSegment::lane_info() const {
  return lane_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::LaneInfo >*
GuidanceSegment::mutable_lane_info() {
  return &lane_info_;
}

// optional double length_in_meter = 14;
inline bool GuidanceSegment::has_length_in_meter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GuidanceSegment::set_has_length_in_meter() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GuidanceSegment::clear_has_length_in_meter() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GuidanceSegment::clear_length_in_meter() {
  length_in_meter_ = 0;
  clear_has_length_in_meter();
}
inline double GuidanceSegment::length_in_meter() const {
  return length_in_meter_;
}
inline void GuidanceSegment::set_length_in_meter(double value) {
  set_has_length_in_meter();
  length_in_meter_ = value;
}

// repeated .com.telenav.proto.map.JunctionView junction_view = 15;
inline int GuidanceSegment::junction_view_size() const {
  return junction_view_.size();
}
inline void GuidanceSegment::clear_junction_view() {
  junction_view_.Clear();
}
inline const ::com::telenav::proto::map::JunctionView& GuidanceSegment::junction_view(int index) const {
  return junction_view_.Get(index);
}
inline ::com::telenav::proto::map::JunctionView* GuidanceSegment::mutable_junction_view(int index) {
  return junction_view_.Mutable(index);
}
inline ::com::telenav::proto::map::JunctionView* GuidanceSegment::add_junction_view() {
  return junction_view_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::JunctionView >&
GuidanceSegment::junction_view() const {
  return junction_view_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::JunctionView >*
GuidanceSegment::mutable_junction_view() {
  return &junction_view_;
}

// repeated .com.telenav.proto.map.Warning warning = 19;
inline int GuidanceSegment::warning_size() const {
  return warning_.size();
}
inline void GuidanceSegment::clear_warning() {
  warning_.Clear();
}
inline ::com::telenav::proto::map::Warning GuidanceSegment::warning(int index) const {
  return static_cast< ::com::telenav::proto::map::Warning >(warning_.Get(index));
}
inline void GuidanceSegment::set_warning(int index, ::com::telenav::proto::map::Warning value) {
  assert(::com::telenav::proto::map::Warning_IsValid(value));
  warning_.Set(index, value);
}
inline void GuidanceSegment::add_warning(::com::telenav::proto::map::Warning value) {
  assert(::com::telenav::proto::map::Warning_IsValid(value));
  warning_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
GuidanceSegment::warning() const {
  return warning_;
}
inline ::google::protobuf::RepeatedField<int>*
GuidanceSegment::mutable_warning() {
  return &warning_;
}

// repeated .com.telenav.proto.map.Edge edge = 18;
inline int GuidanceSegment::edge_size() const {
  return edge_.size();
}
inline void GuidanceSegment::clear_edge() {
  edge_.Clear();
}
inline const ::com::telenav::proto::map::Edge& GuidanceSegment::edge(int index) const {
  return edge_.Get(index);
}
inline ::com::telenav::proto::map::Edge* GuidanceSegment::mutable_edge(int index) {
  return edge_.Mutable(index);
}
inline ::com::telenav::proto::map::Edge* GuidanceSegment::add_edge() {
  return edge_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Edge >&
GuidanceSegment::edge() const {
  return edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::telenav::proto::map::Edge >*
GuidanceSegment::mutable_edge() {
  return &edge_;
}

// -------------------------------------------------------------------

// RoadName

// repeated string official_name = 1;
inline int RoadName::official_name_size() const {
  return official_name_.size();
}
inline void RoadName::clear_official_name() {
  official_name_.Clear();
}
inline const ::std::string& RoadName::official_name(int index) const {
  return official_name_.Get(index);
}
inline ::std::string* RoadName::mutable_official_name(int index) {
  return official_name_.Mutable(index);
}
inline void RoadName::set_official_name(int index, const ::std::string& value) {
  official_name_.Mutable(index)->assign(value);
}
inline void RoadName::set_official_name(int index, const char* value) {
  official_name_.Mutable(index)->assign(value);
}
inline void RoadName::set_official_name(int index, const char* value, size_t size) {
  official_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoadName::add_official_name() {
  return official_name_.Add();
}
inline void RoadName::add_official_name(const ::std::string& value) {
  official_name_.Add()->assign(value);
}
inline void RoadName::add_official_name(const char* value) {
  official_name_.Add()->assign(value);
}
inline void RoadName::add_official_name(const char* value, size_t size) {
  official_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoadName::official_name() const {
  return official_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoadName::mutable_official_name() {
  return &official_name_;
}

// repeated string alternate_name = 2;
inline int RoadName::alternate_name_size() const {
  return alternate_name_.size();
}
inline void RoadName::clear_alternate_name() {
  alternate_name_.Clear();
}
inline const ::std::string& RoadName::alternate_name(int index) const {
  return alternate_name_.Get(index);
}
inline ::std::string* RoadName::mutable_alternate_name(int index) {
  return alternate_name_.Mutable(index);
}
inline void RoadName::set_alternate_name(int index, const ::std::string& value) {
  alternate_name_.Mutable(index)->assign(value);
}
inline void RoadName::set_alternate_name(int index, const char* value) {
  alternate_name_.Mutable(index)->assign(value);
}
inline void RoadName::set_alternate_name(int index, const char* value, size_t size) {
  alternate_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoadName::add_alternate_name() {
  return alternate_name_.Add();
}
inline void RoadName::add_alternate_name(const ::std::string& value) {
  alternate_name_.Add()->assign(value);
}
inline void RoadName::add_alternate_name(const char* value) {
  alternate_name_.Add()->assign(value);
}
inline void RoadName::add_alternate_name(const char* value, size_t size) {
  alternate_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoadName::alternate_name() const {
  return alternate_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoadName::mutable_alternate_name() {
  return &alternate_name_;
}

// repeated string route_number = 3;
inline int RoadName::route_number_size() const {
  return route_number_.size();
}
inline void RoadName::clear_route_number() {
  route_number_.Clear();
}
inline const ::std::string& RoadName::route_number(int index) const {
  return route_number_.Get(index);
}
inline ::std::string* RoadName::mutable_route_number(int index) {
  return route_number_.Mutable(index);
}
inline void RoadName::set_route_number(int index, const ::std::string& value) {
  route_number_.Mutable(index)->assign(value);
}
inline void RoadName::set_route_number(int index, const char* value) {
  route_number_.Mutable(index)->assign(value);
}
inline void RoadName::set_route_number(int index, const char* value, size_t size) {
  route_number_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoadName::add_route_number() {
  return route_number_.Add();
}
inline void RoadName::add_route_number(const ::std::string& value) {
  route_number_.Add()->assign(value);
}
inline void RoadName::add_route_number(const char* value) {
  route_number_.Add()->assign(value);
}
inline void RoadName::add_route_number(const char* value, size_t size) {
  route_number_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoadName::route_number() const {
  return route_number_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoadName::mutable_route_number() {
  return &route_number_;
}

// -------------------------------------------------------------------

// SignPost

// repeated string road_name = 1;
inline int SignPost::road_name_size() const {
  return road_name_.size();
}
inline void SignPost::clear_road_name() {
  road_name_.Clear();
}
inline const ::std::string& SignPost::road_name(int index) const {
  return road_name_.Get(index);
}
inline ::std::string* SignPost::mutable_road_name(int index) {
  return road_name_.Mutable(index);
}
inline void SignPost::set_road_name(int index, const ::std::string& value) {
  road_name_.Mutable(index)->assign(value);
}
inline void SignPost::set_road_name(int index, const char* value) {
  road_name_.Mutable(index)->assign(value);
}
inline void SignPost::set_road_name(int index, const char* value, size_t size) {
  road_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignPost::add_road_name() {
  return road_name_.Add();
}
inline void SignPost::add_road_name(const ::std::string& value) {
  road_name_.Add()->assign(value);
}
inline void SignPost::add_road_name(const char* value) {
  road_name_.Add()->assign(value);
}
inline void SignPost::add_road_name(const char* value, size_t size) {
  road_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SignPost::road_name() const {
  return road_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SignPost::mutable_road_name() {
  return &road_name_;
}

// optional string place_name = 2;
inline bool SignPost::has_place_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignPost::set_has_place_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignPost::clear_has_place_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignPost::clear_place_name() {
  if (place_name_ != &::google::protobuf::internal::kEmptyString) {
    place_name_->clear();
  }
  clear_has_place_name();
}
inline const ::std::string& SignPost::place_name() const {
  return *place_name_;
}
inline void SignPost::set_place_name(const ::std::string& value) {
  set_has_place_name();
  if (place_name_ == &::google::protobuf::internal::kEmptyString) {
    place_name_ = new ::std::string;
  }
  place_name_->assign(value);
}
inline void SignPost::set_place_name(const char* value) {
  set_has_place_name();
  if (place_name_ == &::google::protobuf::internal::kEmptyString) {
    place_name_ = new ::std::string;
  }
  place_name_->assign(value);
}
inline void SignPost::set_place_name(const char* value, size_t size) {
  set_has_place_name();
  if (place_name_ == &::google::protobuf::internal::kEmptyString) {
    place_name_ = new ::std::string;
  }
  place_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignPost::mutable_place_name() {
  set_has_place_name();
  if (place_name_ == &::google::protobuf::internal::kEmptyString) {
    place_name_ = new ::std::string;
  }
  return place_name_;
}
inline ::std::string* SignPost::release_place_name() {
  clear_has_place_name();
  if (place_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = place_name_;
    place_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignPost::set_allocated_place_name(::std::string* place_name) {
  if (place_name_ != &::google::protobuf::internal::kEmptyString) {
    delete place_name_;
  }
  if (place_name) {
    set_has_place_name();
    place_name_ = place_name;
  } else {
    clear_has_place_name();
    place_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string exit_label = 3;
inline bool SignPost::has_exit_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignPost::set_has_exit_label() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignPost::clear_has_exit_label() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignPost::clear_exit_label() {
  if (exit_label_ != &::google::protobuf::internal::kEmptyString) {
    exit_label_->clear();
  }
  clear_has_exit_label();
}
inline const ::std::string& SignPost::exit_label() const {
  return *exit_label_;
}
inline void SignPost::set_exit_label(const ::std::string& value) {
  set_has_exit_label();
  if (exit_label_ == &::google::protobuf::internal::kEmptyString) {
    exit_label_ = new ::std::string;
  }
  exit_label_->assign(value);
}
inline void SignPost::set_exit_label(const char* value) {
  set_has_exit_label();
  if (exit_label_ == &::google::protobuf::internal::kEmptyString) {
    exit_label_ = new ::std::string;
  }
  exit_label_->assign(value);
}
inline void SignPost::set_exit_label(const char* value, size_t size) {
  set_has_exit_label();
  if (exit_label_ == &::google::protobuf::internal::kEmptyString) {
    exit_label_ = new ::std::string;
  }
  exit_label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignPost::mutable_exit_label() {
  set_has_exit_label();
  if (exit_label_ == &::google::protobuf::internal::kEmptyString) {
    exit_label_ = new ::std::string;
  }
  return exit_label_;
}
inline ::std::string* SignPost::release_exit_label() {
  clear_has_exit_label();
  if (exit_label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exit_label_;
    exit_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignPost::set_allocated_exit_label(::std::string* exit_label) {
  if (exit_label_ != &::google::protobuf::internal::kEmptyString) {
    delete exit_label_;
  }
  if (exit_label) {
    set_has_exit_label();
    exit_label_ = exit_label;
  } else {
    clear_has_exit_label();
    exit_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string image_id = 4;
inline bool SignPost::has_image_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignPost::set_has_image_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignPost::clear_has_image_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignPost::clear_image_id() {
  if (image_id_ != &::google::protobuf::internal::kEmptyString) {
    image_id_->clear();
  }
  clear_has_image_id();
}
inline const ::std::string& SignPost::image_id() const {
  return *image_id_;
}
inline void SignPost::set_image_id(const ::std::string& value) {
  set_has_image_id();
  if (image_id_ == &::google::protobuf::internal::kEmptyString) {
    image_id_ = new ::std::string;
  }
  image_id_->assign(value);
}
inline void SignPost::set_image_id(const char* value) {
  set_has_image_id();
  if (image_id_ == &::google::protobuf::internal::kEmptyString) {
    image_id_ = new ::std::string;
  }
  image_id_->assign(value);
}
inline void SignPost::set_image_id(const char* value, size_t size) {
  set_has_image_id();
  if (image_id_ == &::google::protobuf::internal::kEmptyString) {
    image_id_ = new ::std::string;
  }
  image_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignPost::mutable_image_id() {
  set_has_image_id();
  if (image_id_ == &::google::protobuf::internal::kEmptyString) {
    image_id_ = new ::std::string;
  }
  return image_id_;
}
inline ::std::string* SignPost::release_image_id() {
  clear_has_image_id();
  if (image_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_id_;
    image_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignPost::set_allocated_image_id(::std::string* image_id) {
  if (image_id_ != &::google::protobuf::internal::kEmptyString) {
    delete image_id_;
  }
  if (image_id) {
    set_has_image_id();
    image_id_ = image_id;
  } else {
    clear_has_image_id();
    image_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignBoard

// optional .com.telenav.proto.map.SignBoardType type = 1;
inline bool SignBoard::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignBoard::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignBoard::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignBoard::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::com::telenav::proto::map::SignBoardType SignBoard::type() const {
  return static_cast< ::com::telenav::proto::map::SignBoardType >(type_);
}
inline void SignBoard::set_type(::com::telenav::proto::map::SignBoardType value) {
  assert(::com::telenav::proto::map::SignBoardType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string pattern_id = 2;
inline bool SignBoard::has_pattern_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignBoard::set_has_pattern_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignBoard::clear_has_pattern_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignBoard::clear_pattern_id() {
  if (pattern_id_ != &::google::protobuf::internal::kEmptyString) {
    pattern_id_->clear();
  }
  clear_has_pattern_id();
}
inline const ::std::string& SignBoard::pattern_id() const {
  return *pattern_id_;
}
inline void SignBoard::set_pattern_id(const ::std::string& value) {
  set_has_pattern_id();
  if (pattern_id_ == &::google::protobuf::internal::kEmptyString) {
    pattern_id_ = new ::std::string;
  }
  pattern_id_->assign(value);
}
inline void SignBoard::set_pattern_id(const char* value) {
  set_has_pattern_id();
  if (pattern_id_ == &::google::protobuf::internal::kEmptyString) {
    pattern_id_ = new ::std::string;
  }
  pattern_id_->assign(value);
}
inline void SignBoard::set_pattern_id(const char* value, size_t size) {
  set_has_pattern_id();
  if (pattern_id_ == &::google::protobuf::internal::kEmptyString) {
    pattern_id_ = new ::std::string;
  }
  pattern_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignBoard::mutable_pattern_id() {
  set_has_pattern_id();
  if (pattern_id_ == &::google::protobuf::internal::kEmptyString) {
    pattern_id_ = new ::std::string;
  }
  return pattern_id_;
}
inline ::std::string* SignBoard::release_pattern_id() {
  clear_has_pattern_id();
  if (pattern_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pattern_id_;
    pattern_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignBoard::set_allocated_pattern_id(::std::string* pattern_id) {
  if (pattern_id_ != &::google::protobuf::internal::kEmptyString) {
    delete pattern_id_;
  }
  if (pattern_id) {
    set_has_pattern_id();
    pattern_id_ = pattern_id;
  } else {
    clear_has_pattern_id();
    pattern_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string arrow_id = 3;
inline bool SignBoard::has_arrow_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignBoard::set_has_arrow_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignBoard::clear_has_arrow_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignBoard::clear_arrow_id() {
  if (arrow_id_ != &::google::protobuf::internal::kEmptyString) {
    arrow_id_->clear();
  }
  clear_has_arrow_id();
}
inline const ::std::string& SignBoard::arrow_id() const {
  return *arrow_id_;
}
inline void SignBoard::set_arrow_id(const ::std::string& value) {
  set_has_arrow_id();
  if (arrow_id_ == &::google::protobuf::internal::kEmptyString) {
    arrow_id_ = new ::std::string;
  }
  arrow_id_->assign(value);
}
inline void SignBoard::set_arrow_id(const char* value) {
  set_has_arrow_id();
  if (arrow_id_ == &::google::protobuf::internal::kEmptyString) {
    arrow_id_ = new ::std::string;
  }
  arrow_id_->assign(value);
}
inline void SignBoard::set_arrow_id(const char* value, size_t size) {
  set_has_arrow_id();
  if (arrow_id_ == &::google::protobuf::internal::kEmptyString) {
    arrow_id_ = new ::std::string;
  }
  arrow_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignBoard::mutable_arrow_id() {
  set_has_arrow_id();
  if (arrow_id_ == &::google::protobuf::internal::kEmptyString) {
    arrow_id_ = new ::std::string;
  }
  return arrow_id_;
}
inline ::std::string* SignBoard::release_arrow_id() {
  clear_has_arrow_id();
  if (arrow_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arrow_id_;
    arrow_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignBoard::set_allocated_arrow_id(::std::string* arrow_id) {
  if (arrow_id_ != &::google::protobuf::internal::kEmptyString) {
    delete arrow_id_;
  }
  if (arrow_id) {
    set_has_arrow_id();
    arrow_id_ = arrow_id;
  } else {
    clear_has_arrow_id();
    arrow_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Edge

// optional double speed_limit_in_KPH = 2 [default = -1];
inline bool Edge::has_speed_limit_in_kph() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge::set_has_speed_limit_in_kph() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge::clear_has_speed_limit_in_kph() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge::clear_speed_limit_in_kph() {
  speed_limit_in_kph_ = -1;
  clear_has_speed_limit_in_kph();
}
inline double Edge::speed_limit_in_kph() const {
  return speed_limit_in_kph_;
}
inline void Edge::set_speed_limit_in_kph(double value) {
  set_has_speed_limit_in_kph();
  speed_limit_in_kph_ = value;
}

// optional double travel_speed_in_mps = 3 [default = -1];
inline bool Edge::has_travel_speed_in_mps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edge::set_has_travel_speed_in_mps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edge::clear_has_travel_speed_in_mps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edge::clear_travel_speed_in_mps() {
  travel_speed_in_mps_ = -1;
  clear_has_travel_speed_in_mps();
}
inline double Edge::travel_speed_in_mps() const {
  return travel_speed_in_mps_;
}
inline void Edge::set_travel_speed_in_mps(double value) {
  set_has_travel_speed_in_mps();
  travel_speed_in_mps_ = value;
}

// repeated int64 map_edge_id = 4;
inline int Edge::map_edge_id_size() const {
  return map_edge_id_.size();
}
inline void Edge::clear_map_edge_id() {
  map_edge_id_.Clear();
}
inline ::google::protobuf::int64 Edge::map_edge_id(int index) const {
  return map_edge_id_.Get(index);
}
inline void Edge::set_map_edge_id(int index, ::google::protobuf::int64 value) {
  map_edge_id_.Set(index, value);
}
inline void Edge::add_map_edge_id(::google::protobuf::int64 value) {
  map_edge_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Edge::map_edge_id() const {
  return map_edge_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Edge::mutable_map_edge_id() {
  return &map_edge_id_;
}

// optional int32 length_in_meter = 6;
inline bool Edge::has_length_in_meter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Edge::set_has_length_in_meter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Edge::clear_has_length_in_meter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Edge::clear_length_in_meter() {
  length_in_meter_ = 0;
  clear_has_length_in_meter();
}
inline ::google::protobuf::int32 Edge::length_in_meter() const {
  return length_in_meter_;
}
inline void Edge::set_length_in_meter(::google::protobuf::int32 value) {
  set_has_length_in_meter();
  length_in_meter_ = value;
}

// optional string encoded_polyline = 7;
inline bool Edge::has_encoded_polyline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Edge::set_has_encoded_polyline() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Edge::clear_has_encoded_polyline() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Edge::clear_encoded_polyline() {
  if (encoded_polyline_ != &::google::protobuf::internal::kEmptyString) {
    encoded_polyline_->clear();
  }
  clear_has_encoded_polyline();
}
inline const ::std::string& Edge::encoded_polyline() const {
  return *encoded_polyline_;
}
inline void Edge::set_encoded_polyline(const ::std::string& value) {
  set_has_encoded_polyline();
  if (encoded_polyline_ == &::google::protobuf::internal::kEmptyString) {
    encoded_polyline_ = new ::std::string;
  }
  encoded_polyline_->assign(value);
}
inline void Edge::set_encoded_polyline(const char* value) {
  set_has_encoded_polyline();
  if (encoded_polyline_ == &::google::protobuf::internal::kEmptyString) {
    encoded_polyline_ = new ::std::string;
  }
  encoded_polyline_->assign(value);
}
inline void Edge::set_encoded_polyline(const char* value, size_t size) {
  set_has_encoded_polyline();
  if (encoded_polyline_ == &::google::protobuf::internal::kEmptyString) {
    encoded_polyline_ = new ::std::string;
  }
  encoded_polyline_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Edge::mutable_encoded_polyline() {
  set_has_encoded_polyline();
  if (encoded_polyline_ == &::google::protobuf::internal::kEmptyString) {
    encoded_polyline_ = new ::std::string;
  }
  return encoded_polyline_;
}
inline ::std::string* Edge::release_encoded_polyline() {
  clear_has_encoded_polyline();
  if (encoded_polyline_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_polyline_;
    encoded_polyline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Edge::set_allocated_encoded_polyline(::std::string* encoded_polyline) {
  if (encoded_polyline_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_polyline_;
  }
  if (encoded_polyline) {
    set_has_encoded_polyline();
    encoded_polyline_ = encoded_polyline;
  } else {
    clear_has_encoded_polyline();
    encoded_polyline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string traffic_id = 8;
inline bool Edge::has_traffic_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Edge::set_has_traffic_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Edge::clear_has_traffic_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Edge::clear_traffic_id() {
  if (traffic_id_ != &::google::protobuf::internal::kEmptyString) {
    traffic_id_->clear();
  }
  clear_has_traffic_id();
}
inline const ::std::string& Edge::traffic_id() const {
  return *traffic_id_;
}
inline void Edge::set_traffic_id(const ::std::string& value) {
  set_has_traffic_id();
  if (traffic_id_ == &::google::protobuf::internal::kEmptyString) {
    traffic_id_ = new ::std::string;
  }
  traffic_id_->assign(value);
}
inline void Edge::set_traffic_id(const char* value) {
  set_has_traffic_id();
  if (traffic_id_ == &::google::protobuf::internal::kEmptyString) {
    traffic_id_ = new ::std::string;
  }
  traffic_id_->assign(value);
}
inline void Edge::set_traffic_id(const char* value, size_t size) {
  set_has_traffic_id();
  if (traffic_id_ == &::google::protobuf::internal::kEmptyString) {
    traffic_id_ = new ::std::string;
  }
  traffic_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Edge::mutable_traffic_id() {
  set_has_traffic_id();
  if (traffic_id_ == &::google::protobuf::internal::kEmptyString) {
    traffic_id_ = new ::std::string;
  }
  return traffic_id_;
}
inline ::std::string* Edge::release_traffic_id() {
  clear_has_traffic_id();
  if (traffic_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = traffic_id_;
    traffic_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Edge::set_allocated_traffic_id(::std::string* traffic_id) {
  if (traffic_id_ != &::google::protobuf::internal::kEmptyString) {
    delete traffic_id_;
  }
  if (traffic_id) {
    set_has_traffic_id();
    traffic_id_ = traffic_id;
  } else {
    clear_has_traffic_id();
    traffic_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.telenav.proto.map.TimeProfile time_profile = 9;
inline bool Edge::has_time_profile() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Edge::set_has_time_profile() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Edge::clear_has_time_profile() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Edge::clear_time_profile() {
  if (time_profile_ != NULL) time_profile_->::com::telenav::proto::map::TimeProfile::Clear();
  clear_has_time_profile();
}
inline const ::com::telenav::proto::map::TimeProfile& Edge::time_profile() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return time_profile_ != NULL ? *time_profile_ : *default_instance().time_profile_;
#else
  return time_profile_ != NULL ? *time_profile_ : *default_instance_->time_profile_;
#endif
}
inline ::com::telenav::proto::map::TimeProfile* Edge::mutable_time_profile() {
  set_has_time_profile();
  if (time_profile_ == NULL) time_profile_ = new ::com::telenav::proto::map::TimeProfile;
  return time_profile_;
}
inline ::com::telenav::proto::map::TimeProfile* Edge::release_time_profile() {
  clear_has_time_profile();
  ::com::telenav::proto::map::TimeProfile* temp = time_profile_;
  time_profile_ = NULL;
  return temp;
}
inline void Edge::set_allocated_time_profile(::com::telenav::proto::map::TimeProfile* time_profile) {
  delete time_profile_;
  time_profile_ = time_profile;
  if (time_profile) {
    set_has_time_profile();
  } else {
    clear_has_time_profile();
  }
}

// -------------------------------------------------------------------

// TimeProfile

// optional int32 turn_cost = 1;
inline bool TimeProfile::has_turn_cost() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeProfile::set_has_turn_cost() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeProfile::clear_has_turn_cost() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeProfile::clear_turn_cost() {
  turn_cost_ = 0;
  clear_has_turn_cost();
}
inline ::google::protobuf::int32 TimeProfile::turn_cost() const {
  return turn_cost_;
}
inline void TimeProfile::set_turn_cost(::google::protobuf::int32 value) {
  set_has_turn_cost();
  turn_cost_ = value;
}

// optional double real_time_speed = 2;
inline bool TimeProfile::has_real_time_speed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeProfile::set_has_real_time_speed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeProfile::clear_has_real_time_speed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeProfile::clear_real_time_speed() {
  real_time_speed_ = 0;
  clear_has_real_time_speed();
}
inline double TimeProfile::real_time_speed() const {
  return real_time_speed_;
}
inline void TimeProfile::set_real_time_speed(double value) {
  set_has_real_time_speed();
  real_time_speed_ = value;
}

// optional string historical_pattern = 3;
inline bool TimeProfile::has_historical_pattern() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeProfile::set_has_historical_pattern() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeProfile::clear_has_historical_pattern() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeProfile::clear_historical_pattern() {
  if (historical_pattern_ != &::google::protobuf::internal::kEmptyString) {
    historical_pattern_->clear();
  }
  clear_has_historical_pattern();
}
inline const ::std::string& TimeProfile::historical_pattern() const {
  return *historical_pattern_;
}
inline void TimeProfile::set_historical_pattern(const ::std::string& value) {
  set_has_historical_pattern();
  if (historical_pattern_ == &::google::protobuf::internal::kEmptyString) {
    historical_pattern_ = new ::std::string;
  }
  historical_pattern_->assign(value);
}
inline void TimeProfile::set_historical_pattern(const char* value) {
  set_has_historical_pattern();
  if (historical_pattern_ == &::google::protobuf::internal::kEmptyString) {
    historical_pattern_ = new ::std::string;
  }
  historical_pattern_->assign(value);
}
inline void TimeProfile::set_historical_pattern(const char* value, size_t size) {
  set_has_historical_pattern();
  if (historical_pattern_ == &::google::protobuf::internal::kEmptyString) {
    historical_pattern_ = new ::std::string;
  }
  historical_pattern_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeProfile::mutable_historical_pattern() {
  set_has_historical_pattern();
  if (historical_pattern_ == &::google::protobuf::internal::kEmptyString) {
    historical_pattern_ = new ::std::string;
  }
  return historical_pattern_;
}
inline ::std::string* TimeProfile::release_historical_pattern() {
  clear_has_historical_pattern();
  if (historical_pattern_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = historical_pattern_;
    historical_pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeProfile::set_allocated_historical_pattern(::std::string* historical_pattern) {
  if (historical_pattern_ != &::google::protobuf::internal::kEmptyString) {
    delete historical_pattern_;
  }
  if (historical_pattern) {
    set_has_historical_pattern();
    historical_pattern_ = historical_pattern;
  } else {
    clear_has_historical_pattern();
    historical_pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LaneInfo

// optional .com.telenav.proto.map.LanePattern pattern = 1;
inline bool LaneInfo::has_pattern() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneInfo::set_has_pattern() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneInfo::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneInfo::clear_pattern() {
  pattern_ = 1;
  clear_has_pattern();
}
inline ::com::telenav::proto::map::LanePattern LaneInfo::pattern() const {
  return static_cast< ::com::telenav::proto::map::LanePattern >(pattern_);
}
inline void LaneInfo::set_pattern(::com::telenav::proto::map::LanePattern value) {
  assert(::com::telenav::proto::map::LanePattern_IsValid(value));
  set_has_pattern();
  pattern_ = value;
}

// optional .com.telenav.proto.map.HighlightedLane highlight = 2;
inline bool LaneInfo::has_highlight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneInfo::set_has_highlight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneInfo::clear_has_highlight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneInfo::clear_highlight() {
  highlight_ = 1;
  clear_has_highlight();
}
inline ::com::telenav::proto::map::HighlightedLane LaneInfo::highlight() const {
  return static_cast< ::com::telenav::proto::map::HighlightedLane >(highlight_);
}
inline void LaneInfo::set_highlight(::com::telenav::proto::map::HighlightedLane value) {
  assert(::com::telenav::proto::map::HighlightedLane_IsValid(value));
  set_has_highlight();
  highlight_ = value;
}

// optional bool preferred = 3 [default = false];
inline bool LaneInfo::has_preferred() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneInfo::set_has_preferred() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneInfo::clear_has_preferred() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneInfo::clear_preferred() {
  preferred_ = false;
  clear_has_preferred();
}
inline bool LaneInfo::preferred() const {
  return preferred_;
}
inline void LaneInfo::set_preferred(bool value) {
  set_has_preferred();
  preferred_ = value;
}

// -------------------------------------------------------------------

// JunctionView

// optional .com.telenav.proto.map.JunctionViewType type = 1;
inline bool JunctionView::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JunctionView::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JunctionView::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JunctionView::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::com::telenav::proto::map::JunctionViewType JunctionView::type() const {
  return static_cast< ::com::telenav::proto::map::JunctionViewType >(type_);
}
inline void JunctionView::set_type(::com::telenav::proto::map::JunctionViewType value) {
  assert(::com::telenav::proto::map::JunctionViewType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string pattern_id = 2;
inline bool JunctionView::has_pattern_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JunctionView::set_has_pattern_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JunctionView::clear_has_pattern_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JunctionView::clear_pattern_id() {
  if (pattern_id_ != &::google::protobuf::internal::kEmptyString) {
    pattern_id_->clear();
  }
  clear_has_pattern_id();
}
inline const ::std::string& JunctionView::pattern_id() const {
  return *pattern_id_;
}
inline void JunctionView::set_pattern_id(const ::std::string& value) {
  set_has_pattern_id();
  if (pattern_id_ == &::google::protobuf::internal::kEmptyString) {
    pattern_id_ = new ::std::string;
  }
  pattern_id_->assign(value);
}
inline void JunctionView::set_pattern_id(const char* value) {
  set_has_pattern_id();
  if (pattern_id_ == &::google::protobuf::internal::kEmptyString) {
    pattern_id_ = new ::std::string;
  }
  pattern_id_->assign(value);
}
inline void JunctionView::set_pattern_id(const char* value, size_t size) {
  set_has_pattern_id();
  if (pattern_id_ == &::google::protobuf::internal::kEmptyString) {
    pattern_id_ = new ::std::string;
  }
  pattern_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JunctionView::mutable_pattern_id() {
  set_has_pattern_id();
  if (pattern_id_ == &::google::protobuf::internal::kEmptyString) {
    pattern_id_ = new ::std::string;
  }
  return pattern_id_;
}
inline ::std::string* JunctionView::release_pattern_id() {
  clear_has_pattern_id();
  if (pattern_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pattern_id_;
    pattern_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JunctionView::set_allocated_pattern_id(::std::string* pattern_id) {
  if (pattern_id_ != &::google::protobuf::internal::kEmptyString) {
    delete pattern_id_;
  }
  if (pattern_id) {
    set_has_pattern_id();
    pattern_id_ = pattern_id;
  } else {
    clear_has_pattern_id();
    pattern_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string arrow_id = 3;
inline bool JunctionView::has_arrow_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JunctionView::set_has_arrow_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JunctionView::clear_has_arrow_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JunctionView::clear_arrow_id() {
  if (arrow_id_ != &::google::protobuf::internal::kEmptyString) {
    arrow_id_->clear();
  }
  clear_has_arrow_id();
}
inline const ::std::string& JunctionView::arrow_id() const {
  return *arrow_id_;
}
inline void JunctionView::set_arrow_id(const ::std::string& value) {
  set_has_arrow_id();
  if (arrow_id_ == &::google::protobuf::internal::kEmptyString) {
    arrow_id_ = new ::std::string;
  }
  arrow_id_->assign(value);
}
inline void JunctionView::set_arrow_id(const char* value) {
  set_has_arrow_id();
  if (arrow_id_ == &::google::protobuf::internal::kEmptyString) {
    arrow_id_ = new ::std::string;
  }
  arrow_id_->assign(value);
}
inline void JunctionView::set_arrow_id(const char* value, size_t size) {
  set_has_arrow_id();
  if (arrow_id_ == &::google::protobuf::internal::kEmptyString) {
    arrow_id_ = new ::std::string;
  }
  arrow_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JunctionView::mutable_arrow_id() {
  set_has_arrow_id();
  if (arrow_id_ == &::google::protobuf::internal::kEmptyString) {
    arrow_id_ = new ::std::string;
  }
  return arrow_id_;
}
inline ::std::string* JunctionView::release_arrow_id() {
  clear_has_arrow_id();
  if (arrow_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arrow_id_;
    arrow_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JunctionView::set_allocated_arrow_id(::std::string* arrow_id) {
  if (arrow_id_ != &::google::protobuf::internal::kEmptyString) {
    delete arrow_id_;
  }
  if (arrow_id) {
    set_has_arrow_id();
    arrow_id_ = arrow_id;
  } else {
    clear_has_arrow_id();
    arrow_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace map
}  // namespace proto
}  // namespace telenav
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_map_2edirections_2eproto__INCLUDED
