// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "common.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace telenav {
namespace proto {

void protobuf_ShutdownFile_common_2eproto() {
  delete LatLon::default_instance_;
  delete Address::default_instance_;
  delete Street::default_instance_;
  delete SearchQuery::default_instance_;
  delete Facet::default_instance_;
  delete Currency::default_instance_;
  delete NameValuePair::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_common_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_common_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  LatLon::default_instance_ = new LatLon();
  Address::default_instance_ = new Address();
  Street::default_instance_ = new Street();
  SearchQuery::default_instance_ = new SearchQuery();
  Facet::default_instance_ = new Facet();
  Currency::default_instance_ = new Currency();
  NameValuePair::default_instance_ = new NameValuePair();
  LatLon::default_instance_->InitAsDefaultInstance();
  Address::default_instance_->InitAsDefaultInstance();
  Street::default_instance_->InitAsDefaultInstance();
  SearchQuery::default_instance_->InitAsDefaultInstance();
  Facet::default_instance_->InitAsDefaultInstance();
  Currency::default_instance_->InitAsDefaultInstance();
  NameValuePair::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_common_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_common_2eproto_once_);
void protobuf_AddDesc_common_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_common_2eproto_once_,
                 &protobuf_AddDesc_common_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_common_2eproto {
  StaticDescriptorInitializer_common_2eproto() {
    protobuf_AddDesc_common_2eproto();
  }
} static_descriptor_initializer_common_2eproto_;
#endif
bool CurrencyCode_IsValid(int value) {
  switch(value) {
    case 8:
    case 12:
    case 32:
    case 36:
    case 48:
    case 50:
    case 51:
    case 52:
    case 60:
    case 64:
    case 68:
    case 72:
    case 84:
    case 90:
    case 96:
    case 104:
    case 108:
    case 116:
    case 124:
    case 132:
    case 136:
    case 144:
    case 152:
    case 156:
    case 170:
    case 174:
    case 188:
    case 191:
    case 192:
    case 203:
    case 208:
    case 214:
    case 230:
    case 232:
    case 238:
    case 242:
    case 262:
    case 270:
    case 292:
    case 320:
    case 324:
    case 328:
    case 332:
    case 340:
    case 344:
    case 348:
    case 352:
    case 356:
    case 360:
    case 364:
    case 368:
    case 376:
    case 388:
    case 392:
    case 398:
    case 400:
    case 404:
    case 408:
    case 410:
    case 414:
    case 417:
    case 418:
    case 422:
    case 426:
    case 428:
    case 430:
    case 434:
    case 440:
    case 446:
    case 454:
    case 458:
    case 462:
    case 478:
    case 480:
    case 484:
    case 496:
    case 498:
    case 504:
    case 512:
    case 516:
    case 524:
    case 532:
    case 533:
    case 548:
    case 554:
    case 558:
    case 566:
    case 578:
    case 586:
    case 590:
    case 598:
    case 600:
    case 604:
    case 608:
    case 634:
    case 643:
    case 646:
    case 654:
    case 678:
    case 682:
    case 690:
    case 694:
    case 702:
    case 704:
    case 706:
    case 710:
    case 728:
    case 748:
    case 752:
    case 756:
    case 760:
    case 764:
    case 776:
    case 780:
    case 784:
    case 788:
    case 800:
    case 807:
    case 818:
    case 826:
    case 834:
    case 840:
    case 858:
    case 860:
    case 882:
    case 886:
    case 901:
    case 931:
    case 934:
    case 936:
    case 937:
    case 938:
    case 940:
    case 941:
    case 943:
    case 944:
    case 946:
    case 947:
    case 948:
    case 949:
    case 950:
    case 951:
    case 952:
    case 953:
    case 955:
    case 956:
    case 957:
    case 958:
    case 959:
    case 960:
    case 961:
    case 962:
    case 964:
    case 967:
    case 968:
    case 969:
    case 970:
    case 971:
    case 972:
    case 973:
    case 974:
    case 975:
    case 976:
    case 977:
    case 978:
    case 979:
    case 980:
    case 981:
    case 984:
    case 985:
    case 986:
    case 990:
    case 997:
    case 998:
      return true;
    default:
      return false;
  }
}

bool Country_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 187:
    case 188:
    case 189:
    case 190:
    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 202:
    case 203:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
    case 224:
    case 225:
    case 226:
    case 227:
    case 228:
    case 229:
    case 230:
    case 231:
    case 232:
    case 233:
    case 234:
    case 235:
    case 236:
    case 237:
    case 238:
    case 239:
    case 240:
    case 241:
    case 242:
    case 243:
    case 244:
    case 245:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int LatLon::kLatFieldNumber;
const int LatLon::kLonFieldNumber;
#endif  // !_MSC_VER

LatLon::LatLon()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LatLon::InitAsDefaultInstance() {
}

LatLon::LatLon(const LatLon& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LatLon::SharedCtor() {
  _cached_size_ = 0;
  lat_ = 0;
  lon_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LatLon::~LatLon() {
  SharedDtor();
}

void LatLon::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LatLon::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LatLon& LatLon::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_common_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
#endif
  return *default_instance_;
}

LatLon* LatLon::default_instance_ = NULL;

LatLon* LatLon::New() const {
  return new LatLon;
}

void LatLon::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    lat_ = 0;
    lon_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LatLon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double lat = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lat_)));
          set_has_lat();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_lon;
        break;
      }

      // required double lon = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_lon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lon_)));
          set_has_lon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LatLon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double lat = 1;
  if (has_lat()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->lat(), output);
  }

  // required double lon = 2;
  if (has_lon()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->lon(), output);
  }

}

int LatLon::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double lat = 1;
    if (has_lat()) {
      total_size += 1 + 8;
    }

    // required double lon = 2;
    if (has_lon()) {
      total_size += 1 + 8;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LatLon::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LatLon*>(&from));
}

void LatLon::MergeFrom(const LatLon& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lat()) {
      set_lat(from.lat());
    }
    if (from.has_lon()) {
      set_lon(from.lon());
    }
  }
}

void LatLon::CopyFrom(const LatLon& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LatLon::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void LatLon::Swap(LatLon* other) {
  if (other != this) {
    std::swap(lat_, other->lat_);
    std::swap(lon_, other->lon_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LatLon::GetTypeName() const {
  return "com.telenav.proto.LatLon";
}


// ===================================================================

#ifndef _MSC_VER
const int Address::kFormattedAddressFieldNumber;
const int Address::kHouseNumberFieldNumber;
const int Address::kSuiteFieldNumber;
const int Address::kSubStreetFieldNumber;
const int Address::kStreetFieldNumber;
const int Address::kCrossStreetFieldNumber;
const int Address::kSubLocalityFieldNumber;
const int Address::kLocalityFieldNumber;
const int Address::kCityFieldNumber;
const int Address::kCountyFieldNumber;
const int Address::kStateFieldNumber;
const int Address::kCountryFieldNumber;
const int Address::kPostalCodeFieldNumber;
#endif  // !_MSC_VER

Address::Address()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Address::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  street_ = const_cast< ::com::telenav::proto::Street*>(
      ::com::telenav::proto::Street::internal_default_instance());
#else
  street_ = const_cast< ::com::telenav::proto::Street*>(&::com::telenav::proto::Street::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  cross_street_ = const_cast< ::com::telenav::proto::Street*>(
      ::com::telenav::proto::Street::internal_default_instance());
#else
  cross_street_ = const_cast< ::com::telenav::proto::Street*>(&::com::telenav::proto::Street::default_instance());
#endif
}

Address::Address(const Address& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Address::SharedCtor() {
  _cached_size_ = 0;
  formatted_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  house_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  suite_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sub_street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  street_ = NULL;
  cross_street_ = NULL;
  sub_locality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  locality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  county_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  country_ = 1;
  postal_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Address::~Address() {
  SharedDtor();
}

void Address::SharedDtor() {
  if (formatted_address_ != &::google::protobuf::internal::kEmptyString) {
    delete formatted_address_;
  }
  if (house_number_ != &::google::protobuf::internal::kEmptyString) {
    delete house_number_;
  }
  if (suite_ != &::google::protobuf::internal::kEmptyString) {
    delete suite_;
  }
  if (sub_street_ != &::google::protobuf::internal::kEmptyString) {
    delete sub_street_;
  }
  if (sub_locality_ != &::google::protobuf::internal::kEmptyString) {
    delete sub_locality_;
  }
  if (locality_ != &::google::protobuf::internal::kEmptyString) {
    delete locality_;
  }
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (county_ != &::google::protobuf::internal::kEmptyString) {
    delete county_;
  }
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (postal_code_ != &::google::protobuf::internal::kEmptyString) {
    delete postal_code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete street_;
    delete cross_street_;
  }
}

void Address::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Address& Address::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_common_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
#endif
  return *default_instance_;
}

Address* Address::default_instance_ = NULL;

Address* Address::New() const {
  return new Address;
}

void Address::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_formatted_address()) {
      if (formatted_address_ != &::google::protobuf::internal::kEmptyString) {
        formatted_address_->clear();
      }
    }
    if (has_house_number()) {
      if (house_number_ != &::google::protobuf::internal::kEmptyString) {
        house_number_->clear();
      }
    }
    if (has_suite()) {
      if (suite_ != &::google::protobuf::internal::kEmptyString) {
        suite_->clear();
      }
    }
    if (has_sub_street()) {
      if (sub_street_ != &::google::protobuf::internal::kEmptyString) {
        sub_street_->clear();
      }
    }
    if (has_street()) {
      if (street_ != NULL) street_->::com::telenav::proto::Street::Clear();
    }
    if (has_cross_street()) {
      if (cross_street_ != NULL) cross_street_->::com::telenav::proto::Street::Clear();
    }
    if (has_sub_locality()) {
      if (sub_locality_ != &::google::protobuf::internal::kEmptyString) {
        sub_locality_->clear();
      }
    }
    if (has_locality()) {
      if (locality_ != &::google::protobuf::internal::kEmptyString) {
        locality_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_city()) {
      if (city_ != &::google::protobuf::internal::kEmptyString) {
        city_->clear();
      }
    }
    if (has_county()) {
      if (county_ != &::google::protobuf::internal::kEmptyString) {
        county_->clear();
      }
    }
    if (has_state()) {
      if (state_ != &::google::protobuf::internal::kEmptyString) {
        state_->clear();
      }
    }
    country_ = 1;
    if (has_postal_code()) {
      if (postal_code_ != &::google::protobuf::internal::kEmptyString) {
        postal_code_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Address::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string formatted_address = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_formatted_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_house_number;
        break;
      }

      // optional string house_number = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_house_number:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_house_number()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(242)) goto parse_suite;
        break;
      }

      // optional string suite = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_suite:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_suite()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(322)) goto parse_sub_street;
        break;
      }

      // optional string sub_street = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sub_street:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sub_street()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(402)) goto parse_street;
        break;
      }

      // optional .com.telenav.proto.Street street = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_street:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_street()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(482)) goto parse_cross_street;
        break;
      }

      // optional .com.telenav.proto.Street cross_street = 60;
      case 60: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cross_street:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cross_street()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(562)) goto parse_sub_locality;
        break;
      }

      // optional string sub_locality = 70;
      case 70: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sub_locality:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sub_locality()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(642)) goto parse_locality;
        break;
      }

      // optional string locality = 80;
      case 80: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_locality:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_locality()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(722)) goto parse_city;
        break;
      }

      // optional string city = 90;
      case 90: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_city:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_city()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(802)) goto parse_county;
        break;
      }

      // optional string county = 100;
      case 100: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_county:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_county()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(882)) goto parse_state;
        break;
      }

      // optional string state = 110;
      case 110: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_state()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(960)) goto parse_country;
        break;
      }

      // optional .com.telenav.proto.Country country = 120;
      case 120: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_country:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::Country_IsValid(value)) {
            set_country(static_cast< ::com::telenav::proto::Country >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(1042)) goto parse_postal_code;
        break;
      }

      // optional string postal_code = 130;
      case 130: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_postal_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_postal_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Address::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string formatted_address = 10;
  if (has_formatted_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->formatted_address(), output);
  }

  // optional string house_number = 20;
  if (has_house_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->house_number(), output);
  }

  // optional string suite = 30;
  if (has_suite()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      30, this->suite(), output);
  }

  // optional string sub_street = 40;
  if (has_sub_street()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      40, this->sub_street(), output);
  }

  // optional .com.telenav.proto.Street street = 50;
  if (has_street()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      50, this->street(), output);
  }

  // optional .com.telenav.proto.Street cross_street = 60;
  if (has_cross_street()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      60, this->cross_street(), output);
  }

  // optional string sub_locality = 70;
  if (has_sub_locality()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      70, this->sub_locality(), output);
  }

  // optional string locality = 80;
  if (has_locality()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      80, this->locality(), output);
  }

  // optional string city = 90;
  if (has_city()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      90, this->city(), output);
  }

  // optional string county = 100;
  if (has_county()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      100, this->county(), output);
  }

  // optional string state = 110;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      110, this->state(), output);
  }

  // optional .com.telenav.proto.Country country = 120;
  if (has_country()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      120, this->country(), output);
  }

  // optional string postal_code = 130;
  if (has_postal_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      130, this->postal_code(), output);
  }

}

int Address::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string formatted_address = 10;
    if (has_formatted_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->formatted_address());
    }

    // optional string house_number = 20;
    if (has_house_number()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->house_number());
    }

    // optional string suite = 30;
    if (has_suite()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->suite());
    }

    // optional string sub_street = 40;
    if (has_sub_street()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sub_street());
    }

    // optional .com.telenav.proto.Street street = 50;
    if (has_street()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->street());
    }

    // optional .com.telenav.proto.Street cross_street = 60;
    if (has_cross_street()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cross_street());
    }

    // optional string sub_locality = 70;
    if (has_sub_locality()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sub_locality());
    }

    // optional string locality = 80;
    if (has_locality()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->locality());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string city = 90;
    if (has_city()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->city());
    }

    // optional string county = 100;
    if (has_county()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->county());
    }

    // optional string state = 110;
    if (has_state()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->state());
    }

    // optional .com.telenav.proto.Country country = 120;
    if (has_country()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->country());
    }

    // optional string postal_code = 130;
    if (has_postal_code()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->postal_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Address::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Address*>(&from));
}

void Address::MergeFrom(const Address& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_formatted_address()) {
      set_formatted_address(from.formatted_address());
    }
    if (from.has_house_number()) {
      set_house_number(from.house_number());
    }
    if (from.has_suite()) {
      set_suite(from.suite());
    }
    if (from.has_sub_street()) {
      set_sub_street(from.sub_street());
    }
    if (from.has_street()) {
      mutable_street()->::com::telenav::proto::Street::MergeFrom(from.street());
    }
    if (from.has_cross_street()) {
      mutable_cross_street()->::com::telenav::proto::Street::MergeFrom(from.cross_street());
    }
    if (from.has_sub_locality()) {
      set_sub_locality(from.sub_locality());
    }
    if (from.has_locality()) {
      set_locality(from.locality());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_city()) {
      set_city(from.city());
    }
    if (from.has_county()) {
      set_county(from.county());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_country()) {
      set_country(from.country());
    }
    if (from.has_postal_code()) {
      set_postal_code(from.postal_code());
    }
  }
}

void Address::CopyFrom(const Address& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Address::IsInitialized() const {

  return true;
}

void Address::Swap(Address* other) {
  if (other != this) {
    std::swap(formatted_address_, other->formatted_address_);
    std::swap(house_number_, other->house_number_);
    std::swap(suite_, other->suite_);
    std::swap(sub_street_, other->sub_street_);
    std::swap(street_, other->street_);
    std::swap(cross_street_, other->cross_street_);
    std::swap(sub_locality_, other->sub_locality_);
    std::swap(locality_, other->locality_);
    std::swap(city_, other->city_);
    std::swap(county_, other->county_);
    std::swap(state_, other->state_);
    std::swap(country_, other->country_);
    std::swap(postal_code_, other->postal_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Address::GetTypeName() const {
  return "com.telenav.proto.Address";
}


// ===================================================================

#ifndef _MSC_VER
const int Street::kDirsFieldNumber;
const int Street::kBodyFieldNumber;
const int Street::kTypeFieldNumber;
const int Street::kFormattedNameFieldNumber;
#endif  // !_MSC_VER

Street::Street()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Street::InitAsDefaultInstance() {
}

Street::Street(const Street& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Street::SharedCtor() {
  _cached_size_ = 0;
  body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  formatted_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Street::~Street() {
  SharedDtor();
}

void Street::SharedDtor() {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    delete body_;
  }
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (formatted_name_ != &::google::protobuf::internal::kEmptyString) {
    delete formatted_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Street::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Street& Street::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_common_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
#endif
  return *default_instance_;
}

Street* Street::default_instance_ = NULL;

Street* Street::New() const {
  return new Street;
}

void Street::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_body()) {
      if (body_ != &::google::protobuf::internal::kEmptyString) {
        body_->clear();
      }
    }
    if (has_type()) {
      if (type_ != &::google::protobuf::internal::kEmptyString) {
        type_->clear();
      }
    }
    if (has_formatted_name()) {
      if (formatted_name_ != &::google::protobuf::internal::kEmptyString) {
        formatted_name_->clear();
      }
    }
  }
  dirs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Street::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string dirs = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dirs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_dirs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_dirs;
        if (input->ExpectTag(162)) goto parse_body;
        break;
      }

      // optional string body = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_body:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_body()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(242)) goto parse_type;
        break;
      }

      // optional string type = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(322)) goto parse_formatted_name;
        break;
      }

      // optional string formatted_name = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_formatted_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_formatted_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Street::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated string dirs = 10;
  for (int i = 0; i < this->dirs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->dirs(i), output);
  }

  // optional string body = 20;
  if (has_body()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->body(), output);
  }

  // optional string type = 30;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      30, this->type(), output);
  }

  // optional string formatted_name = 40;
  if (has_formatted_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      40, this->formatted_name(), output);
  }

}

int Street::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string body = 20;
    if (has_body()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->body());
    }

    // optional string type = 30;
    if (has_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // optional string formatted_name = 40;
    if (has_formatted_name()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->formatted_name());
    }

  }
  // repeated string dirs = 10;
  total_size += 1 * this->dirs_size();
  for (int i = 0; i < this->dirs_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->dirs(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Street::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Street*>(&from));
}

void Street::MergeFrom(const Street& from) {
  GOOGLE_CHECK_NE(&from, this);
  dirs_.MergeFrom(from.dirs_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_body()) {
      set_body(from.body());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_formatted_name()) {
      set_formatted_name(from.formatted_name());
    }
  }
}

void Street::CopyFrom(const Street& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Street::IsInitialized() const {

  return true;
}

void Street::Swap(Street* other) {
  if (other != this) {
    dirs_.Swap(&other->dirs_);
    std::swap(body_, other->body_);
    std::swap(type_, other->type_);
    std::swap(formatted_name_, other->formatted_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Street::GetTypeName() const {
  return "com.telenav.proto.Street";
}


// ===================================================================

#ifndef _MSC_VER
const int SearchQuery::kDomainFieldNumber;
const int SearchQuery::kCategoryFieldNumber;
#endif  // !_MSC_VER

SearchQuery::SearchQuery()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SearchQuery::InitAsDefaultInstance() {
}

SearchQuery::SearchQuery(const SearchQuery& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SearchQuery::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SearchQuery::~SearchQuery() {
  SharedDtor();
}

void SearchQuery::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SearchQuery::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SearchQuery& SearchQuery::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_common_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
#endif
  return *default_instance_;
}

SearchQuery* SearchQuery::default_instance_ = NULL;

SearchQuery* SearchQuery::New() const {
  return new SearchQuery;
}

void SearchQuery::Clear() {
  domain_.Clear();
  category_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SearchQuery::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string domain = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_domain:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_domain()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_domain;
        if (input->ExpectTag(162)) goto parse_category;
        break;
      }

      // repeated string category = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_category:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_category()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_category;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SearchQuery::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated string domain = 10;
  for (int i = 0; i < this->domain_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->domain(i), output);
  }

  // repeated string category = 20;
  for (int i = 0; i < this->category_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->category(i), output);
  }

}

int SearchQuery::ByteSize() const {
  int total_size = 0;

  // repeated string domain = 10;
  total_size += 1 * this->domain_size();
  for (int i = 0; i < this->domain_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->domain(i));
  }

  // repeated string category = 20;
  total_size += 2 * this->category_size();
  for (int i = 0; i < this->category_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->category(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SearchQuery::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SearchQuery*>(&from));
}

void SearchQuery::MergeFrom(const SearchQuery& from) {
  GOOGLE_CHECK_NE(&from, this);
  domain_.MergeFrom(from.domain_);
  category_.MergeFrom(from.category_);
}

void SearchQuery::CopyFrom(const SearchQuery& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SearchQuery::IsInitialized() const {

  return true;
}

void SearchQuery::Swap(SearchQuery* other) {
  if (other != this) {
    domain_.Swap(&other->domain_);
    category_.Swap(&other->category_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SearchQuery::GetTypeName() const {
  return "com.telenav.proto.SearchQuery";
}


// ===================================================================

#ifndef _MSC_VER
const int Facet::kTypeFieldNumber;
const int Facet::kFacetDataFieldNumber;
#endif  // !_MSC_VER

Facet::Facet()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Facet::InitAsDefaultInstance() {
}

Facet::Facet(const Facet& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Facet::SharedCtor() {
  _cached_size_ = 0;
  type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  facet_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Facet::~Facet() {
  SharedDtor();
}

void Facet::SharedDtor() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (facet_data_ != &::google::protobuf::internal::kEmptyString) {
    delete facet_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Facet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Facet& Facet::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_common_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
#endif
  return *default_instance_;
}

Facet* Facet::default_instance_ = NULL;

Facet* Facet::New() const {
  return new Facet;
}

void Facet::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_type()) {
      if (type_ != &::google::protobuf::internal::kEmptyString) {
        type_->clear();
      }
    }
    if (has_facet_data()) {
      if (facet_data_ != &::google::protobuf::internal::kEmptyString) {
        facet_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Facet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string type = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_facet_data;
        break;
      }

      // required string facet_data = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_facet_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_facet_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Facet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string type = 10;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->type(), output);
  }

  // required string facet_data = 20;
  if (has_facet_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->facet_data(), output);
  }

}

int Facet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string type = 10;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // required string facet_data = 20;
    if (has_facet_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->facet_data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Facet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Facet*>(&from));
}

void Facet::MergeFrom(const Facet& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_facet_data()) {
      set_facet_data(from.facet_data());
    }
  }
}

void Facet::CopyFrom(const Facet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Facet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Facet::Swap(Facet* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(facet_data_, other->facet_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Facet::GetTypeName() const {
  return "com.telenav.proto.Facet";
}


// ===================================================================

#ifndef _MSC_VER
const int Currency::kValueFieldNumber;
const int Currency::kIsoCodeFieldNumber;
const int Currency::kSymbolFieldNumber;
#endif  // !_MSC_VER

Currency::Currency()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Currency::InitAsDefaultInstance() {
}

Currency::Currency(const Currency& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Currency::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0;
  iso_code_ = 784;
  symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Currency::~Currency() {
  SharedDtor();
}

void Currency::SharedDtor() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Currency::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Currency& Currency::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_common_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
#endif
  return *default_instance_;
}

Currency* Currency::default_instance_ = NULL;

Currency* Currency::New() const {
  return new Currency;
}

void Currency::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0;
    iso_code_ = 784;
    if (has_symbol()) {
      if (symbol_ != &::google::protobuf::internal::kEmptyString) {
        symbol_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Currency::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float value = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_iso_code;
        break;
      }

      // required .com.telenav.proto.CurrencyCode iso_code = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_iso_code:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::CurrencyCode_IsValid(value)) {
            set_iso_code(static_cast< ::com::telenav::proto::CurrencyCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(242)) goto parse_symbol;
        break;
      }

      // optional string symbol = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_symbol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_symbol()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Currency::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float value = 10;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->value(), output);
  }

  // required .com.telenav.proto.CurrencyCode iso_code = 20;
  if (has_iso_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      20, this->iso_code(), output);
  }

  // optional string symbol = 30;
  if (has_symbol()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      30, this->symbol(), output);
  }

}

int Currency::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float value = 10;
    if (has_value()) {
      total_size += 1 + 4;
    }

    // required .com.telenav.proto.CurrencyCode iso_code = 20;
    if (has_iso_code()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->iso_code());
    }

    // optional string symbol = 30;
    if (has_symbol()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->symbol());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Currency::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Currency*>(&from));
}

void Currency::MergeFrom(const Currency& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_iso_code()) {
      set_iso_code(from.iso_code());
    }
    if (from.has_symbol()) {
      set_symbol(from.symbol());
    }
  }
}

void Currency::CopyFrom(const Currency& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Currency::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Currency::Swap(Currency* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(iso_code_, other->iso_code_);
    std::swap(symbol_, other->symbol_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Currency::GetTypeName() const {
  return "com.telenav.proto.Currency";
}


// ===================================================================

#ifndef _MSC_VER
const int NameValuePair::kNameFieldNumber;
const int NameValuePair::kValueFieldNumber;
#endif  // !_MSC_VER

NameValuePair::NameValuePair()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NameValuePair::InitAsDefaultInstance() {
}

NameValuePair::NameValuePair(const NameValuePair& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NameValuePair::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NameValuePair::~NameValuePair() {
  SharedDtor();
}

void NameValuePair::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NameValuePair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NameValuePair& NameValuePair::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_common_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
#endif
  return *default_instance_;
}

NameValuePair* NameValuePair::default_instance_ = NULL;

NameValuePair* NameValuePair::New() const {
  return new NameValuePair;
}

void NameValuePair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NameValuePair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_value;
        break;
      }

      // required string value = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NameValuePair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 10;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->name(), output);
  }

  // required string value = 20;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->value(), output);
  }

}

int NameValuePair::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 10;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required string value = 20;
    if (has_value()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NameValuePair::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NameValuePair*>(&from));
}

void NameValuePair::MergeFrom(const NameValuePair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void NameValuePair::CopyFrom(const NameValuePair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NameValuePair::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void NameValuePair::Swap(NameValuePair* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NameValuePair::GetTypeName() const {
  return "com.telenav.proto.NameValuePair";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace telenav
}  // namespace com

// @@protoc_insertion_point(global_scope)
