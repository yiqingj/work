// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map.directions.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mapnik/map.directions.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace telenav {
namespace proto {
namespace map {

void protobuf_ShutdownFile_map_2edirections_2eproto() {
  delete RouteRequest::default_instance_;
  delete RouteOption::default_instance_;
  delete Location::default_instance_;
  delete OutputOption::default_instance_;
  delete GuidanceRequest::default_instance_;
  delete BasicRouteResponse::default_instance_;
  delete RouteResponse::default_instance_;
  delete FindMeRequest::default_instance_;
  delete FindMeResponse::default_instance_;
  delete SystemInfoResponse::default_instance_;
  delete GpsFix::default_instance_;
  delete Candidate::default_instance_;
  delete BasicRoute::default_instance_;
  delete BasicPath::default_instance_;
  delete Route::default_instance_;
  delete RouteInfo::default_instance_;
  delete Path::default_instance_;
  delete GuidanceSegment::default_instance_;
  delete RoadName::default_instance_;
  delete SignPost::default_instance_;
  delete SignBoard::default_instance_;
  delete Edge::default_instance_;
  delete TimeProfile::default_instance_;
  delete LaneInfo::default_instance_;
  delete JunctionView::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_map_2edirections_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_map_2edirections_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::com::telenav::proto::protobuf_AddDesc_services_2eproto();
  ::com::telenav::proto::protobuf_AddDesc_common_2eproto();
  ::com::telenav::proto::map::protobuf_AddDesc_map_2ecommon_2eproto();
  RouteRequest::default_instance_ = new RouteRequest();
  RouteOption::default_instance_ = new RouteOption();
  Location::default_instance_ = new Location();
  OutputOption::default_instance_ = new OutputOption();
  GuidanceRequest::default_instance_ = new GuidanceRequest();
  BasicRouteResponse::default_instance_ = new BasicRouteResponse();
  RouteResponse::default_instance_ = new RouteResponse();
  FindMeRequest::default_instance_ = new FindMeRequest();
  FindMeResponse::default_instance_ = new FindMeResponse();
  SystemInfoResponse::default_instance_ = new SystemInfoResponse();
  GpsFix::default_instance_ = new GpsFix();
  Candidate::default_instance_ = new Candidate();
  BasicRoute::default_instance_ = new BasicRoute();
  BasicPath::default_instance_ = new BasicPath();
  Route::default_instance_ = new Route();
  RouteInfo::default_instance_ = new RouteInfo();
  Path::default_instance_ = new Path();
  GuidanceSegment::default_instance_ = new GuidanceSegment();
  RoadName::default_instance_ = new RoadName();
  SignPost::default_instance_ = new SignPost();
  SignBoard::default_instance_ = new SignBoard();
  Edge::default_instance_ = new Edge();
  TimeProfile::default_instance_ = new TimeProfile();
  LaneInfo::default_instance_ = new LaneInfo();
  JunctionView::default_instance_ = new JunctionView();
  RouteRequest::default_instance_->InitAsDefaultInstance();
  RouteOption::default_instance_->InitAsDefaultInstance();
  Location::default_instance_->InitAsDefaultInstance();
  OutputOption::default_instance_->InitAsDefaultInstance();
  GuidanceRequest::default_instance_->InitAsDefaultInstance();
  BasicRouteResponse::default_instance_->InitAsDefaultInstance();
  RouteResponse::default_instance_->InitAsDefaultInstance();
  FindMeRequest::default_instance_->InitAsDefaultInstance();
  FindMeResponse::default_instance_->InitAsDefaultInstance();
  SystemInfoResponse::default_instance_->InitAsDefaultInstance();
  GpsFix::default_instance_->InitAsDefaultInstance();
  Candidate::default_instance_->InitAsDefaultInstance();
  BasicRoute::default_instance_->InitAsDefaultInstance();
  BasicPath::default_instance_->InitAsDefaultInstance();
  Route::default_instance_->InitAsDefaultInstance();
  RouteInfo::default_instance_->InitAsDefaultInstance();
  Path::default_instance_->InitAsDefaultInstance();
  GuidanceSegment::default_instance_->InitAsDefaultInstance();
  RoadName::default_instance_->InitAsDefaultInstance();
  SignPost::default_instance_->InitAsDefaultInstance();
  SignBoard::default_instance_->InitAsDefaultInstance();
  Edge::default_instance_->InitAsDefaultInstance();
  TimeProfile::default_instance_->InitAsDefaultInstance();
  LaneInfo::default_instance_->InitAsDefaultInstance();
  JunctionView::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_map_2edirections_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_map_2edirections_2eproto_once_);
void protobuf_AddDesc_map_2edirections_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_map_2edirections_2eproto_once_,
                 &protobuf_AddDesc_map_2edirections_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_map_2edirections_2eproto {
  StaticDescriptorInitializer_map_2edirections_2eproto() {
    protobuf_AddDesc_map_2edirections_2eproto();
  }
} static_descriptor_initializer_map_2edirections_2eproto_;
#endif
bool RouteStyle_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

bool EcoMode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool SignBoardType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool LanePattern_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

bool JunctionViewType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

bool HighlightedLane_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

bool Warning_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

bool TurnType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 26:
    case 27:
    case 50:
    case 51:
    case 60:
    case 61:
    case 62:
    case 63:
    case 67:
    case 70:
    case 76:
    case 77:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 97:
    case 98:
    case 99:
    case 113:
    case 114:
    case 120:
    case 121:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int RouteRequest::kOriginFieldNumber;
const int RouteRequest::kDestinationFieldNumber;
const int RouteRequest::kStyleFieldNumber;
const int RouteRequest::kOptionFieldNumber;
const int RouteRequest::kMaxRouteNumberFieldNumber;
const int RouteRequest::kHeadingFieldNumber;
const int RouteRequest::kSpeedInMpsFieldNumber;
const int RouteRequest::kDestCandidateFieldNumber;
const int RouteRequest::kOutputOptionFieldNumber;
const int RouteRequest::kDeviationCountFieldNumber;
const int RouteRequest::kDataSetFieldNumber;
const int RouteRequest::kContextFieldNumber;
const int RouteRequest::kRouteStartTimeFieldNumber;
const int RouteRequest::kUseTimeRestrictionForRoadFieldNumber;
const int RouteRequest::kEcoModeFieldNumber;
const int RouteRequest::kWaypointFieldNumber;
#endif  // !_MSC_VER

RouteRequest::RouteRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RouteRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  origin_ = const_cast< ::com::telenav::proto::map::Location*>(
      ::com::telenav::proto::map::Location::internal_default_instance());
#else
  origin_ = const_cast< ::com::telenav::proto::map::Location*>(&::com::telenav::proto::map::Location::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  destination_ = const_cast< ::com::telenav::proto::map::Location*>(
      ::com::telenav::proto::map::Location::internal_default_instance());
#else
  destination_ = const_cast< ::com::telenav::proto::map::Location*>(&::com::telenav::proto::map::Location::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  option_ = const_cast< ::com::telenav::proto::map::RouteOption*>(
      ::com::telenav::proto::map::RouteOption::internal_default_instance());
#else
  option_ = const_cast< ::com::telenav::proto::map::RouteOption*>(&::com::telenav::proto::map::RouteOption::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  output_option_ = const_cast< ::com::telenav::proto::map::OutputOption*>(
      ::com::telenav::proto::map::OutputOption::internal_default_instance());
#else
  output_option_ = const_cast< ::com::telenav::proto::map::OutputOption*>(&::com::telenav::proto::map::OutputOption::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  context_ = const_cast< ::com::telenav::proto::Context*>(
      ::com::telenav::proto::Context::internal_default_instance());
#else
  context_ = const_cast< ::com::telenav::proto::Context*>(&::com::telenav::proto::Context::default_instance());
#endif
}

RouteRequest::RouteRequest(const RouteRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RouteRequest::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  destination_ = NULL;
  style_ = 1;
  option_ = NULL;
  max_route_number_ = 1;
  heading_ = -1;
  speed_in_mps_ = 0;
  output_option_ = NULL;
  deviation_count_ = 0;
  data_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  context_ = NULL;
  route_start_time_ = GOOGLE_LONGLONG(0);
  use_time_restriction_for_road_ = false;
  eco_mode_ = 3;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RouteRequest::~RouteRequest() {
  SharedDtor();
}

void RouteRequest::SharedDtor() {
  if (data_set_ != &::google::protobuf::internal::kEmptyString) {
    delete data_set_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete origin_;
    delete destination_;
    delete option_;
    delete output_option_;
    delete context_;
  }
}

void RouteRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RouteRequest& RouteRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

RouteRequest* RouteRequest::default_instance_ = NULL;

RouteRequest* RouteRequest::New() const {
  return new RouteRequest;
}

void RouteRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_origin()) {
      if (origin_ != NULL) origin_->::com::telenav::proto::map::Location::Clear();
    }
    if (has_destination()) {
      if (destination_ != NULL) destination_->::com::telenav::proto::map::Location::Clear();
    }
    style_ = 1;
    if (has_option()) {
      if (option_ != NULL) option_->::com::telenav::proto::map::RouteOption::Clear();
    }
    max_route_number_ = 1;
    heading_ = -1;
    speed_in_mps_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_output_option()) {
      if (output_option_ != NULL) output_option_->::com::telenav::proto::map::OutputOption::Clear();
    }
    deviation_count_ = 0;
    if (has_data_set()) {
      if (data_set_ != &::google::protobuf::internal::kEmptyString) {
        data_set_->clear();
      }
    }
    if (has_context()) {
      if (context_ != NULL) context_->::com::telenav::proto::Context::Clear();
    }
    route_start_time_ = GOOGLE_LONGLONG(0);
    use_time_restriction_for_road_ = false;
    eco_mode_ = 3;
  }
  dest_candidate_.Clear();
  waypoint_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RouteRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.telenav.proto.map.Location origin = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_destination;
        break;
      }

      // optional .com.telenav.proto.map.Location destination = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_destination:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_destination()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_style;
        break;
      }

      // optional .com.telenav.proto.map.RouteStyle style = 7 [default = FASTEST];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_style:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::RouteStyle_IsValid(value)) {
            set_style(static_cast< ::com::telenav::proto::map::RouteStyle >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_option;
        break;
      }

      // optional .com.telenav.proto.map.RouteOption option = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_option:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_option()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_max_route_number;
        break;
      }

      // optional int32 max_route_number = 9 [default = 1];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_route_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_route_number_)));
          set_has_max_route_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_heading;
        break;
      }

      // optional int32 heading = 10 [default = -1];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_heading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
          set_has_heading();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_speed_in_mps;
        break;
      }

      // optional int32 speed_in_mps = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_speed_in_mps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &speed_in_mps_)));
          set_has_speed_in_mps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_dest_candidate;
        break;
      }

      // repeated .com.telenav.proto.LatLon dest_candidate = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dest_candidate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_dest_candidate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_dest_candidate;
        if (input->ExpectTag(106)) goto parse_output_option;
        break;
      }

      // optional .com.telenav.proto.map.OutputOption output_option = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_output_option:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_output_option()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_context;
        break;
      }

      // optional .com.telenav.proto.Context context = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_context:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_context()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(144)) goto parse_deviation_count;
        break;
      }

      // optional int32 deviation_count = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_deviation_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &deviation_count_)));
          set_has_deviation_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_data_set;
        break;
      }

      // optional string data_set = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data_set:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data_set()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_route_start_time;
        break;
      }

      // optional int64 route_start_time = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_route_start_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &route_start_time_)));
          set_has_route_start_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(168)) goto parse_use_time_restriction_for_road;
        break;
      }

      // optional bool use_time_restriction_for_road = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_use_time_restriction_for_road:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_time_restriction_for_road_)));
          set_has_use_time_restriction_for_road();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(176)) goto parse_eco_mode;
        break;
      }

      // optional .com.telenav.proto.map.EcoMode eco_mode = 22 [default = HIGH_ECO_MODE];
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_eco_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::EcoMode_IsValid(value)) {
            set_eco_mode(static_cast< ::com::telenav::proto::map::EcoMode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(186)) goto parse_waypoint;
        break;
      }

      // repeated .com.telenav.proto.map.Location waypoint = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_waypoint:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_waypoint()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(186)) goto parse_waypoint;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RouteRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .com.telenav.proto.map.Location origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->origin(), output);
  }

  // optional .com.telenav.proto.map.Location destination = 2;
  if (has_destination()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->destination(), output);
  }

  // optional .com.telenav.proto.map.RouteStyle style = 7 [default = FASTEST];
  if (has_style()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->style(), output);
  }

  // optional .com.telenav.proto.map.RouteOption option = 8;
  if (has_option()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->option(), output);
  }

  // optional int32 max_route_number = 9 [default = 1];
  if (has_max_route_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->max_route_number(), output);
  }

  // optional int32 heading = 10 [default = -1];
  if (has_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->heading(), output);
  }

  // optional int32 speed_in_mps = 11;
  if (has_speed_in_mps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->speed_in_mps(), output);
  }

  // repeated .com.telenav.proto.LatLon dest_candidate = 12;
  for (int i = 0; i < this->dest_candidate_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->dest_candidate(i), output);
  }

  // optional .com.telenav.proto.map.OutputOption output_option = 13;
  if (has_output_option()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, this->output_option(), output);
  }

  // optional .com.telenav.proto.Context context = 16;
  if (has_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, this->context(), output);
  }

  // optional int32 deviation_count = 18;
  if (has_deviation_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(18, this->deviation_count(), output);
  }

  // optional string data_set = 19;
  if (has_data_set()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->data_set(), output);
  }

  // optional int64 route_start_time = 20;
  if (has_route_start_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(20, this->route_start_time(), output);
  }

  // optional bool use_time_restriction_for_road = 21;
  if (has_use_time_restriction_for_road()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(21, this->use_time_restriction_for_road(), output);
  }

  // optional .com.telenav.proto.map.EcoMode eco_mode = 22 [default = HIGH_ECO_MODE];
  if (has_eco_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      22, this->eco_mode(), output);
  }

  // repeated .com.telenav.proto.map.Location waypoint = 23;
  for (int i = 0; i < this->waypoint_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      23, this->waypoint(i), output);
  }

}

int RouteRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .com.telenav.proto.map.Location origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->origin());
    }

    // optional .com.telenav.proto.map.Location destination = 2;
    if (has_destination()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->destination());
    }

    // optional .com.telenav.proto.map.RouteStyle style = 7 [default = FASTEST];
    if (has_style()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->style());
    }

    // optional .com.telenav.proto.map.RouteOption option = 8;
    if (has_option()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->option());
    }

    // optional int32 max_route_number = 9 [default = 1];
    if (has_max_route_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_route_number());
    }

    // optional int32 heading = 10 [default = -1];
    if (has_heading()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

    // optional int32 speed_in_mps = 11;
    if (has_speed_in_mps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->speed_in_mps());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .com.telenav.proto.map.OutputOption output_option = 13;
    if (has_output_option()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->output_option());
    }

    // optional int32 deviation_count = 18;
    if (has_deviation_count()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->deviation_count());
    }

    // optional string data_set = 19;
    if (has_data_set()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->data_set());
    }

    // optional .com.telenav.proto.Context context = 16;
    if (has_context()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->context());
    }

    // optional int64 route_start_time = 20;
    if (has_route_start_time()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->route_start_time());
    }

    // optional bool use_time_restriction_for_road = 21;
    if (has_use_time_restriction_for_road()) {
      total_size += 2 + 1;
    }

    // optional .com.telenav.proto.map.EcoMode eco_mode = 22 [default = HIGH_ECO_MODE];
    if (has_eco_mode()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->eco_mode());
    }

  }
  // repeated .com.telenav.proto.LatLon dest_candidate = 12;
  total_size += 1 * this->dest_candidate_size();
  for (int i = 0; i < this->dest_candidate_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->dest_candidate(i));
  }

  // repeated .com.telenav.proto.map.Location waypoint = 23;
  total_size += 2 * this->waypoint_size();
  for (int i = 0; i < this->waypoint_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->waypoint(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RouteRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RouteRequest*>(&from));
}

void RouteRequest::MergeFrom(const RouteRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  dest_candidate_.MergeFrom(from.dest_candidate_);
  waypoint_.MergeFrom(from.waypoint_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::com::telenav::proto::map::Location::MergeFrom(from.origin());
    }
    if (from.has_destination()) {
      mutable_destination()->::com::telenav::proto::map::Location::MergeFrom(from.destination());
    }
    if (from.has_style()) {
      set_style(from.style());
    }
    if (from.has_option()) {
      mutable_option()->::com::telenav::proto::map::RouteOption::MergeFrom(from.option());
    }
    if (from.has_max_route_number()) {
      set_max_route_number(from.max_route_number());
    }
    if (from.has_heading()) {
      set_heading(from.heading());
    }
    if (from.has_speed_in_mps()) {
      set_speed_in_mps(from.speed_in_mps());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_output_option()) {
      mutable_output_option()->::com::telenav::proto::map::OutputOption::MergeFrom(from.output_option());
    }
    if (from.has_deviation_count()) {
      set_deviation_count(from.deviation_count());
    }
    if (from.has_data_set()) {
      set_data_set(from.data_set());
    }
    if (from.has_context()) {
      mutable_context()->::com::telenav::proto::Context::MergeFrom(from.context());
    }
    if (from.has_route_start_time()) {
      set_route_start_time(from.route_start_time());
    }
    if (from.has_use_time_restriction_for_road()) {
      set_use_time_restriction_for_road(from.use_time_restriction_for_road());
    }
    if (from.has_eco_mode()) {
      set_eco_mode(from.eco_mode());
    }
  }
}

void RouteRequest::CopyFrom(const RouteRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteRequest::IsInitialized() const {

  if (has_origin()) {
    if (!this->origin().IsInitialized()) return false;
  }
  if (has_destination()) {
    if (!this->destination().IsInitialized()) return false;
  }
  for (int i = 0; i < dest_candidate_size(); i++) {
    if (!this->dest_candidate(i).IsInitialized()) return false;
  }
  if (has_context()) {
    if (!this->context().IsInitialized()) return false;
  }
  for (int i = 0; i < waypoint_size(); i++) {
    if (!this->waypoint(i).IsInitialized()) return false;
  }
  return true;
}

void RouteRequest::Swap(RouteRequest* other) {
  if (other != this) {
    std::swap(origin_, other->origin_);
    std::swap(destination_, other->destination_);
    std::swap(style_, other->style_);
    std::swap(option_, other->option_);
    std::swap(max_route_number_, other->max_route_number_);
    std::swap(heading_, other->heading_);
    std::swap(speed_in_mps_, other->speed_in_mps_);
    dest_candidate_.Swap(&other->dest_candidate_);
    std::swap(output_option_, other->output_option_);
    std::swap(deviation_count_, other->deviation_count_);
    std::swap(data_set_, other->data_set_);
    std::swap(context_, other->context_);
    std::swap(route_start_time_, other->route_start_time_);
    std::swap(use_time_restriction_for_road_, other->use_time_restriction_for_road_);
    std::swap(eco_mode_, other->eco_mode_);
    waypoint_.Swap(&other->waypoint_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RouteRequest::GetTypeName() const {
  return "com.telenav.proto.map.RouteRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int RouteOption::kAvoidHovLaneFieldNumber;
const int RouteOption::kAvoidHighwayFieldNumber;
const int RouteOption::kAvoidTollRoadFieldNumber;
const int RouteOption::kAvoidFerryFieldNumber;
const int RouteOption::kAvoidCarTrainFieldNumber;
const int RouteOption::kAvoidUnpavedRoadFieldNumber;
const int RouteOption::kAvoidTunnelFieldNumber;
const int RouteOption::kAvoidUturnFieldNumber;
const int RouteOption::kAvoidTrafficFieldNumber;
const int RouteOption::kMustAvoidEdgeIdFieldNumber;
const int RouteOption::kTryAvoidEdgeIdFieldNumber;
const int RouteOption::kPreferredEdgeIdFieldNumber;
const int RouteOption::kAvoidTrafficIdFieldNumber;
#endif  // !_MSC_VER

RouteOption::RouteOption()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RouteOption::InitAsDefaultInstance() {
}

RouteOption::RouteOption(const RouteOption& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RouteOption::SharedCtor() {
  _cached_size_ = 0;
  avoid_hov_lane_ = false;
  avoid_highway_ = false;
  avoid_toll_road_ = false;
  avoid_ferry_ = false;
  avoid_car_train_ = false;
  avoid_unpaved_road_ = false;
  avoid_tunnel_ = false;
  avoid_uturn_ = false;
  avoid_traffic_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RouteOption::~RouteOption() {
  SharedDtor();
}

void RouteOption::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RouteOption::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RouteOption& RouteOption::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

RouteOption* RouteOption::default_instance_ = NULL;

RouteOption* RouteOption::New() const {
  return new RouteOption;
}

void RouteOption::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    avoid_hov_lane_ = false;
    avoid_highway_ = false;
    avoid_toll_road_ = false;
    avoid_ferry_ = false;
    avoid_car_train_ = false;
    avoid_unpaved_road_ = false;
    avoid_tunnel_ = false;
    avoid_uturn_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    avoid_traffic_ = false;
  }
  must_avoid_edge_id_.Clear();
  try_avoid_edge_id_.Clear();
  preferred_edge_id_.Clear();
  avoid_traffic_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RouteOption::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool avoid_hov_lane = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &avoid_hov_lane_)));
          set_has_avoid_hov_lane();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_avoid_highway;
        break;
      }

      // optional bool avoid_highway = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_avoid_highway:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &avoid_highway_)));
          set_has_avoid_highway();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_avoid_toll_road;
        break;
      }

      // optional bool avoid_toll_road = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_avoid_toll_road:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &avoid_toll_road_)));
          set_has_avoid_toll_road();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_avoid_ferry;
        break;
      }

      // optional bool avoid_ferry = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_avoid_ferry:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &avoid_ferry_)));
          set_has_avoid_ferry();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_avoid_car_train;
        break;
      }

      // optional bool avoid_car_train = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_avoid_car_train:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &avoid_car_train_)));
          set_has_avoid_car_train();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_avoid_unpaved_road;
        break;
      }

      // optional bool avoid_unpaved_road = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_avoid_unpaved_road:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &avoid_unpaved_road_)));
          set_has_avoid_unpaved_road();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_avoid_tunnel;
        break;
      }

      // optional bool avoid_tunnel = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_avoid_tunnel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &avoid_tunnel_)));
          set_has_avoid_tunnel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_avoid_uturn;
        break;
      }

      // optional bool avoid_uturn = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_avoid_uturn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &avoid_uturn_)));
          set_has_avoid_uturn();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_avoid_traffic;
        break;
      }

      // optional bool avoid_traffic = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_avoid_traffic:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &avoid_traffic_)));
          set_has_avoid_traffic();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_must_avoid_edge_id;
        break;
      }

      // repeated int64 must_avoid_edge_id = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_must_avoid_edge_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 80, input, this->mutable_must_avoid_edge_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_must_avoid_edge_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_must_avoid_edge_id;
        if (input->ExpectTag(88)) goto parse_try_avoid_edge_Id;
        break;
      }

      // repeated int64 try_avoid_edge_Id = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_try_avoid_edge_Id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 88, input, this->mutable_try_avoid_edge_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_try_avoid_edge_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_try_avoid_edge_Id;
        if (input->ExpectTag(96)) goto parse_preferred_edge_Id;
        break;
      }

      // repeated int64 preferred_edge_Id = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_preferred_edge_Id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 96, input, this->mutable_preferred_edge_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_preferred_edge_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_preferred_edge_Id;
        if (input->ExpectTag(106)) goto parse_avoid_traffic_id;
        break;
      }

      // repeated string avoid_traffic_id = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_avoid_traffic_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_avoid_traffic_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_avoid_traffic_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RouteOption::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool avoid_hov_lane = 1;
  if (has_avoid_hov_lane()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->avoid_hov_lane(), output);
  }

  // optional bool avoid_highway = 2;
  if (has_avoid_highway()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->avoid_highway(), output);
  }

  // optional bool avoid_toll_road = 3;
  if (has_avoid_toll_road()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->avoid_toll_road(), output);
  }

  // optional bool avoid_ferry = 4;
  if (has_avoid_ferry()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->avoid_ferry(), output);
  }

  // optional bool avoid_car_train = 5;
  if (has_avoid_car_train()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->avoid_car_train(), output);
  }

  // optional bool avoid_unpaved_road = 6;
  if (has_avoid_unpaved_road()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->avoid_unpaved_road(), output);
  }

  // optional bool avoid_tunnel = 7;
  if (has_avoid_tunnel()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->avoid_tunnel(), output);
  }

  // optional bool avoid_uturn = 8;
  if (has_avoid_uturn()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->avoid_uturn(), output);
  }

  // optional bool avoid_traffic = 9;
  if (has_avoid_traffic()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->avoid_traffic(), output);
  }

  // repeated int64 must_avoid_edge_id = 10;
  for (int i = 0; i < this->must_avoid_edge_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      10, this->must_avoid_edge_id(i), output);
  }

  // repeated int64 try_avoid_edge_Id = 11;
  for (int i = 0; i < this->try_avoid_edge_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      11, this->try_avoid_edge_id(i), output);
  }

  // repeated int64 preferred_edge_Id = 12;
  for (int i = 0; i < this->preferred_edge_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      12, this->preferred_edge_id(i), output);
  }

  // repeated string avoid_traffic_id = 13;
  for (int i = 0; i < this->avoid_traffic_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->avoid_traffic_id(i), output);
  }

}

int RouteOption::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool avoid_hov_lane = 1;
    if (has_avoid_hov_lane()) {
      total_size += 1 + 1;
    }

    // optional bool avoid_highway = 2;
    if (has_avoid_highway()) {
      total_size += 1 + 1;
    }

    // optional bool avoid_toll_road = 3;
    if (has_avoid_toll_road()) {
      total_size += 1 + 1;
    }

    // optional bool avoid_ferry = 4;
    if (has_avoid_ferry()) {
      total_size += 1 + 1;
    }

    // optional bool avoid_car_train = 5;
    if (has_avoid_car_train()) {
      total_size += 1 + 1;
    }

    // optional bool avoid_unpaved_road = 6;
    if (has_avoid_unpaved_road()) {
      total_size += 1 + 1;
    }

    // optional bool avoid_tunnel = 7;
    if (has_avoid_tunnel()) {
      total_size += 1 + 1;
    }

    // optional bool avoid_uturn = 8;
    if (has_avoid_uturn()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool avoid_traffic = 9;
    if (has_avoid_traffic()) {
      total_size += 1 + 1;
    }

  }
  // repeated int64 must_avoid_edge_id = 10;
  {
    int data_size = 0;
    for (int i = 0; i < this->must_avoid_edge_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->must_avoid_edge_id(i));
    }
    total_size += 1 * this->must_avoid_edge_id_size() + data_size;
  }

  // repeated int64 try_avoid_edge_Id = 11;
  {
    int data_size = 0;
    for (int i = 0; i < this->try_avoid_edge_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->try_avoid_edge_id(i));
    }
    total_size += 1 * this->try_avoid_edge_id_size() + data_size;
  }

  // repeated int64 preferred_edge_Id = 12;
  {
    int data_size = 0;
    for (int i = 0; i < this->preferred_edge_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->preferred_edge_id(i));
    }
    total_size += 1 * this->preferred_edge_id_size() + data_size;
  }

  // repeated string avoid_traffic_id = 13;
  total_size += 1 * this->avoid_traffic_id_size();
  for (int i = 0; i < this->avoid_traffic_id_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->avoid_traffic_id(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RouteOption::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RouteOption*>(&from));
}

void RouteOption::MergeFrom(const RouteOption& from) {
  GOOGLE_CHECK_NE(&from, this);
  must_avoid_edge_id_.MergeFrom(from.must_avoid_edge_id_);
  try_avoid_edge_id_.MergeFrom(from.try_avoid_edge_id_);
  preferred_edge_id_.MergeFrom(from.preferred_edge_id_);
  avoid_traffic_id_.MergeFrom(from.avoid_traffic_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_avoid_hov_lane()) {
      set_avoid_hov_lane(from.avoid_hov_lane());
    }
    if (from.has_avoid_highway()) {
      set_avoid_highway(from.avoid_highway());
    }
    if (from.has_avoid_toll_road()) {
      set_avoid_toll_road(from.avoid_toll_road());
    }
    if (from.has_avoid_ferry()) {
      set_avoid_ferry(from.avoid_ferry());
    }
    if (from.has_avoid_car_train()) {
      set_avoid_car_train(from.avoid_car_train());
    }
    if (from.has_avoid_unpaved_road()) {
      set_avoid_unpaved_road(from.avoid_unpaved_road());
    }
    if (from.has_avoid_tunnel()) {
      set_avoid_tunnel(from.avoid_tunnel());
    }
    if (from.has_avoid_uturn()) {
      set_avoid_uturn(from.avoid_uturn());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_avoid_traffic()) {
      set_avoid_traffic(from.avoid_traffic());
    }
  }
}

void RouteOption::CopyFrom(const RouteOption& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteOption::IsInitialized() const {

  return true;
}

void RouteOption::Swap(RouteOption* other) {
  if (other != this) {
    std::swap(avoid_hov_lane_, other->avoid_hov_lane_);
    std::swap(avoid_highway_, other->avoid_highway_);
    std::swap(avoid_toll_road_, other->avoid_toll_road_);
    std::swap(avoid_ferry_, other->avoid_ferry_);
    std::swap(avoid_car_train_, other->avoid_car_train_);
    std::swap(avoid_unpaved_road_, other->avoid_unpaved_road_);
    std::swap(avoid_tunnel_, other->avoid_tunnel_);
    std::swap(avoid_uturn_, other->avoid_uturn_);
    std::swap(avoid_traffic_, other->avoid_traffic_);
    must_avoid_edge_id_.Swap(&other->must_avoid_edge_id_);
    try_avoid_edge_id_.Swap(&other->try_avoid_edge_id_);
    preferred_edge_id_.Swap(&other->preferred_edge_id_);
    avoid_traffic_id_.Swap(&other->avoid_traffic_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RouteOption::GetTypeName() const {
  return "com.telenav.proto.map.RouteOption";
}


// ===================================================================

#ifndef _MSC_VER
const int Location::kLatLonFieldNumber;
const int Location::kAddressFieldNumber;
const int Location::kEdgeIdFieldNumber;
#endif  // !_MSC_VER

Location::Location()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Location::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  lat_lon_ = const_cast< ::com::telenav::proto::LatLon*>(
      ::com::telenav::proto::LatLon::internal_default_instance());
#else
  lat_lon_ = const_cast< ::com::telenav::proto::LatLon*>(&::com::telenav::proto::LatLon::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  address_ = const_cast< ::com::telenav::proto::Address*>(
      ::com::telenav::proto::Address::internal_default_instance());
#else
  address_ = const_cast< ::com::telenav::proto::Address*>(&::com::telenav::proto::Address::default_instance());
#endif
}

Location::Location(const Location& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Location::SharedCtor() {
  _cached_size_ = 0;
  lat_lon_ = NULL;
  address_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Location::~Location() {
  SharedDtor();
}

void Location::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete lat_lon_;
    delete address_;
  }
}

void Location::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Location& Location::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

Location* Location::default_instance_ = NULL;

Location* Location::New() const {
  return new Location;
}

void Location::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_lat_lon()) {
      if (lat_lon_ != NULL) lat_lon_->::com::telenav::proto::LatLon::Clear();
    }
    if (has_address()) {
      if (address_ != NULL) address_->::com::telenav::proto::Address::Clear();
    }
  }
  edge_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Location::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.telenav.proto.LatLon lat_lon = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lat_lon()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_address;
        break;
      }

      // optional .com.telenav.proto.Address address = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_edge_id;
        break;
      }

      // repeated int64 edge_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_edge_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 24, input, this->mutable_edge_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_edge_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_edge_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Location::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .com.telenav.proto.LatLon lat_lon = 1;
  if (has_lat_lon()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->lat_lon(), output);
  }

  // optional .com.telenav.proto.Address address = 2;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->address(), output);
  }

  // repeated int64 edge_id = 3;
  for (int i = 0; i < this->edge_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      3, this->edge_id(i), output);
  }

}

int Location::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .com.telenav.proto.LatLon lat_lon = 1;
    if (has_lat_lon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lat_lon());
    }

    // optional .com.telenav.proto.Address address = 2;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->address());
    }

  }
  // repeated int64 edge_id = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->edge_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->edge_id(i));
    }
    total_size += 1 * this->edge_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Location::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Location*>(&from));
}

void Location::MergeFrom(const Location& from) {
  GOOGLE_CHECK_NE(&from, this);
  edge_id_.MergeFrom(from.edge_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lat_lon()) {
      mutable_lat_lon()->::com::telenav::proto::LatLon::MergeFrom(from.lat_lon());
    }
    if (from.has_address()) {
      mutable_address()->::com::telenav::proto::Address::MergeFrom(from.address());
    }
  }
}

void Location::CopyFrom(const Location& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Location::IsInitialized() const {

  if (has_lat_lon()) {
    if (!this->lat_lon().IsInitialized()) return false;
  }
  return true;
}

void Location::Swap(Location* other) {
  if (other != this) {
    std::swap(lat_lon_, other->lat_lon_);
    std::swap(address_, other->address_);
    edge_id_.Swap(&other->edge_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Location::GetTypeName() const {
  return "com.telenav.proto.map.Location";
}


// ===================================================================

#ifndef _MSC_VER
const int OutputOption::kEtaOnlyFieldNumber;
const int OutputOption::kEdgeDetailFieldNumber;
const int OutputOption::kBasicRouteFieldNumber;
const int OutputOption::kTrafficIdFieldNumber;
const int OutputOption::kLaneInfoFieldNumber;
const int OutputOption::kSpeedLimitFieldNumber;
const int OutputOption::kOverviewFieldNumber;
const int OutputOption::kRouteInfoFieldNumber;
const int OutputOption::kOverviewDecimatedLevelFieldNumber;
#endif  // !_MSC_VER

OutputOption::OutputOption()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OutputOption::InitAsDefaultInstance() {
}

OutputOption::OutputOption(const OutputOption& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OutputOption::SharedCtor() {
  _cached_size_ = 0;
  eta_only_ = false;
  edge_detail_ = false;
  basic_route_ = false;
  traffic_id_ = true;
  lane_info_ = true;
  speed_limit_ = true;
  overview_ = false;
  route_info_ = true;
  overview_decimated_level_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OutputOption::~OutputOption() {
  SharedDtor();
}

void OutputOption::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OutputOption::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OutputOption& OutputOption::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

OutputOption* OutputOption::default_instance_ = NULL;

OutputOption* OutputOption::New() const {
  return new OutputOption;
}

void OutputOption::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    eta_only_ = false;
    edge_detail_ = false;
    basic_route_ = false;
    traffic_id_ = true;
    lane_info_ = true;
    speed_limit_ = true;
    overview_ = false;
    route_info_ = true;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    overview_decimated_level_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OutputOption::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool eta_only = 1 [default = false];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &eta_only_)));
          set_has_eta_only();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_edge_detail;
        break;
      }

      // optional bool edge_detail = 2 [default = false];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_edge_detail:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &edge_detail_)));
          set_has_edge_detail();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_basic_route;
        break;
      }

      // optional bool basic_route = 3 [default = false];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_basic_route:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &basic_route_)));
          set_has_basic_route();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_traffic_id;
        break;
      }

      // optional bool traffic_id = 4 [default = true];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_traffic_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &traffic_id_)));
          set_has_traffic_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_lane_info;
        break;
      }

      // optional bool lane_info = 5 [default = true];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lane_info:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lane_info_)));
          set_has_lane_info();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_speed_limit;
        break;
      }

      // optional bool speed_limit = 6 [default = true];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_speed_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &speed_limit_)));
          set_has_speed_limit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_overview;
        break;
      }

      // optional bool overview = 9 [default = false];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_overview:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &overview_)));
          set_has_overview();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_route_info;
        break;
      }

      // optional bool route_info = 10 [default = true];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_route_info:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &route_info_)));
          set_has_route_info();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_overview_decimated_level;
        break;
      }

      // optional int32 overview_decimated_level = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_overview_decimated_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &overview_decimated_level_)));
          set_has_overview_decimated_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OutputOption::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool eta_only = 1 [default = false];
  if (has_eta_only()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->eta_only(), output);
  }

  // optional bool edge_detail = 2 [default = false];
  if (has_edge_detail()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->edge_detail(), output);
  }

  // optional bool basic_route = 3 [default = false];
  if (has_basic_route()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->basic_route(), output);
  }

  // optional bool traffic_id = 4 [default = true];
  if (has_traffic_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->traffic_id(), output);
  }

  // optional bool lane_info = 5 [default = true];
  if (has_lane_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->lane_info(), output);
  }

  // optional bool speed_limit = 6 [default = true];
  if (has_speed_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->speed_limit(), output);
  }

  // optional bool overview = 9 [default = false];
  if (has_overview()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->overview(), output);
  }

  // optional bool route_info = 10 [default = true];
  if (has_route_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->route_info(), output);
  }

  // optional int32 overview_decimated_level = 11;
  if (has_overview_decimated_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->overview_decimated_level(), output);
  }

}

int OutputOption::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool eta_only = 1 [default = false];
    if (has_eta_only()) {
      total_size += 1 + 1;
    }

    // optional bool edge_detail = 2 [default = false];
    if (has_edge_detail()) {
      total_size += 1 + 1;
    }

    // optional bool basic_route = 3 [default = false];
    if (has_basic_route()) {
      total_size += 1 + 1;
    }

    // optional bool traffic_id = 4 [default = true];
    if (has_traffic_id()) {
      total_size += 1 + 1;
    }

    // optional bool lane_info = 5 [default = true];
    if (has_lane_info()) {
      total_size += 1 + 1;
    }

    // optional bool speed_limit = 6 [default = true];
    if (has_speed_limit()) {
      total_size += 1 + 1;
    }

    // optional bool overview = 9 [default = false];
    if (has_overview()) {
      total_size += 1 + 1;
    }

    // optional bool route_info = 10 [default = true];
    if (has_route_info()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 overview_decimated_level = 11;
    if (has_overview_decimated_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->overview_decimated_level());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OutputOption::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OutputOption*>(&from));
}

void OutputOption::MergeFrom(const OutputOption& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_eta_only()) {
      set_eta_only(from.eta_only());
    }
    if (from.has_edge_detail()) {
      set_edge_detail(from.edge_detail());
    }
    if (from.has_basic_route()) {
      set_basic_route(from.basic_route());
    }
    if (from.has_traffic_id()) {
      set_traffic_id(from.traffic_id());
    }
    if (from.has_lane_info()) {
      set_lane_info(from.lane_info());
    }
    if (from.has_speed_limit()) {
      set_speed_limit(from.speed_limit());
    }
    if (from.has_overview()) {
      set_overview(from.overview());
    }
    if (from.has_route_info()) {
      set_route_info(from.route_info());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_overview_decimated_level()) {
      set_overview_decimated_level(from.overview_decimated_level());
    }
  }
}

void OutputOption::CopyFrom(const OutputOption& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OutputOption::IsInitialized() const {

  return true;
}

void OutputOption::Swap(OutputOption* other) {
  if (other != this) {
    std::swap(eta_only_, other->eta_only_);
    std::swap(edge_detail_, other->edge_detail_);
    std::swap(basic_route_, other->basic_route_);
    std::swap(traffic_id_, other->traffic_id_);
    std::swap(lane_info_, other->lane_info_);
    std::swap(speed_limit_, other->speed_limit_);
    std::swap(overview_, other->overview_);
    std::swap(route_info_, other->route_info_);
    std::swap(overview_decimated_level_, other->overview_decimated_level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OutputOption::GetTypeName() const {
  return "com.telenav.proto.map.OutputOption";
}


// ===================================================================

#ifndef _MSC_VER
const int GuidanceRequest::kBasicPathFieldNumber;
const int GuidanceRequest::kStartIndexFieldNumber;
const int GuidanceRequest::kEndIndexFieldNumber;
const int GuidanceRequest::kLengthInMeterFieldNumber;
#endif  // !_MSC_VER

GuidanceRequest::GuidanceRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GuidanceRequest::InitAsDefaultInstance() {
}

GuidanceRequest::GuidanceRequest(const GuidanceRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GuidanceRequest::SharedCtor() {
  _cached_size_ = 0;
  start_index_ = 0;
  end_index_ = 0;
  length_in_meter_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GuidanceRequest::~GuidanceRequest() {
  SharedDtor();
}

void GuidanceRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GuidanceRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GuidanceRequest& GuidanceRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

GuidanceRequest* GuidanceRequest::default_instance_ = NULL;

GuidanceRequest* GuidanceRequest::New() const {
  return new GuidanceRequest;
}

void GuidanceRequest::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    start_index_ = 0;
    end_index_ = 0;
    length_in_meter_ = 0;
  }
  basic_path_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GuidanceRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.BasicPath basic_path = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_basic_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_basic_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_basic_path;
        if (input->ExpectTag(16)) goto parse_start_index;
        break;
      }

      // optional int32 start_index = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_index_)));
          set_has_start_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_end_index;
        break;
      }

      // optional int32 end_index = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &end_index_)));
          set_has_end_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_length_in_meter;
        break;
      }

      // optional int32 length_in_meter = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_length_in_meter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &length_in_meter_)));
          set_has_length_in_meter();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GuidanceRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.BasicPath basic_path = 1;
  for (int i = 0; i < this->basic_path_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->basic_path(i), output);
  }

  // optional int32 start_index = 2;
  if (has_start_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->start_index(), output);
  }

  // optional int32 end_index = 3;
  if (has_end_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->end_index(), output);
  }

  // optional int32 length_in_meter = 4;
  if (has_length_in_meter()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->length_in_meter(), output);
  }

}

int GuidanceRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 start_index = 2;
    if (has_start_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->start_index());
    }

    // optional int32 end_index = 3;
    if (has_end_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->end_index());
    }

    // optional int32 length_in_meter = 4;
    if (has_length_in_meter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->length_in_meter());
    }

  }
  // repeated .com.telenav.proto.map.BasicPath basic_path = 1;
  total_size += 1 * this->basic_path_size();
  for (int i = 0; i < this->basic_path_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->basic_path(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GuidanceRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GuidanceRequest*>(&from));
}

void GuidanceRequest::MergeFrom(const GuidanceRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  basic_path_.MergeFrom(from.basic_path_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_start_index()) {
      set_start_index(from.start_index());
    }
    if (from.has_end_index()) {
      set_end_index(from.end_index());
    }
    if (from.has_length_in_meter()) {
      set_length_in_meter(from.length_in_meter());
    }
  }
}

void GuidanceRequest::CopyFrom(const GuidanceRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuidanceRequest::IsInitialized() const {

  return true;
}

void GuidanceRequest::Swap(GuidanceRequest* other) {
  if (other != this) {
    basic_path_.Swap(&other->basic_path_);
    std::swap(start_index_, other->start_index_);
    std::swap(end_index_, other->end_index_);
    std::swap(length_in_meter_, other->length_in_meter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GuidanceRequest::GetTypeName() const {
  return "com.telenav.proto.map.GuidanceRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int BasicRouteResponse::kStatusFieldNumber;
const int BasicRouteResponse::kDataVersionFieldNumber;
const int BasicRouteResponse::kRouteInfoFieldNumber;
const int BasicRouteResponse::kRouteFieldNumber;
#endif  // !_MSC_VER

BasicRouteResponse::BasicRouteResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BasicRouteResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  status_ = const_cast< ::com::telenav::proto::ServiceStatus*>(
      ::com::telenav::proto::ServiceStatus::internal_default_instance());
#else
  status_ = const_cast< ::com::telenav::proto::ServiceStatus*>(&::com::telenav::proto::ServiceStatus::default_instance());
#endif
}

BasicRouteResponse::BasicRouteResponse(const BasicRouteResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BasicRouteResponse::SharedCtor() {
  _cached_size_ = 0;
  status_ = NULL;
  data_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BasicRouteResponse::~BasicRouteResponse() {
  SharedDtor();
}

void BasicRouteResponse::SharedDtor() {
  if (data_version_ != &::google::protobuf::internal::kEmptyString) {
    delete data_version_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete status_;
  }
}

void BasicRouteResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BasicRouteResponse& BasicRouteResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

BasicRouteResponse* BasicRouteResponse::default_instance_ = NULL;

BasicRouteResponse* BasicRouteResponse::New() const {
  return new BasicRouteResponse;
}

void BasicRouteResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_status()) {
      if (status_ != NULL) status_->::com::telenav::proto::ServiceStatus::Clear();
    }
    if (has_data_version()) {
      if (data_version_ != &::google::protobuf::internal::kEmptyString) {
        data_version_->clear();
      }
    }
  }
  route_info_.Clear();
  route_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BasicRouteResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.telenav.proto.ServiceStatus status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data_version;
        break;
      }

      // optional string data_version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_route_info;
        break;
      }

      // repeated .com.telenav.proto.map.RouteInfo route_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_route_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_route_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_route_info;
        if (input->ExpectTag(42)) goto parse_route;
        break;
      }

      // repeated .com.telenav.proto.map.BasicRoute route = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_route:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_route()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_route;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BasicRouteResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .com.telenav.proto.ServiceStatus status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->status(), output);
  }

  // optional string data_version = 3;
  if (has_data_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->data_version(), output);
  }

  // repeated .com.telenav.proto.map.RouteInfo route_info = 4;
  for (int i = 0; i < this->route_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->route_info(i), output);
  }

  // repeated .com.telenav.proto.map.BasicRoute route = 5;
  for (int i = 0; i < this->route_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->route(i), output);
  }

}

int BasicRouteResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .com.telenav.proto.ServiceStatus status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }

    // optional string data_version = 3;
    if (has_data_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->data_version());
    }

  }
  // repeated .com.telenav.proto.map.RouteInfo route_info = 4;
  total_size += 1 * this->route_info_size();
  for (int i = 0; i < this->route_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->route_info(i));
  }

  // repeated .com.telenav.proto.map.BasicRoute route = 5;
  total_size += 1 * this->route_size();
  for (int i = 0; i < this->route_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->route(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BasicRouteResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BasicRouteResponse*>(&from));
}

void BasicRouteResponse::MergeFrom(const BasicRouteResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  route_info_.MergeFrom(from.route_info_);
  route_.MergeFrom(from.route_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      mutable_status()->::com::telenav::proto::ServiceStatus::MergeFrom(from.status());
    }
    if (from.has_data_version()) {
      set_data_version(from.data_version());
    }
  }
}

void BasicRouteResponse::CopyFrom(const BasicRouteResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BasicRouteResponse::IsInitialized() const {

  if (has_status()) {
    if (!this->status().IsInitialized()) return false;
  }
  return true;
}

void BasicRouteResponse::Swap(BasicRouteResponse* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(data_version_, other->data_version_);
    route_info_.Swap(&other->route_info_);
    route_.Swap(&other->route_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BasicRouteResponse::GetTypeName() const {
  return "com.telenav.proto.map.BasicRouteResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RouteResponse::kStatusFieldNumber;
const int RouteResponse::kDataVersionFieldNumber;
const int RouteResponse::kRouteFieldNumber;
#endif  // !_MSC_VER

RouteResponse::RouteResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RouteResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  status_ = const_cast< ::com::telenav::proto::ServiceStatus*>(
      ::com::telenav::proto::ServiceStatus::internal_default_instance());
#else
  status_ = const_cast< ::com::telenav::proto::ServiceStatus*>(&::com::telenav::proto::ServiceStatus::default_instance());
#endif
}

RouteResponse::RouteResponse(const RouteResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RouteResponse::SharedCtor() {
  _cached_size_ = 0;
  status_ = NULL;
  data_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RouteResponse::~RouteResponse() {
  SharedDtor();
}

void RouteResponse::SharedDtor() {
  if (data_version_ != &::google::protobuf::internal::kEmptyString) {
    delete data_version_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete status_;
  }
}

void RouteResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RouteResponse& RouteResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

RouteResponse* RouteResponse::default_instance_ = NULL;

RouteResponse* RouteResponse::New() const {
  return new RouteResponse;
}

void RouteResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_status()) {
      if (status_ != NULL) status_->::com::telenav::proto::ServiceStatus::Clear();
    }
    if (has_data_version()) {
      if (data_version_ != &::google::protobuf::internal::kEmptyString) {
        data_version_->clear();
      }
    }
  }
  route_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RouteResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.telenav.proto.ServiceStatus status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data_version;
        break;
      }

      // optional string data_version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_route;
        break;
      }

      // repeated .com.telenav.proto.map.Route route = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_route:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_route()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_route;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RouteResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .com.telenav.proto.ServiceStatus status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->status(), output);
  }

  // optional string data_version = 3;
  if (has_data_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->data_version(), output);
  }

  // repeated .com.telenav.proto.map.Route route = 4;
  for (int i = 0; i < this->route_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->route(i), output);
  }

}

int RouteResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .com.telenav.proto.ServiceStatus status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }

    // optional string data_version = 3;
    if (has_data_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->data_version());
    }

  }
  // repeated .com.telenav.proto.map.Route route = 4;
  total_size += 1 * this->route_size();
  for (int i = 0; i < this->route_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->route(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RouteResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RouteResponse*>(&from));
}

void RouteResponse::MergeFrom(const RouteResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  route_.MergeFrom(from.route_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      mutable_status()->::com::telenav::proto::ServiceStatus::MergeFrom(from.status());
    }
    if (from.has_data_version()) {
      set_data_version(from.data_version());
    }
  }
}

void RouteResponse::CopyFrom(const RouteResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteResponse::IsInitialized() const {

  if (has_status()) {
    if (!this->status().IsInitialized()) return false;
  }
  return true;
}

void RouteResponse::Swap(RouteResponse* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(data_version_, other->data_version_);
    route_.Swap(&other->route_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RouteResponse::GetTypeName() const {
  return "com.telenav.proto.map.RouteResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int FindMeRequest::kGpsFixFieldNumber;
const int FindMeRequest::kLatchHeadingFieldNumber;
const int FindMeRequest::kContextFieldNumber;
#endif  // !_MSC_VER

FindMeRequest::FindMeRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FindMeRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  context_ = const_cast< ::com::telenav::proto::Context*>(
      ::com::telenav::proto::Context::internal_default_instance());
#else
  context_ = const_cast< ::com::telenav::proto::Context*>(&::com::telenav::proto::Context::default_instance());
#endif
}

FindMeRequest::FindMeRequest(const FindMeRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FindMeRequest::SharedCtor() {
  _cached_size_ = 0;
  latch_heading_ = -999;
  context_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FindMeRequest::~FindMeRequest() {
  SharedDtor();
}

void FindMeRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete context_;
  }
}

void FindMeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindMeRequest& FindMeRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

FindMeRequest* FindMeRequest::default_instance_ = NULL;

FindMeRequest* FindMeRequest::New() const {
  return new FindMeRequest;
}

void FindMeRequest::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    latch_heading_ = -999;
    if (has_context()) {
      if (context_ != NULL) context_->::com::telenav::proto::Context::Clear();
    }
  }
  gps_fix_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FindMeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.GpsFix gps_fix = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gps_fix:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_gps_fix()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_gps_fix;
        if (input->ExpectTag(16)) goto parse_latch_heading;
        break;
      }

      // optional int32 latch_heading = 2 [default = -999];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_latch_heading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &latch_heading_)));
          set_has_latch_heading();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_context;
        break;
      }

      // optional .com.telenav.proto.Context context = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_context:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_context()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FindMeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.GpsFix gps_fix = 1;
  for (int i = 0; i < this->gps_fix_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->gps_fix(i), output);
  }

  // optional int32 latch_heading = 2 [default = -999];
  if (has_latch_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->latch_heading(), output);
  }

  // optional .com.telenav.proto.Context context = 3;
  if (has_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->context(), output);
  }

}

int FindMeRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 latch_heading = 2 [default = -999];
    if (has_latch_heading()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->latch_heading());
    }

    // optional .com.telenav.proto.Context context = 3;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->context());
    }

  }
  // repeated .com.telenav.proto.map.GpsFix gps_fix = 1;
  total_size += 1 * this->gps_fix_size();
  for (int i = 0; i < this->gps_fix_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->gps_fix(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FindMeRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FindMeRequest*>(&from));
}

void FindMeRequest::MergeFrom(const FindMeRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  gps_fix_.MergeFrom(from.gps_fix_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_latch_heading()) {
      set_latch_heading(from.latch_heading());
    }
    if (from.has_context()) {
      mutable_context()->::com::telenav::proto::Context::MergeFrom(from.context());
    }
  }
}

void FindMeRequest::CopyFrom(const FindMeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindMeRequest::IsInitialized() const {

  if (has_context()) {
    if (!this->context().IsInitialized()) return false;
  }
  return true;
}

void FindMeRequest::Swap(FindMeRequest* other) {
  if (other != this) {
    gps_fix_.Swap(&other->gps_fix_);
    std::swap(latch_heading_, other->latch_heading_);
    std::swap(context_, other->context_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FindMeRequest::GetTypeName() const {
  return "com.telenav.proto.map.FindMeRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int FindMeResponse::kStatusFieldNumber;
const int FindMeResponse::kDataVersionFieldNumber;
const int FindMeResponse::kCandidateFieldNumber;
#endif  // !_MSC_VER

FindMeResponse::FindMeResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FindMeResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  status_ = const_cast< ::com::telenav::proto::ServiceStatus*>(
      ::com::telenav::proto::ServiceStatus::internal_default_instance());
#else
  status_ = const_cast< ::com::telenav::proto::ServiceStatus*>(&::com::telenav::proto::ServiceStatus::default_instance());
#endif
}

FindMeResponse::FindMeResponse(const FindMeResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FindMeResponse::SharedCtor() {
  _cached_size_ = 0;
  status_ = NULL;
  data_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FindMeResponse::~FindMeResponse() {
  SharedDtor();
}

void FindMeResponse::SharedDtor() {
  if (data_version_ != &::google::protobuf::internal::kEmptyString) {
    delete data_version_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete status_;
  }
}

void FindMeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindMeResponse& FindMeResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

FindMeResponse* FindMeResponse::default_instance_ = NULL;

FindMeResponse* FindMeResponse::New() const {
  return new FindMeResponse;
}

void FindMeResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_status()) {
      if (status_ != NULL) status_->::com::telenav::proto::ServiceStatus::Clear();
    }
    if (has_data_version()) {
      if (data_version_ != &::google::protobuf::internal::kEmptyString) {
        data_version_->clear();
      }
    }
  }
  candidate_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FindMeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.telenav.proto.ServiceStatus status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data_version;
        break;
      }

      // optional string data_version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_candidate;
        break;
      }

      // repeated .com.telenav.proto.map.Candidate candidate = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_candidate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_candidate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_candidate;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FindMeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .com.telenav.proto.ServiceStatus status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->status(), output);
  }

  // optional string data_version = 3;
  if (has_data_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->data_version(), output);
  }

  // repeated .com.telenav.proto.map.Candidate candidate = 4;
  for (int i = 0; i < this->candidate_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->candidate(i), output);
  }

}

int FindMeResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .com.telenav.proto.ServiceStatus status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }

    // optional string data_version = 3;
    if (has_data_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->data_version());
    }

  }
  // repeated .com.telenav.proto.map.Candidate candidate = 4;
  total_size += 1 * this->candidate_size();
  for (int i = 0; i < this->candidate_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->candidate(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FindMeResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FindMeResponse*>(&from));
}

void FindMeResponse::MergeFrom(const FindMeResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  candidate_.MergeFrom(from.candidate_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      mutable_status()->::com::telenav::proto::ServiceStatus::MergeFrom(from.status());
    }
    if (from.has_data_version()) {
      set_data_version(from.data_version());
    }
  }
}

void FindMeResponse::CopyFrom(const FindMeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindMeResponse::IsInitialized() const {

  if (has_status()) {
    if (!this->status().IsInitialized()) return false;
  }
  for (int i = 0; i < candidate_size(); i++) {
    if (!this->candidate(i).IsInitialized()) return false;
  }
  return true;
}

void FindMeResponse::Swap(FindMeResponse* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(data_version_, other->data_version_);
    candidate_.Swap(&other->candidate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FindMeResponse::GetTypeName() const {
  return "com.telenav.proto.map.FindMeResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int SystemInfoResponse::kStatusFieldNumber;
const int SystemInfoResponse::kAppVersionFieldNumber;
const int SystemInfoResponse::kDataVersionFieldNumber;
const int SystemInfoResponse::kUpTimeFieldNumber;
#endif  // !_MSC_VER

SystemInfoResponse::SystemInfoResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SystemInfoResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  status_ = const_cast< ::com::telenav::proto::ServiceStatus*>(
      ::com::telenav::proto::ServiceStatus::internal_default_instance());
#else
  status_ = const_cast< ::com::telenav::proto::ServiceStatus*>(&::com::telenav::proto::ServiceStatus::default_instance());
#endif
}

SystemInfoResponse::SystemInfoResponse(const SystemInfoResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SystemInfoResponse::SharedCtor() {
  _cached_size_ = 0;
  status_ = NULL;
  app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  data_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  up_time_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SystemInfoResponse::~SystemInfoResponse() {
  SharedDtor();
}

void SystemInfoResponse::SharedDtor() {
  if (app_version_ != &::google::protobuf::internal::kEmptyString) {
    delete app_version_;
  }
  if (data_version_ != &::google::protobuf::internal::kEmptyString) {
    delete data_version_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete status_;
  }
}

void SystemInfoResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SystemInfoResponse& SystemInfoResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

SystemInfoResponse* SystemInfoResponse::default_instance_ = NULL;

SystemInfoResponse* SystemInfoResponse::New() const {
  return new SystemInfoResponse;
}

void SystemInfoResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_status()) {
      if (status_ != NULL) status_->::com::telenav::proto::ServiceStatus::Clear();
    }
    if (has_app_version()) {
      if (app_version_ != &::google::protobuf::internal::kEmptyString) {
        app_version_->clear();
      }
    }
    if (has_data_version()) {
      if (data_version_ != &::google::protobuf::internal::kEmptyString) {
        data_version_->clear();
      }
    }
    up_time_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SystemInfoResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.telenav.proto.ServiceStatus status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_app_version;
        break;
      }

      // optional string app_version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_app_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_app_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data_version;
        break;
      }

      // optional string data_version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_up_time;
        break;
      }

      // optional int64 up_time = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_up_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &up_time_)));
          set_has_up_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SystemInfoResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .com.telenav.proto.ServiceStatus status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->status(), output);
  }

  // optional string app_version = 2;
  if (has_app_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->app_version(), output);
  }

  // optional string data_version = 3;
  if (has_data_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->data_version(), output);
  }

  // optional int64 up_time = 4;
  if (has_up_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->up_time(), output);
  }

}

int SystemInfoResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .com.telenav.proto.ServiceStatus status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }

    // optional string app_version = 2;
    if (has_app_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->app_version());
    }

    // optional string data_version = 3;
    if (has_data_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->data_version());
    }

    // optional int64 up_time = 4;
    if (has_up_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->up_time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SystemInfoResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SystemInfoResponse*>(&from));
}

void SystemInfoResponse::MergeFrom(const SystemInfoResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      mutable_status()->::com::telenav::proto::ServiceStatus::MergeFrom(from.status());
    }
    if (from.has_app_version()) {
      set_app_version(from.app_version());
    }
    if (from.has_data_version()) {
      set_data_version(from.data_version());
    }
    if (from.has_up_time()) {
      set_up_time(from.up_time());
    }
  }
}

void SystemInfoResponse::CopyFrom(const SystemInfoResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemInfoResponse::IsInitialized() const {

  if (has_status()) {
    if (!this->status().IsInitialized()) return false;
  }
  return true;
}

void SystemInfoResponse::Swap(SystemInfoResponse* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(app_version_, other->app_version_);
    std::swap(data_version_, other->data_version_);
    std::swap(up_time_, other->up_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SystemInfoResponse::GetTypeName() const {
  return "com.telenav.proto.map.SystemInfoResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int GpsFix::kLatFieldNumber;
const int GpsFix::kLonFieldNumber;
const int GpsFix::kAltFieldNumber;
const int GpsFix::kTimeStampFieldNumber;
const int GpsFix::kSpeedFieldNumber;
const int GpsFix::kHeadingFieldNumber;
const int GpsFix::kErrorFieldNumber;
#endif  // !_MSC_VER

GpsFix::GpsFix()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GpsFix::InitAsDefaultInstance() {
}

GpsFix::GpsFix(const GpsFix& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GpsFix::SharedCtor() {
  _cached_size_ = 0;
  lat_ = 0;
  lon_ = 0;
  alt_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  speed_ = 0;
  heading_ = 0;
  error_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GpsFix::~GpsFix() {
  SharedDtor();
}

void GpsFix::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GpsFix::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GpsFix& GpsFix::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

GpsFix* GpsFix::default_instance_ = NULL;

GpsFix* GpsFix::New() const {
  return new GpsFix;
}

void GpsFix::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    lat_ = 0;
    lon_ = 0;
    alt_ = 0;
    time_stamp_ = GOOGLE_LONGLONG(0);
    speed_ = 0;
    heading_ = 0;
    error_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GpsFix::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double lat = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lat_)));
          set_has_lat();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_lon;
        break;
      }

      // optional double lon = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_lon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lon_)));
          set_has_lon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_alt;
        break;
      }

      // optional double alt = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_alt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &alt_)));
          set_has_alt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_time_stamp;
        break;
      }

      // optional int64 time_stamp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_speed;
        break;
      }

      // optional int32 speed = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_heading;
        break;
      }

      // optional int32 heading = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_heading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
          set_has_heading();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_error;
        break;
      }

      // optional int32 error = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &error_)));
          set_has_error();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GpsFix::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional double lat = 1;
  if (has_lat()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->lat(), output);
  }

  // optional double lon = 2;
  if (has_lon()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->lon(), output);
  }

  // optional double alt = 3;
  if (has_alt()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->alt(), output);
  }

  // optional int64 time_stamp = 4;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->time_stamp(), output);
  }

  // optional int32 speed = 5;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->speed(), output);
  }

  // optional int32 heading = 6;
  if (has_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->heading(), output);
  }

  // optional int32 error = 7;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->error(), output);
  }

}

int GpsFix::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double lat = 1;
    if (has_lat()) {
      total_size += 1 + 8;
    }

    // optional double lon = 2;
    if (has_lon()) {
      total_size += 1 + 8;
    }

    // optional double alt = 3;
    if (has_alt()) {
      total_size += 1 + 8;
    }

    // optional int64 time_stamp = 4;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

    // optional int32 speed = 5;
    if (has_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->speed());
    }

    // optional int32 heading = 6;
    if (has_heading()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

    // optional int32 error = 7;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->error());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GpsFix::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GpsFix*>(&from));
}

void GpsFix::MergeFrom(const GpsFix& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lat()) {
      set_lat(from.lat());
    }
    if (from.has_lon()) {
      set_lon(from.lon());
    }
    if (from.has_alt()) {
      set_alt(from.alt());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_heading()) {
      set_heading(from.heading());
    }
    if (from.has_error()) {
      set_error(from.error());
    }
  }
}

void GpsFix::CopyFrom(const GpsFix& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GpsFix::IsInitialized() const {

  return true;
}

void GpsFix::Swap(GpsFix* other) {
  if (other != this) {
    std::swap(lat_, other->lat_);
    std::swap(lon_, other->lon_);
    std::swap(alt_, other->alt_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(speed_, other->speed_);
    std::swap(heading_, other->heading_);
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GpsFix::GetTypeName() const {
  return "com.telenav.proto.map.GpsFix";
}


// ===================================================================

#ifndef _MSC_VER
const int Candidate::kLatLonFieldNumber;
const int Candidate::kAddressFieldNumber;
const int Candidate::kHeadingFieldNumber;
const int Candidate::kSpeedInMpsFieldNumber;
#endif  // !_MSC_VER

Candidate::Candidate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Candidate::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  lat_lon_ = const_cast< ::com::telenav::proto::LatLon*>(
      ::com::telenav::proto::LatLon::internal_default_instance());
#else
  lat_lon_ = const_cast< ::com::telenav::proto::LatLon*>(&::com::telenav::proto::LatLon::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  address_ = const_cast< ::com::telenav::proto::Address*>(
      ::com::telenav::proto::Address::internal_default_instance());
#else
  address_ = const_cast< ::com::telenav::proto::Address*>(&::com::telenav::proto::Address::default_instance());
#endif
}

Candidate::Candidate(const Candidate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Candidate::SharedCtor() {
  _cached_size_ = 0;
  lat_lon_ = NULL;
  address_ = NULL;
  heading_ = 0;
  speed_in_mps_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Candidate::~Candidate() {
  SharedDtor();
}

void Candidate::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete lat_lon_;
    delete address_;
  }
}

void Candidate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Candidate& Candidate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

Candidate* Candidate::default_instance_ = NULL;

Candidate* Candidate::New() const {
  return new Candidate;
}

void Candidate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_lat_lon()) {
      if (lat_lon_ != NULL) lat_lon_->::com::telenav::proto::LatLon::Clear();
    }
    if (has_address()) {
      if (address_ != NULL) address_->::com::telenav::proto::Address::Clear();
    }
    heading_ = 0;
    speed_in_mps_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Candidate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.telenav.proto.LatLon lat_lon = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lat_lon()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_address;
        break;
      }

      // optional .com.telenav.proto.Address address = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_heading;
        break;
      }

      // optional int32 heading = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_heading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
          set_has_heading();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_speed_in_mps;
        break;
      }

      // optional int32 speed_in_mps = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_speed_in_mps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &speed_in_mps_)));
          set_has_speed_in_mps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Candidate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .com.telenav.proto.LatLon lat_lon = 1;
  if (has_lat_lon()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->lat_lon(), output);
  }

  // optional .com.telenav.proto.Address address = 2;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->address(), output);
  }

  // optional int32 heading = 3;
  if (has_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->heading(), output);
  }

  // optional int32 speed_in_mps = 4;
  if (has_speed_in_mps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->speed_in_mps(), output);
  }

}

int Candidate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .com.telenav.proto.LatLon lat_lon = 1;
    if (has_lat_lon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lat_lon());
    }

    // optional .com.telenav.proto.Address address = 2;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->address());
    }

    // optional int32 heading = 3;
    if (has_heading()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

    // optional int32 speed_in_mps = 4;
    if (has_speed_in_mps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->speed_in_mps());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Candidate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Candidate*>(&from));
}

void Candidate::MergeFrom(const Candidate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lat_lon()) {
      mutable_lat_lon()->::com::telenav::proto::LatLon::MergeFrom(from.lat_lon());
    }
    if (from.has_address()) {
      mutable_address()->::com::telenav::proto::Address::MergeFrom(from.address());
    }
    if (from.has_heading()) {
      set_heading(from.heading());
    }
    if (from.has_speed_in_mps()) {
      set_speed_in_mps(from.speed_in_mps());
    }
  }
}

void Candidate::CopyFrom(const Candidate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Candidate::IsInitialized() const {

  if (has_lat_lon()) {
    if (!this->lat_lon().IsInitialized()) return false;
  }
  return true;
}

void Candidate::Swap(Candidate* other) {
  if (other != this) {
    std::swap(lat_lon_, other->lat_lon_);
    std::swap(address_, other->address_);
    std::swap(heading_, other->heading_);
    std::swap(speed_in_mps_, other->speed_in_mps_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Candidate::GetTypeName() const {
  return "com.telenav.proto.map.Candidate";
}


// ===================================================================

#ifndef _MSC_VER
const int BasicRoute::kHeadPathFieldNumber;
const int BasicRoute::kBodyPathFieldNumber;
#endif  // !_MSC_VER

BasicRoute::BasicRoute()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BasicRoute::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  body_path_ = const_cast< ::com::telenav::proto::map::BasicPath*>(
      ::com::telenav::proto::map::BasicPath::internal_default_instance());
#else
  body_path_ = const_cast< ::com::telenav::proto::map::BasicPath*>(&::com::telenav::proto::map::BasicPath::default_instance());
#endif
}

BasicRoute::BasicRoute(const BasicRoute& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BasicRoute::SharedCtor() {
  _cached_size_ = 0;
  body_path_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BasicRoute::~BasicRoute() {
  SharedDtor();
}

void BasicRoute::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete body_path_;
  }
}

void BasicRoute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BasicRoute& BasicRoute::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

BasicRoute* BasicRoute::default_instance_ = NULL;

BasicRoute* BasicRoute::New() const {
  return new BasicRoute;
}

void BasicRoute::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_body_path()) {
      if (body_path_ != NULL) body_path_->::com::telenav::proto::map::BasicPath::Clear();
    }
  }
  head_path_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BasicRoute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.BasicPath head_path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_head_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_head_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_head_path;
        if (input->ExpectTag(26)) goto parse_body_path;
        break;
      }

      // optional .com.telenav.proto.map.BasicPath body_path = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_body_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_body_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BasicRoute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.BasicPath head_path = 2;
  for (int i = 0; i < this->head_path_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->head_path(i), output);
  }

  // optional .com.telenav.proto.map.BasicPath body_path = 3;
  if (has_body_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->body_path(), output);
  }

}

int BasicRoute::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .com.telenav.proto.map.BasicPath body_path = 3;
    if (has_body_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->body_path());
    }

  }
  // repeated .com.telenav.proto.map.BasicPath head_path = 2;
  total_size += 1 * this->head_path_size();
  for (int i = 0; i < this->head_path_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->head_path(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BasicRoute::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BasicRoute*>(&from));
}

void BasicRoute::MergeFrom(const BasicRoute& from) {
  GOOGLE_CHECK_NE(&from, this);
  head_path_.MergeFrom(from.head_path_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_body_path()) {
      mutable_body_path()->::com::telenav::proto::map::BasicPath::MergeFrom(from.body_path());
    }
  }
}

void BasicRoute::CopyFrom(const BasicRoute& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BasicRoute::IsInitialized() const {

  return true;
}

void BasicRoute::Swap(BasicRoute* other) {
  if (other != this) {
    head_path_.Swap(&other->head_path_);
    std::swap(body_path_, other->body_path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BasicRoute::GetTypeName() const {
  return "com.telenav.proto.map.BasicRoute";
}


// ===================================================================

#ifndef _MSC_VER
const int BasicPath::kEdgeIdFieldNumber;
const int BasicPath::kFirstEdgeStartPointsFieldNumber;
const int BasicPath::kLastEdgeEndPointsFieldNumber;
#endif  // !_MSC_VER

BasicPath::BasicPath()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BasicPath::InitAsDefaultInstance() {
}

BasicPath::BasicPath(const BasicPath& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BasicPath::SharedCtor() {
  _cached_size_ = 0;
  first_edge_start_points_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  last_edge_end_points_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BasicPath::~BasicPath() {
  SharedDtor();
}

void BasicPath::SharedDtor() {
  if (first_edge_start_points_ != &::google::protobuf::internal::kEmptyString) {
    delete first_edge_start_points_;
  }
  if (last_edge_end_points_ != &::google::protobuf::internal::kEmptyString) {
    delete last_edge_end_points_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BasicPath::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BasicPath& BasicPath::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

BasicPath* BasicPath::default_instance_ = NULL;

BasicPath* BasicPath::New() const {
  return new BasicPath;
}

void BasicPath::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_first_edge_start_points()) {
      if (first_edge_start_points_ != &::google::protobuf::internal::kEmptyString) {
        first_edge_start_points_->clear();
      }
    }
    if (has_last_edge_end_points()) {
      if (last_edge_end_points_ != &::google::protobuf::internal::kEmptyString) {
        last_edge_end_points_->clear();
      }
    }
  }
  edge_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BasicPath::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int64 edge_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_edge_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 16, input, this->mutable_edge_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_edge_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_edge_id;
        if (input->ExpectTag(34)) goto parse_first_edge_start_points;
        break;
      }

      // optional string first_edge_start_points = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_first_edge_start_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_first_edge_start_points()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_last_edge_end_points;
        break;
      }

      // optional string last_edge_end_points = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_last_edge_end_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_last_edge_end_points()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BasicPath::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int64 edge_id = 2;
  for (int i = 0; i < this->edge_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      2, this->edge_id(i), output);
  }

  // optional string first_edge_start_points = 4;
  if (has_first_edge_start_points()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->first_edge_start_points(), output);
  }

  // optional string last_edge_end_points = 5;
  if (has_last_edge_end_points()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->last_edge_end_points(), output);
  }

}

int BasicPath::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string first_edge_start_points = 4;
    if (has_first_edge_start_points()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->first_edge_start_points());
    }

    // optional string last_edge_end_points = 5;
    if (has_last_edge_end_points()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->last_edge_end_points());
    }

  }
  // repeated int64 edge_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->edge_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->edge_id(i));
    }
    total_size += 1 * this->edge_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BasicPath::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BasicPath*>(&from));
}

void BasicPath::MergeFrom(const BasicPath& from) {
  GOOGLE_CHECK_NE(&from, this);
  edge_id_.MergeFrom(from.edge_id_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_first_edge_start_points()) {
      set_first_edge_start_points(from.first_edge_start_points());
    }
    if (from.has_last_edge_end_points()) {
      set_last_edge_end_points(from.last_edge_end_points());
    }
  }
}

void BasicPath::CopyFrom(const BasicPath& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BasicPath::IsInitialized() const {

  return true;
}

void BasicPath::Swap(BasicPath* other) {
  if (other != this) {
    edge_id_.Swap(&other->edge_id_);
    std::swap(first_edge_start_points_, other->first_edge_start_points_);
    std::swap(last_edge_end_points_, other->last_edge_end_points_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BasicPath::GetTypeName() const {
  return "com.telenav.proto.map.BasicPath";
}


// ===================================================================

#ifndef _MSC_VER
const int Route::kRouteInfoFieldNumber;
const int Route::kPathFieldNumber;
const int Route::kSegmentFieldNumber;
const int Route::kPartialFieldNumber;
#endif  // !_MSC_VER

Route::Route()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Route::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  route_info_ = const_cast< ::com::telenav::proto::map::RouteInfo*>(
      ::com::telenav::proto::map::RouteInfo::internal_default_instance());
#else
  route_info_ = const_cast< ::com::telenav::proto::map::RouteInfo*>(&::com::telenav::proto::map::RouteInfo::default_instance());
#endif
}

Route::Route(const Route& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Route::SharedCtor() {
  _cached_size_ = 0;
  route_info_ = NULL;
  partial_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Route::~Route() {
  SharedDtor();
}

void Route::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete route_info_;
  }
}

void Route::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Route& Route::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

Route* Route::default_instance_ = NULL;

Route* Route::New() const {
  return new Route;
}

void Route::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_route_info()) {
      if (route_info_ != NULL) route_info_->::com::telenav::proto::map::RouteInfo::Clear();
    }
    partial_ = false;
  }
  path_.Clear();
  segment_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Route::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.telenav.proto.map.RouteInfo route_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_route_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_path;
        break;
      }

      // repeated .com.telenav.proto.map.Path path = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_path;
        if (input->ExpectTag(34)) goto parse_segment;
        break;
      }

      // repeated .com.telenav.proto.map.GuidanceSegment segment = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_segment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_segment()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_segment;
        if (input->ExpectTag(40)) goto parse_partial;
        break;
      }

      // optional bool partial = 5 [default = false];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_partial:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &partial_)));
          set_has_partial();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Route::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .com.telenav.proto.map.RouteInfo route_info = 2;
  if (has_route_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->route_info(), output);
  }

  // repeated .com.telenav.proto.map.Path path = 3;
  for (int i = 0; i < this->path_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->path(i), output);
  }

  // repeated .com.telenav.proto.map.GuidanceSegment segment = 4;
  for (int i = 0; i < this->segment_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->segment(i), output);
  }

  // optional bool partial = 5 [default = false];
  if (has_partial()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->partial(), output);
  }

}

int Route::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .com.telenav.proto.map.RouteInfo route_info = 2;
    if (has_route_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->route_info());
    }

    // optional bool partial = 5 [default = false];
    if (has_partial()) {
      total_size += 1 + 1;
    }

  }
  // repeated .com.telenav.proto.map.Path path = 3;
  total_size += 1 * this->path_size();
  for (int i = 0; i < this->path_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->path(i));
  }

  // repeated .com.telenav.proto.map.GuidanceSegment segment = 4;
  total_size += 1 * this->segment_size();
  for (int i = 0; i < this->segment_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->segment(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Route::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Route*>(&from));
}

void Route::MergeFrom(const Route& from) {
  GOOGLE_CHECK_NE(&from, this);
  path_.MergeFrom(from.path_);
  segment_.MergeFrom(from.segment_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_route_info()) {
      mutable_route_info()->::com::telenav::proto::map::RouteInfo::MergeFrom(from.route_info());
    }
    if (from.has_partial()) {
      set_partial(from.partial());
    }
  }
}

void Route::CopyFrom(const Route& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Route::IsInitialized() const {

  return true;
}

void Route::Swap(Route* other) {
  if (other != this) {
    std::swap(route_info_, other->route_info_);
    path_.Swap(&other->path_);
    segment_.Swap(&other->segment_);
    std::swap(partial_, other->partial_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Route::GetTypeName() const {
  return "com.telenav.proto.map.Route";
}


// ===================================================================

#ifndef _MSC_VER
const int RouteInfo::kOverviewFieldNumber;
const int RouteInfo::kSummaryFieldNumber;
const int RouteInfo::kTravelTimeInSecondFieldNumber;
const int RouteInfo::kTravelDistInMeterFieldNumber;
const int RouteInfo::kTrafficDelayInSecondFieldNumber;
const int RouteInfo::kEstimateOnlyFieldNumber;
const int RouteInfo::kWarningFieldNumber;
#endif  // !_MSC_VER

RouteInfo::RouteInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RouteInfo::InitAsDefaultInstance() {
}

RouteInfo::RouteInfo(const RouteInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RouteInfo::SharedCtor() {
  _cached_size_ = 0;
  overview_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  travel_time_in_second_ = 0;
  travel_dist_in_meter_ = 0;
  traffic_delay_in_second_ = 0;
  estimate_only_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RouteInfo::~RouteInfo() {
  SharedDtor();
}

void RouteInfo::SharedDtor() {
  if (overview_ != &::google::protobuf::internal::kEmptyString) {
    delete overview_;
  }
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    delete summary_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RouteInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RouteInfo& RouteInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

RouteInfo* RouteInfo::default_instance_ = NULL;

RouteInfo* RouteInfo::New() const {
  return new RouteInfo;
}

void RouteInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_overview()) {
      if (overview_ != &::google::protobuf::internal::kEmptyString) {
        overview_->clear();
      }
    }
    if (has_summary()) {
      if (summary_ != &::google::protobuf::internal::kEmptyString) {
        summary_->clear();
      }
    }
    travel_time_in_second_ = 0;
    travel_dist_in_meter_ = 0;
    traffic_delay_in_second_ = 0;
    estimate_only_ = false;
  }
  warning_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RouteInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string overview = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_overview()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_summary;
        break;
      }

      // optional string summary = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_summary:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_summary()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_travel_time_in_second;
        break;
      }

      // optional int32 travel_time_in_second = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_travel_time_in_second:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &travel_time_in_second_)));
          set_has_travel_time_in_second();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_travel_dist_in_meter;
        break;
      }

      // optional int32 travel_dist_in_meter = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_travel_dist_in_meter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &travel_dist_in_meter_)));
          set_has_travel_dist_in_meter();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_traffic_delay_in_second;
        break;
      }

      // optional int32 traffic_delay_in_second = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_traffic_delay_in_second:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &traffic_delay_in_second_)));
          set_has_traffic_delay_in_second();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_estimate_only;
        break;
      }

      // optional bool estimate_only = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_estimate_only:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &estimate_only_)));
          set_has_estimate_only();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_warning;
        break;
      }

      // repeated .com.telenav.proto.map.Warning warning = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_warning:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::Warning_IsValid(value)) {
            add_warning(static_cast< ::com::telenav::proto::map::Warning >(value));
          }
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::com::telenav::proto::map::Warning_IsValid,
                 this->mutable_warning())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_warning;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RouteInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string overview = 1;
  if (has_overview()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->overview(), output);
  }

  // optional string summary = 2;
  if (has_summary()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->summary(), output);
  }

  // optional int32 travel_time_in_second = 3;
  if (has_travel_time_in_second()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->travel_time_in_second(), output);
  }

  // optional int32 travel_dist_in_meter = 4;
  if (has_travel_dist_in_meter()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->travel_dist_in_meter(), output);
  }

  // optional int32 traffic_delay_in_second = 5;
  if (has_traffic_delay_in_second()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->traffic_delay_in_second(), output);
  }

  // optional bool estimate_only = 8;
  if (has_estimate_only()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->estimate_only(), output);
  }

  // repeated .com.telenav.proto.map.Warning warning = 9;
  for (int i = 0; i < this->warning_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->warning(i), output);
  }

}

int RouteInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string overview = 1;
    if (has_overview()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->overview());
    }

    // optional string summary = 2;
    if (has_summary()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->summary());
    }

    // optional int32 travel_time_in_second = 3;
    if (has_travel_time_in_second()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->travel_time_in_second());
    }

    // optional int32 travel_dist_in_meter = 4;
    if (has_travel_dist_in_meter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->travel_dist_in_meter());
    }

    // optional int32 traffic_delay_in_second = 5;
    if (has_traffic_delay_in_second()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->traffic_delay_in_second());
    }

    // optional bool estimate_only = 8;
    if (has_estimate_only()) {
      total_size += 1 + 1;
    }

  }
  // repeated .com.telenav.proto.map.Warning warning = 9;
  {
    int data_size = 0;
    for (int i = 0; i < this->warning_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->warning(i));
    }
    total_size += 1 * this->warning_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RouteInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RouteInfo*>(&from));
}

void RouteInfo::MergeFrom(const RouteInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  warning_.MergeFrom(from.warning_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_overview()) {
      set_overview(from.overview());
    }
    if (from.has_summary()) {
      set_summary(from.summary());
    }
    if (from.has_travel_time_in_second()) {
      set_travel_time_in_second(from.travel_time_in_second());
    }
    if (from.has_travel_dist_in_meter()) {
      set_travel_dist_in_meter(from.travel_dist_in_meter());
    }
    if (from.has_traffic_delay_in_second()) {
      set_traffic_delay_in_second(from.traffic_delay_in_second());
    }
    if (from.has_estimate_only()) {
      set_estimate_only(from.estimate_only());
    }
  }
}

void RouteInfo::CopyFrom(const RouteInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteInfo::IsInitialized() const {

  return true;
}

void RouteInfo::Swap(RouteInfo* other) {
  if (other != this) {
    std::swap(overview_, other->overview_);
    std::swap(summary_, other->summary_);
    std::swap(travel_time_in_second_, other->travel_time_in_second_);
    std::swap(travel_dist_in_meter_, other->travel_dist_in_meter_);
    std::swap(traffic_delay_in_second_, other->traffic_delay_in_second_);
    std::swap(estimate_only_, other->estimate_only_);
    warning_.Swap(&other->warning_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RouteInfo::GetTypeName() const {
  return "com.telenav.proto.map.RouteInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int Path::kSegmentIndexFieldNumber;
#endif  // !_MSC_VER

Path::Path()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Path::InitAsDefaultInstance() {
}

Path::Path(const Path& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Path::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Path::~Path() {
  SharedDtor();
}

void Path::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Path::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Path& Path::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

Path* Path::default_instance_ = NULL;

Path* Path::New() const {
  return new Path;
}

void Path::Clear() {
  segment_index_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Path::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 segment_index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_segment_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_segment_index())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_segment_index())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_segment_index;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Path::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 segment_index = 1;
  for (int i = 0; i < this->segment_index_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->segment_index(i), output);
  }

}

int Path::ByteSize() const {
  int total_size = 0;

  // repeated int32 segment_index = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->segment_index_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->segment_index(i));
    }
    total_size += 1 * this->segment_index_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Path::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Path*>(&from));
}

void Path::MergeFrom(const Path& from) {
  GOOGLE_CHECK_NE(&from, this);
  segment_index_.MergeFrom(from.segment_index_);
}

void Path::CopyFrom(const Path& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Path::IsInitialized() const {

  return true;
}

void Path::Swap(Path* other) {
  if (other != this) {
    segment_index_.Swap(&other->segment_index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Path::GetTypeName() const {
  return "com.telenav.proto.map.Path";
}


// ===================================================================

#ifndef _MSC_VER
const int GuidanceSegment::kTurnTypeFieldNumber;
const int GuidanceSegment::kIsTightTurnFieldNumber;
const int GuidanceSegment::kRoadNameFieldNumber;
const int GuidanceSegment::kSignPostFieldNumber;
const int GuidanceSegment::kSignBoardFieldNumber;
const int GuidanceSegment::kNthTurnFieldNumber;
const int GuidanceSegment::kLanguageFieldNumber;
const int GuidanceSegment::kRoadTypeFieldNumber;
const int GuidanceSegment::kIsLeftSideDriveFieldNumber;
const int GuidanceSegment::kLaneInfoFieldNumber;
const int GuidanceSegment::kLengthInMeterFieldNumber;
const int GuidanceSegment::kJunctionViewFieldNumber;
const int GuidanceSegment::kWarningFieldNumber;
const int GuidanceSegment::kEdgeFieldNumber;
#endif  // !_MSC_VER

GuidanceSegment::GuidanceSegment()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GuidanceSegment::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  road_name_ = const_cast< ::com::telenav::proto::map::RoadName*>(
      ::com::telenav::proto::map::RoadName::internal_default_instance());
#else
  road_name_ = const_cast< ::com::telenav::proto::map::RoadName*>(&::com::telenav::proto::map::RoadName::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sign_post_ = const_cast< ::com::telenav::proto::map::SignPost*>(
      ::com::telenav::proto::map::SignPost::internal_default_instance());
#else
  sign_post_ = const_cast< ::com::telenav::proto::map::SignPost*>(&::com::telenav::proto::map::SignPost::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sign_board_ = const_cast< ::com::telenav::proto::map::SignBoard*>(
      ::com::telenav::proto::map::SignBoard::internal_default_instance());
#else
  sign_board_ = const_cast< ::com::telenav::proto::map::SignBoard*>(&::com::telenav::proto::map::SignBoard::default_instance());
#endif
}

GuidanceSegment::GuidanceSegment(const GuidanceSegment& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GuidanceSegment::SharedCtor() {
  _cached_size_ = 0;
  turn_type_ = 0;
  is_tight_turn_ = false;
  road_name_ = NULL;
  sign_post_ = NULL;
  sign_board_ = NULL;
  nth_turn_ = 0;
  language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  road_type_ = 0;
  is_left_side_drive_ = false;
  length_in_meter_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GuidanceSegment::~GuidanceSegment() {
  SharedDtor();
}

void GuidanceSegment::SharedDtor() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete road_name_;
    delete sign_post_;
    delete sign_board_;
  }
}

void GuidanceSegment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GuidanceSegment& GuidanceSegment::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

GuidanceSegment* GuidanceSegment::default_instance_ = NULL;

GuidanceSegment* GuidanceSegment::New() const {
  return new GuidanceSegment;
}

void GuidanceSegment::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    turn_type_ = 0;
    is_tight_turn_ = false;
    if (has_road_name()) {
      if (road_name_ != NULL) road_name_->::com::telenav::proto::map::RoadName::Clear();
    }
    if (has_sign_post()) {
      if (sign_post_ != NULL) sign_post_->::com::telenav::proto::map::SignPost::Clear();
    }
    if (has_sign_board()) {
      if (sign_board_ != NULL) sign_board_->::com::telenav::proto::map::SignBoard::Clear();
    }
    nth_turn_ = 0;
    if (has_language()) {
      if (language_ != &::google::protobuf::internal::kEmptyString) {
        language_->clear();
      }
    }
    road_type_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    is_left_side_drive_ = false;
    length_in_meter_ = 0;
  }
  lane_info_.Clear();
  junction_view_.Clear();
  warning_.Clear();
  edge_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GuidanceSegment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.telenav.proto.map.TurnType turn_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::TurnType_IsValid(value)) {
            set_turn_type(static_cast< ::com::telenav::proto::map::TurnType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_tight_turn;
        break;
      }

      // optional bool is_tight_turn = 2 [default = false];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_tight_turn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_tight_turn_)));
          set_has_is_tight_turn();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_road_name;
        break;
      }

      // optional .com.telenav.proto.map.RoadName road_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_road_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_road_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_sign_post;
        break;
      }

      // optional .com.telenav.proto.map.SignPost sign_post = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sign_post:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sign_post()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_sign_board;
        break;
      }

      // optional .com.telenav.proto.map.SignBoard sign_board = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sign_board:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sign_board()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_nth_turn;
        break;
      }

      // optional int32 nth_turn = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nth_turn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nth_turn_)));
          set_has_nth_turn();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_language;
        break;
      }

      // optional string language = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_language:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_road_type;
        break;
      }

      // optional .com.telenav.proto.map.RoadType road_type = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_road_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::RoadType_IsValid(value)) {
            set_road_type(static_cast< ::com::telenav::proto::map::RoadType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_is_left_side_drive;
        break;
      }

      // optional bool is_left_side_drive = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_left_side_drive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_left_side_drive_)));
          set_has_is_left_side_drive();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_lane_info;
        break;
      }

      // repeated .com.telenav.proto.map.LaneInfo lane_info = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lane_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lane_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_lane_info;
        if (input->ExpectTag(113)) goto parse_length_in_meter;
        break;
      }

      // optional double length_in_meter = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_length_in_meter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &length_in_meter_)));
          set_has_length_in_meter();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_junction_view;
        break;
      }

      // repeated .com.telenav.proto.map.JunctionView junction_view = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_junction_view:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_junction_view()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_junction_view;
        if (input->ExpectTag(146)) goto parse_edge;
        break;
      }

      // repeated .com.telenav.proto.map.Edge edge = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_edge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_edge()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_edge;
        if (input->ExpectTag(152)) goto parse_warning;
        break;
      }

      // repeated .com.telenav.proto.map.Warning warning = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_warning:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::Warning_IsValid(value)) {
            add_warning(static_cast< ::com::telenav::proto::map::Warning >(value));
          }
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::com::telenav::proto::map::Warning_IsValid,
                 this->mutable_warning())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(152)) goto parse_warning;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GuidanceSegment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .com.telenav.proto.map.TurnType turn_type = 1;
  if (has_turn_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->turn_type(), output);
  }

  // optional bool is_tight_turn = 2 [default = false];
  if (has_is_tight_turn()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_tight_turn(), output);
  }

  // optional .com.telenav.proto.map.RoadName road_name = 3;
  if (has_road_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->road_name(), output);
  }

  // optional .com.telenav.proto.map.SignPost sign_post = 4;
  if (has_sign_post()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->sign_post(), output);
  }

  // optional .com.telenav.proto.map.SignBoard sign_board = 5;
  if (has_sign_board()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->sign_board(), output);
  }

  // optional int32 nth_turn = 6;
  if (has_nth_turn()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->nth_turn(), output);
  }

  // optional string language = 9;
  if (has_language()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->language(), output);
  }

  // optional .com.telenav.proto.map.RoadType road_type = 10;
  if (has_road_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->road_type(), output);
  }

  // optional bool is_left_side_drive = 12;
  if (has_is_left_side_drive()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->is_left_side_drive(), output);
  }

  // repeated .com.telenav.proto.map.LaneInfo lane_info = 13;
  for (int i = 0; i < this->lane_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, this->lane_info(i), output);
  }

  // optional double length_in_meter = 14;
  if (has_length_in_meter()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(14, this->length_in_meter(), output);
  }

  // repeated .com.telenav.proto.map.JunctionView junction_view = 15;
  for (int i = 0; i < this->junction_view_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, this->junction_view(i), output);
  }

  // repeated .com.telenav.proto.map.Edge edge = 18;
  for (int i = 0; i < this->edge_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      18, this->edge(i), output);
  }

  // repeated .com.telenav.proto.map.Warning warning = 19;
  for (int i = 0; i < this->warning_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      19, this->warning(i), output);
  }

}

int GuidanceSegment::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .com.telenav.proto.map.TurnType turn_type = 1;
    if (has_turn_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->turn_type());
    }

    // optional bool is_tight_turn = 2 [default = false];
    if (has_is_tight_turn()) {
      total_size += 1 + 1;
    }

    // optional .com.telenav.proto.map.RoadName road_name = 3;
    if (has_road_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->road_name());
    }

    // optional .com.telenav.proto.map.SignPost sign_post = 4;
    if (has_sign_post()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sign_post());
    }

    // optional .com.telenav.proto.map.SignBoard sign_board = 5;
    if (has_sign_board()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sign_board());
    }

    // optional int32 nth_turn = 6;
    if (has_nth_turn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nth_turn());
    }

    // optional string language = 9;
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional .com.telenav.proto.map.RoadType road_type = 10;
    if (has_road_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->road_type());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool is_left_side_drive = 12;
    if (has_is_left_side_drive()) {
      total_size += 1 + 1;
    }

    // optional double length_in_meter = 14;
    if (has_length_in_meter()) {
      total_size += 1 + 8;
    }

  }
  // repeated .com.telenav.proto.map.LaneInfo lane_info = 13;
  total_size += 1 * this->lane_info_size();
  for (int i = 0; i < this->lane_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lane_info(i));
  }

  // repeated .com.telenav.proto.map.JunctionView junction_view = 15;
  total_size += 1 * this->junction_view_size();
  for (int i = 0; i < this->junction_view_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->junction_view(i));
  }

  // repeated .com.telenav.proto.map.Warning warning = 19;
  {
    int data_size = 0;
    for (int i = 0; i < this->warning_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->warning(i));
    }
    total_size += 2 * this->warning_size() + data_size;
  }

  // repeated .com.telenav.proto.map.Edge edge = 18;
  total_size += 2 * this->edge_size();
  for (int i = 0; i < this->edge_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->edge(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GuidanceSegment::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GuidanceSegment*>(&from));
}

void GuidanceSegment::MergeFrom(const GuidanceSegment& from) {
  GOOGLE_CHECK_NE(&from, this);
  lane_info_.MergeFrom(from.lane_info_);
  junction_view_.MergeFrom(from.junction_view_);
  warning_.MergeFrom(from.warning_);
  edge_.MergeFrom(from.edge_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_turn_type()) {
      set_turn_type(from.turn_type());
    }
    if (from.has_is_tight_turn()) {
      set_is_tight_turn(from.is_tight_turn());
    }
    if (from.has_road_name()) {
      mutable_road_name()->::com::telenav::proto::map::RoadName::MergeFrom(from.road_name());
    }
    if (from.has_sign_post()) {
      mutable_sign_post()->::com::telenav::proto::map::SignPost::MergeFrom(from.sign_post());
    }
    if (from.has_sign_board()) {
      mutable_sign_board()->::com::telenav::proto::map::SignBoard::MergeFrom(from.sign_board());
    }
    if (from.has_nth_turn()) {
      set_nth_turn(from.nth_turn());
    }
    if (from.has_language()) {
      set_language(from.language());
    }
    if (from.has_road_type()) {
      set_road_type(from.road_type());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_is_left_side_drive()) {
      set_is_left_side_drive(from.is_left_side_drive());
    }
    if (from.has_length_in_meter()) {
      set_length_in_meter(from.length_in_meter());
    }
  }
}

void GuidanceSegment::CopyFrom(const GuidanceSegment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuidanceSegment::IsInitialized() const {

  return true;
}

void GuidanceSegment::Swap(GuidanceSegment* other) {
  if (other != this) {
    std::swap(turn_type_, other->turn_type_);
    std::swap(is_tight_turn_, other->is_tight_turn_);
    std::swap(road_name_, other->road_name_);
    std::swap(sign_post_, other->sign_post_);
    std::swap(sign_board_, other->sign_board_);
    std::swap(nth_turn_, other->nth_turn_);
    std::swap(language_, other->language_);
    std::swap(road_type_, other->road_type_);
    std::swap(is_left_side_drive_, other->is_left_side_drive_);
    lane_info_.Swap(&other->lane_info_);
    std::swap(length_in_meter_, other->length_in_meter_);
    junction_view_.Swap(&other->junction_view_);
    warning_.Swap(&other->warning_);
    edge_.Swap(&other->edge_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GuidanceSegment::GetTypeName() const {
  return "com.telenav.proto.map.GuidanceSegment";
}


// ===================================================================

#ifndef _MSC_VER
const int RoadName::kOfficialNameFieldNumber;
const int RoadName::kAlternateNameFieldNumber;
const int RoadName::kRouteNumberFieldNumber;
#endif  // !_MSC_VER

RoadName::RoadName()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RoadName::InitAsDefaultInstance() {
}

RoadName::RoadName(const RoadName& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RoadName::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoadName::~RoadName() {
  SharedDtor();
}

void RoadName::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RoadName::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RoadName& RoadName::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

RoadName* RoadName::default_instance_ = NULL;

RoadName* RoadName::New() const {
  return new RoadName;
}

void RoadName::Clear() {
  official_name_.Clear();
  alternate_name_.Clear();
  route_number_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RoadName::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string official_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_official_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_official_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_official_name;
        if (input->ExpectTag(18)) goto parse_alternate_name;
        break;
      }

      // repeated string alternate_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_alternate_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_alternate_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_alternate_name;
        if (input->ExpectTag(26)) goto parse_route_number;
        break;
      }

      // repeated string route_number = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_route_number:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_route_number()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_route_number;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RoadName::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated string official_name = 1;
  for (int i = 0; i < this->official_name_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->official_name(i), output);
  }

  // repeated string alternate_name = 2;
  for (int i = 0; i < this->alternate_name_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->alternate_name(i), output);
  }

  // repeated string route_number = 3;
  for (int i = 0; i < this->route_number_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->route_number(i), output);
  }

}

int RoadName::ByteSize() const {
  int total_size = 0;

  // repeated string official_name = 1;
  total_size += 1 * this->official_name_size();
  for (int i = 0; i < this->official_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->official_name(i));
  }

  // repeated string alternate_name = 2;
  total_size += 1 * this->alternate_name_size();
  for (int i = 0; i < this->alternate_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->alternate_name(i));
  }

  // repeated string route_number = 3;
  total_size += 1 * this->route_number_size();
  for (int i = 0; i < this->route_number_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->route_number(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoadName::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RoadName*>(&from));
}

void RoadName::MergeFrom(const RoadName& from) {
  GOOGLE_CHECK_NE(&from, this);
  official_name_.MergeFrom(from.official_name_);
  alternate_name_.MergeFrom(from.alternate_name_);
  route_number_.MergeFrom(from.route_number_);
}

void RoadName::CopyFrom(const RoadName& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadName::IsInitialized() const {

  return true;
}

void RoadName::Swap(RoadName* other) {
  if (other != this) {
    official_name_.Swap(&other->official_name_);
    alternate_name_.Swap(&other->alternate_name_);
    route_number_.Swap(&other->route_number_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RoadName::GetTypeName() const {
  return "com.telenav.proto.map.RoadName";
}


// ===================================================================

#ifndef _MSC_VER
const int SignPost::kRoadNameFieldNumber;
const int SignPost::kPlaceNameFieldNumber;
const int SignPost::kExitLabelFieldNumber;
const int SignPost::kImageIdFieldNumber;
#endif  // !_MSC_VER

SignPost::SignPost()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SignPost::InitAsDefaultInstance() {
}

SignPost::SignPost(const SignPost& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SignPost::SharedCtor() {
  _cached_size_ = 0;
  place_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  exit_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  image_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignPost::~SignPost() {
  SharedDtor();
}

void SignPost::SharedDtor() {
  if (place_name_ != &::google::protobuf::internal::kEmptyString) {
    delete place_name_;
  }
  if (exit_label_ != &::google::protobuf::internal::kEmptyString) {
    delete exit_label_;
  }
  if (image_id_ != &::google::protobuf::internal::kEmptyString) {
    delete image_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SignPost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SignPost& SignPost::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

SignPost* SignPost::default_instance_ = NULL;

SignPost* SignPost::New() const {
  return new SignPost;
}

void SignPost::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_place_name()) {
      if (place_name_ != &::google::protobuf::internal::kEmptyString) {
        place_name_->clear();
      }
    }
    if (has_exit_label()) {
      if (exit_label_ != &::google::protobuf::internal::kEmptyString) {
        exit_label_->clear();
      }
    }
    if (has_image_id()) {
      if (image_id_ != &::google::protobuf::internal::kEmptyString) {
        image_id_->clear();
      }
    }
  }
  road_name_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SignPost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string road_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_road_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_road_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_road_name;
        if (input->ExpectTag(18)) goto parse_place_name;
        break;
      }

      // optional string place_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_place_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_place_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_exit_label;
        break;
      }

      // optional string exit_label = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exit_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_exit_label()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_image_id;
        break;
      }

      // optional string image_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_image_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_image_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SignPost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated string road_name = 1;
  for (int i = 0; i < this->road_name_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->road_name(i), output);
  }

  // optional string place_name = 2;
  if (has_place_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->place_name(), output);
  }

  // optional string exit_label = 3;
  if (has_exit_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->exit_label(), output);
  }

  // optional string image_id = 4;
  if (has_image_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->image_id(), output);
  }

}

int SignPost::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string place_name = 2;
    if (has_place_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->place_name());
    }

    // optional string exit_label = 3;
    if (has_exit_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->exit_label());
    }

    // optional string image_id = 4;
    if (has_image_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->image_id());
    }

  }
  // repeated string road_name = 1;
  total_size += 1 * this->road_name_size();
  for (int i = 0; i < this->road_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->road_name(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignPost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SignPost*>(&from));
}

void SignPost::MergeFrom(const SignPost& from) {
  GOOGLE_CHECK_NE(&from, this);
  road_name_.MergeFrom(from.road_name_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_place_name()) {
      set_place_name(from.place_name());
    }
    if (from.has_exit_label()) {
      set_exit_label(from.exit_label());
    }
    if (from.has_image_id()) {
      set_image_id(from.image_id());
    }
  }
}

void SignPost::CopyFrom(const SignPost& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignPost::IsInitialized() const {

  return true;
}

void SignPost::Swap(SignPost* other) {
  if (other != this) {
    road_name_.Swap(&other->road_name_);
    std::swap(place_name_, other->place_name_);
    std::swap(exit_label_, other->exit_label_);
    std::swap(image_id_, other->image_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SignPost::GetTypeName() const {
  return "com.telenav.proto.map.SignPost";
}


// ===================================================================

#ifndef _MSC_VER
const int SignBoard::kTypeFieldNumber;
const int SignBoard::kPatternIdFieldNumber;
const int SignBoard::kArrowIdFieldNumber;
#endif  // !_MSC_VER

SignBoard::SignBoard()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SignBoard::InitAsDefaultInstance() {
}

SignBoard::SignBoard(const SignBoard& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SignBoard::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  pattern_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  arrow_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignBoard::~SignBoard() {
  SharedDtor();
}

void SignBoard::SharedDtor() {
  if (pattern_id_ != &::google::protobuf::internal::kEmptyString) {
    delete pattern_id_;
  }
  if (arrow_id_ != &::google::protobuf::internal::kEmptyString) {
    delete arrow_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SignBoard::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SignBoard& SignBoard::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

SignBoard* SignBoard::default_instance_ = NULL;

SignBoard* SignBoard::New() const {
  return new SignBoard;
}

void SignBoard::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_pattern_id()) {
      if (pattern_id_ != &::google::protobuf::internal::kEmptyString) {
        pattern_id_->clear();
      }
    }
    if (has_arrow_id()) {
      if (arrow_id_ != &::google::protobuf::internal::kEmptyString) {
        arrow_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SignBoard::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.telenav.proto.map.SignBoardType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::SignBoardType_IsValid(value)) {
            set_type(static_cast< ::com::telenav::proto::map::SignBoardType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pattern_id;
        break;
      }

      // optional string pattern_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pattern_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pattern_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_arrow_id;
        break;
      }

      // optional string arrow_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_arrow_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_arrow_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SignBoard::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .com.telenav.proto.map.SignBoardType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional string pattern_id = 2;
  if (has_pattern_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->pattern_id(), output);
  }

  // optional string arrow_id = 3;
  if (has_arrow_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->arrow_id(), output);
  }

}

int SignBoard::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .com.telenav.proto.map.SignBoardType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string pattern_id = 2;
    if (has_pattern_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pattern_id());
    }

    // optional string arrow_id = 3;
    if (has_arrow_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->arrow_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignBoard::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SignBoard*>(&from));
}

void SignBoard::MergeFrom(const SignBoard& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_pattern_id()) {
      set_pattern_id(from.pattern_id());
    }
    if (from.has_arrow_id()) {
      set_arrow_id(from.arrow_id());
    }
  }
}

void SignBoard::CopyFrom(const SignBoard& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignBoard::IsInitialized() const {

  return true;
}

void SignBoard::Swap(SignBoard* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(pattern_id_, other->pattern_id_);
    std::swap(arrow_id_, other->arrow_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SignBoard::GetTypeName() const {
  return "com.telenav.proto.map.SignBoard";
}


// ===================================================================

#ifndef _MSC_VER
const int Edge::kSpeedLimitInKPHFieldNumber;
const int Edge::kTravelSpeedInMpsFieldNumber;
const int Edge::kMapEdgeIdFieldNumber;
const int Edge::kLengthInMeterFieldNumber;
const int Edge::kEncodedPolylineFieldNumber;
const int Edge::kTrafficIdFieldNumber;
const int Edge::kTimeProfileFieldNumber;
#endif  // !_MSC_VER

Edge::Edge()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Edge::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  time_profile_ = const_cast< ::com::telenav::proto::map::TimeProfile*>(
      ::com::telenav::proto::map::TimeProfile::internal_default_instance());
#else
  time_profile_ = const_cast< ::com::telenav::proto::map::TimeProfile*>(&::com::telenav::proto::map::TimeProfile::default_instance());
#endif
}

Edge::Edge(const Edge& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Edge::SharedCtor() {
  _cached_size_ = 0;
  speed_limit_in_kph_ = -1;
  travel_speed_in_mps_ = -1;
  length_in_meter_ = 0;
  encoded_polyline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  traffic_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  time_profile_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Edge::~Edge() {
  SharedDtor();
}

void Edge::SharedDtor() {
  if (encoded_polyline_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_polyline_;
  }
  if (traffic_id_ != &::google::protobuf::internal::kEmptyString) {
    delete traffic_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete time_profile_;
  }
}

void Edge::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Edge& Edge::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

Edge* Edge::default_instance_ = NULL;

Edge* Edge::New() const {
  return new Edge;
}

void Edge::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    speed_limit_in_kph_ = -1;
    travel_speed_in_mps_ = -1;
    length_in_meter_ = 0;
    if (has_encoded_polyline()) {
      if (encoded_polyline_ != &::google::protobuf::internal::kEmptyString) {
        encoded_polyline_->clear();
      }
    }
    if (has_traffic_id()) {
      if (traffic_id_ != &::google::protobuf::internal::kEmptyString) {
        traffic_id_->clear();
      }
    }
    if (has_time_profile()) {
      if (time_profile_ != NULL) time_profile_->::com::telenav::proto::map::TimeProfile::Clear();
    }
  }
  map_edge_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Edge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double speed_limit_in_KPH = 2 [default = -1];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_limit_in_kph_)));
          set_has_speed_limit_in_kph();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_travel_speed_in_mps;
        break;
      }

      // optional double travel_speed_in_mps = 3 [default = -1];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_travel_speed_in_mps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &travel_speed_in_mps_)));
          set_has_travel_speed_in_mps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_map_edge_id;
        break;
      }

      // repeated int64 map_edge_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_edge_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 32, input, this->mutable_map_edge_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_map_edge_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_map_edge_id;
        if (input->ExpectTag(48)) goto parse_length_in_meter;
        break;
      }

      // optional int32 length_in_meter = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_length_in_meter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &length_in_meter_)));
          set_has_length_in_meter();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_encoded_polyline;
        break;
      }

      // optional string encoded_polyline = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encoded_polyline:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_encoded_polyline()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_traffic_id;
        break;
      }

      // optional string traffic_id = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_traffic_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_traffic_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_time_profile;
        break;
      }

      // optional .com.telenav.proto.map.TimeProfile time_profile = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_time_profile:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_time_profile()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Edge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional double speed_limit_in_KPH = 2 [default = -1];
  if (has_speed_limit_in_kph()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->speed_limit_in_kph(), output);
  }

  // optional double travel_speed_in_mps = 3 [default = -1];
  if (has_travel_speed_in_mps()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->travel_speed_in_mps(), output);
  }

  // repeated int64 map_edge_id = 4;
  for (int i = 0; i < this->map_edge_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      4, this->map_edge_id(i), output);
  }

  // optional int32 length_in_meter = 6;
  if (has_length_in_meter()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->length_in_meter(), output);
  }

  // optional string encoded_polyline = 7;
  if (has_encoded_polyline()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->encoded_polyline(), output);
  }

  // optional string traffic_id = 8;
  if (has_traffic_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->traffic_id(), output);
  }

  // optional .com.telenav.proto.map.TimeProfile time_profile = 9;
  if (has_time_profile()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->time_profile(), output);
  }

}

int Edge::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double speed_limit_in_KPH = 2 [default = -1];
    if (has_speed_limit_in_kph()) {
      total_size += 1 + 8;
    }

    // optional double travel_speed_in_mps = 3 [default = -1];
    if (has_travel_speed_in_mps()) {
      total_size += 1 + 8;
    }

    // optional int32 length_in_meter = 6;
    if (has_length_in_meter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->length_in_meter());
    }

    // optional string encoded_polyline = 7;
    if (has_encoded_polyline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->encoded_polyline());
    }

    // optional string traffic_id = 8;
    if (has_traffic_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->traffic_id());
    }

    // optional .com.telenav.proto.map.TimeProfile time_profile = 9;
    if (has_time_profile()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->time_profile());
    }

  }
  // repeated int64 map_edge_id = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->map_edge_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->map_edge_id(i));
    }
    total_size += 1 * this->map_edge_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Edge::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Edge*>(&from));
}

void Edge::MergeFrom(const Edge& from) {
  GOOGLE_CHECK_NE(&from, this);
  map_edge_id_.MergeFrom(from.map_edge_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_speed_limit_in_kph()) {
      set_speed_limit_in_kph(from.speed_limit_in_kph());
    }
    if (from.has_travel_speed_in_mps()) {
      set_travel_speed_in_mps(from.travel_speed_in_mps());
    }
    if (from.has_length_in_meter()) {
      set_length_in_meter(from.length_in_meter());
    }
    if (from.has_encoded_polyline()) {
      set_encoded_polyline(from.encoded_polyline());
    }
    if (from.has_traffic_id()) {
      set_traffic_id(from.traffic_id());
    }
    if (from.has_time_profile()) {
      mutable_time_profile()->::com::telenav::proto::map::TimeProfile::MergeFrom(from.time_profile());
    }
  }
}

void Edge::CopyFrom(const Edge& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Edge::IsInitialized() const {

  return true;
}

void Edge::Swap(Edge* other) {
  if (other != this) {
    std::swap(speed_limit_in_kph_, other->speed_limit_in_kph_);
    std::swap(travel_speed_in_mps_, other->travel_speed_in_mps_);
    map_edge_id_.Swap(&other->map_edge_id_);
    std::swap(length_in_meter_, other->length_in_meter_);
    std::swap(encoded_polyline_, other->encoded_polyline_);
    std::swap(traffic_id_, other->traffic_id_);
    std::swap(time_profile_, other->time_profile_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Edge::GetTypeName() const {
  return "com.telenav.proto.map.Edge";
}


// ===================================================================

#ifndef _MSC_VER
const int TimeProfile::kTurnCostFieldNumber;
const int TimeProfile::kRealTimeSpeedFieldNumber;
const int TimeProfile::kHistoricalPatternFieldNumber;
#endif  // !_MSC_VER

TimeProfile::TimeProfile()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TimeProfile::InitAsDefaultInstance() {
}

TimeProfile::TimeProfile(const TimeProfile& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TimeProfile::SharedCtor() {
  _cached_size_ = 0;
  turn_cost_ = 0;
  real_time_speed_ = 0;
  historical_pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TimeProfile::~TimeProfile() {
  SharedDtor();
}

void TimeProfile::SharedDtor() {
  if (historical_pattern_ != &::google::protobuf::internal::kEmptyString) {
    delete historical_pattern_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TimeProfile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TimeProfile& TimeProfile::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

TimeProfile* TimeProfile::default_instance_ = NULL;

TimeProfile* TimeProfile::New() const {
  return new TimeProfile;
}

void TimeProfile::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    turn_cost_ = 0;
    real_time_speed_ = 0;
    if (has_historical_pattern()) {
      if (historical_pattern_ != &::google::protobuf::internal::kEmptyString) {
        historical_pattern_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TimeProfile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 turn_cost = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &turn_cost_)));
          set_has_turn_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_real_time_speed;
        break;
      }

      // optional double real_time_speed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_real_time_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &real_time_speed_)));
          set_has_real_time_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_historical_pattern;
        break;
      }

      // optional string historical_pattern = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_historical_pattern:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_historical_pattern()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TimeProfile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 turn_cost = 1;
  if (has_turn_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->turn_cost(), output);
  }

  // optional double real_time_speed = 2;
  if (has_real_time_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->real_time_speed(), output);
  }

  // optional string historical_pattern = 3;
  if (has_historical_pattern()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->historical_pattern(), output);
  }

}

int TimeProfile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 turn_cost = 1;
    if (has_turn_cost()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->turn_cost());
    }

    // optional double real_time_speed = 2;
    if (has_real_time_speed()) {
      total_size += 1 + 8;
    }

    // optional string historical_pattern = 3;
    if (has_historical_pattern()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->historical_pattern());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TimeProfile::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TimeProfile*>(&from));
}

void TimeProfile::MergeFrom(const TimeProfile& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_turn_cost()) {
      set_turn_cost(from.turn_cost());
    }
    if (from.has_real_time_speed()) {
      set_real_time_speed(from.real_time_speed());
    }
    if (from.has_historical_pattern()) {
      set_historical_pattern(from.historical_pattern());
    }
  }
}

void TimeProfile::CopyFrom(const TimeProfile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeProfile::IsInitialized() const {

  return true;
}

void TimeProfile::Swap(TimeProfile* other) {
  if (other != this) {
    std::swap(turn_cost_, other->turn_cost_);
    std::swap(real_time_speed_, other->real_time_speed_);
    std::swap(historical_pattern_, other->historical_pattern_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TimeProfile::GetTypeName() const {
  return "com.telenav.proto.map.TimeProfile";
}


// ===================================================================

#ifndef _MSC_VER
const int LaneInfo::kPatternFieldNumber;
const int LaneInfo::kHighlightFieldNumber;
const int LaneInfo::kPreferredFieldNumber;
#endif  // !_MSC_VER

LaneInfo::LaneInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LaneInfo::InitAsDefaultInstance() {
}

LaneInfo::LaneInfo(const LaneInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LaneInfo::SharedCtor() {
  _cached_size_ = 0;
  pattern_ = 1;
  highlight_ = 1;
  preferred_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaneInfo::~LaneInfo() {
  SharedDtor();
}

void LaneInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LaneInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LaneInfo& LaneInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

LaneInfo* LaneInfo::default_instance_ = NULL;

LaneInfo* LaneInfo::New() const {
  return new LaneInfo;
}

void LaneInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pattern_ = 1;
    highlight_ = 1;
    preferred_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LaneInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.telenav.proto.map.LanePattern pattern = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::LanePattern_IsValid(value)) {
            set_pattern(static_cast< ::com::telenav::proto::map::LanePattern >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_highlight;
        break;
      }

      // optional .com.telenav.proto.map.HighlightedLane highlight = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_highlight:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::HighlightedLane_IsValid(value)) {
            set_highlight(static_cast< ::com::telenav::proto::map::HighlightedLane >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_preferred;
        break;
      }

      // optional bool preferred = 3 [default = false];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_preferred:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &preferred_)));
          set_has_preferred();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LaneInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .com.telenav.proto.map.LanePattern pattern = 1;
  if (has_pattern()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->pattern(), output);
  }

  // optional .com.telenav.proto.map.HighlightedLane highlight = 2;
  if (has_highlight()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->highlight(), output);
  }

  // optional bool preferred = 3 [default = false];
  if (has_preferred()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->preferred(), output);
  }

}

int LaneInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .com.telenav.proto.map.LanePattern pattern = 1;
    if (has_pattern()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->pattern());
    }

    // optional .com.telenav.proto.map.HighlightedLane highlight = 2;
    if (has_highlight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->highlight());
    }

    // optional bool preferred = 3 [default = false];
    if (has_preferred()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaneInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LaneInfo*>(&from));
}

void LaneInfo::MergeFrom(const LaneInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pattern()) {
      set_pattern(from.pattern());
    }
    if (from.has_highlight()) {
      set_highlight(from.highlight());
    }
    if (from.has_preferred()) {
      set_preferred(from.preferred());
    }
  }
}

void LaneInfo::CopyFrom(const LaneInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneInfo::IsInitialized() const {

  return true;
}

void LaneInfo::Swap(LaneInfo* other) {
  if (other != this) {
    std::swap(pattern_, other->pattern_);
    std::swap(highlight_, other->highlight_);
    std::swap(preferred_, other->preferred_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LaneInfo::GetTypeName() const {
  return "com.telenav.proto.map.LaneInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int JunctionView::kTypeFieldNumber;
const int JunctionView::kPatternIdFieldNumber;
const int JunctionView::kArrowIdFieldNumber;
#endif  // !_MSC_VER

JunctionView::JunctionView()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void JunctionView::InitAsDefaultInstance() {
}

JunctionView::JunctionView(const JunctionView& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void JunctionView::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  pattern_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  arrow_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JunctionView::~JunctionView() {
  SharedDtor();
}

void JunctionView::SharedDtor() {
  if (pattern_id_ != &::google::protobuf::internal::kEmptyString) {
    delete pattern_id_;
  }
  if (arrow_id_ != &::google::protobuf::internal::kEmptyString) {
    delete arrow_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void JunctionView::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const JunctionView& JunctionView::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2edirections_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2edirections_2eproto();
#endif
  return *default_instance_;
}

JunctionView* JunctionView::default_instance_ = NULL;

JunctionView* JunctionView::New() const {
  return new JunctionView;
}

void JunctionView::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_pattern_id()) {
      if (pattern_id_ != &::google::protobuf::internal::kEmptyString) {
        pattern_id_->clear();
      }
    }
    if (has_arrow_id()) {
      if (arrow_id_ != &::google::protobuf::internal::kEmptyString) {
        arrow_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool JunctionView::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .com.telenav.proto.map.JunctionViewType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::JunctionViewType_IsValid(value)) {
            set_type(static_cast< ::com::telenav::proto::map::JunctionViewType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pattern_id;
        break;
      }

      // optional string pattern_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pattern_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pattern_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_arrow_id;
        break;
      }

      // optional string arrow_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_arrow_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_arrow_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void JunctionView::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .com.telenav.proto.map.JunctionViewType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional string pattern_id = 2;
  if (has_pattern_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->pattern_id(), output);
  }

  // optional string arrow_id = 3;
  if (has_arrow_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->arrow_id(), output);
  }

}

int JunctionView::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .com.telenav.proto.map.JunctionViewType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string pattern_id = 2;
    if (has_pattern_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pattern_id());
    }

    // optional string arrow_id = 3;
    if (has_arrow_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->arrow_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JunctionView::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const JunctionView*>(&from));
}

void JunctionView::MergeFrom(const JunctionView& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_pattern_id()) {
      set_pattern_id(from.pattern_id());
    }
    if (from.has_arrow_id()) {
      set_arrow_id(from.arrow_id());
    }
  }
}

void JunctionView::CopyFrom(const JunctionView& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JunctionView::IsInitialized() const {

  return true;
}

void JunctionView::Swap(JunctionView* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(pattern_id_, other->pattern_id_);
    std::swap(arrow_id_, other->arrow_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string JunctionView::GetTypeName() const {
  return "com.telenav.proto.map.JunctionView";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace map
}  // namespace proto
}  // namespace telenav
}  // namespace com

// @@protoc_insertion_point(global_scope)
