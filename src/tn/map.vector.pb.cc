// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map.vector.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mapnik/map.vector.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace telenav {
namespace proto {
namespace map {

namespace {

const ::google::protobuf::Descriptor* VectorMapRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VectorMapRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* TfcObj_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TfcObj_reflection_ = NULL;
const ::google::protobuf::Descriptor* Polygon_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Polygon_reflection_ = NULL;
const ::google::protobuf::Descriptor* Polyline_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Polyline_reflection_ = NULL;
const ::google::protobuf::Descriptor* VectorTrafficTile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VectorTrafficTile_reflection_ = NULL;
const ::google::protobuf::Descriptor* VectorMapTile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VectorMapTile_reflection_ = NULL;
const ::google::protobuf::Descriptor* FeatureName_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FeatureName_reflection_ = NULL;
const ::google::protobuf::Descriptor* HighwayShield_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HighwayShield_reflection_ = NULL;
const ::google::protobuf::Descriptor* RoadFeature_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RoadFeature_reflection_ = NULL;
const ::google::protobuf::Descriptor* AreaFeature_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AreaFeature_reflection_ = NULL;
const ::google::protobuf::Descriptor* LineFeature_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LineFeature_reflection_ = NULL;
const ::google::protobuf::Descriptor* PointFeature_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PointFeature_reflection_ = NULL;
const ::google::protobuf::Descriptor* BuildingBlockRef_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BuildingBlockRef_reflection_ = NULL;
const ::google::protobuf::Descriptor* BuildingBlockList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BuildingBlockList_reflection_ = NULL;
const ::google::protobuf::Descriptor* BigTileConfig_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BigTileConfig_reflection_ = NULL;
const ::google::protobuf::Descriptor* ZoomLevel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ZoomLevel_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RoadSubType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RoadDirection_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RoadFunctionClass_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* AreaType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RingOrientation_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* PointType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* LineType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* FontStyle_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_map_2evector_2eproto() {
  protobuf_AddDesc_map_2evector_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "map.vector.proto");
  GOOGLE_CHECK(file != NULL);
  VectorMapRequest_descriptor_ = file->message_type(0);
  static const int VectorMapRequest_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapRequest, zoomlevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapRequest, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapRequest, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapRequest, context_),
  };
  VectorMapRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VectorMapRequest_descriptor_,
      VectorMapRequest::default_instance_,
      VectorMapRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VectorMapRequest));
  TfcObj_descriptor_ = file->message_type(1);
  static const int TfcObj_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TfcObj, trafficid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TfcObj, start_idx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TfcObj, end_idx_),
  };
  TfcObj_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TfcObj_descriptor_,
      TfcObj::default_instance_,
      TfcObj_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TfcObj, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TfcObj, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TfcObj));
  Polygon_descriptor_ = file->message_type(2);
  static const int Polygon_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, latlon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, orient_),
  };
  Polygon_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Polygon_descriptor_,
      Polygon::default_instance_,
      Polygon_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Polygon));
  Polyline_descriptor_ = file->message_type(3);
  static const int Polyline_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polyline, latlon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polyline, tfcid_right_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polyline, tfcid_left_),
  };
  Polyline_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Polyline_descriptor_,
      Polyline::default_instance_,
      Polyline_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polyline, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polyline, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Polyline));
  VectorTrafficTile_descriptor_ = file->message_type(4);
  static const int VectorTrafficTile_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorTrafficTile, tmcids_),
  };
  VectorTrafficTile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VectorTrafficTile_descriptor_,
      VectorTrafficTile::default_instance_,
      VectorTrafficTile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorTrafficTile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorTrafficTile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VectorTrafficTile));
  VectorMapTile_descriptor_ = file->message_type(5);
  static const int VectorMapTile_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapTile, rf_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapTile, af_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapTile, lf_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapTile, pf_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapTile, buildingblocklist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapTile, dataversion_),
  };
  VectorMapTile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VectorMapTile_descriptor_,
      VectorMapTile::default_instance_,
      VectorMapTile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapTile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorMapTile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VectorMapTile));
  FeatureName_descriptor_ = file->message_type(6);
  static const int FeatureName_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureName, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureName, alias_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureName, language_),
  };
  FeatureName_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FeatureName_descriptor_,
      FeatureName::default_instance_,
      FeatureName_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureName, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureName, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FeatureName));
  HighwayShield_descriptor_ = file->message_type(7);
  static const int HighwayShield_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HighwayShield, number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HighwayShield, iconid_),
  };
  HighwayShield_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HighwayShield_descriptor_,
      HighwayShield::default_instance_,
      HighwayShield_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HighwayShield, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HighwayShield, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HighwayShield));
  RoadFeature_descriptor_ = file->message_type(8);
  static const int RoadFeature_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadFeature, lines_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadFeature, roadtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadFeature, roadsubtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadFeature, roadname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadFeature, roadalias_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadFeature, featureid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadFeature, roadnames_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadFeature, shields_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadFeature, roadfunctionclass_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadFeature, roaddirection_),
  };
  RoadFeature_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RoadFeature_descriptor_,
      RoadFeature::default_instance_,
      RoadFeature_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadFeature, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadFeature, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RoadFeature));
  AreaFeature_descriptor_ = file->message_type(9);
  static const int AreaFeature_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AreaFeature, rings_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AreaFeature, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AreaFeature, maintype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AreaFeature, subtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AreaFeature, featureid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AreaFeature, areanames_),
  };
  AreaFeature_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AreaFeature_descriptor_,
      AreaFeature::default_instance_,
      AreaFeature_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AreaFeature, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AreaFeature, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AreaFeature));
  LineFeature_descriptor_ = file->message_type(10);
  static const int LineFeature_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LineFeature, lines_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LineFeature, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LineFeature, maintype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LineFeature, subtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LineFeature, featureid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LineFeature, names_),
  };
  LineFeature_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LineFeature_descriptor_,
      LineFeature::default_instance_,
      LineFeature_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LineFeature, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LineFeature, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LineFeature));
  PointFeature_descriptor_ = file->message_type(11);
  static const int PointFeature_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, latlon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, maintype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, subtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, fontsize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, country_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, rdnameori_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, fontstyle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, spline_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, p_featureid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, featureid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, pointnames_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, landmark_icon_),
  };
  PointFeature_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PointFeature_descriptor_,
      PointFeature::default_instance_,
      PointFeature_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointFeature, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PointFeature));
  BuildingBlockRef_descriptor_ = file->message_type(12);
  static const int BuildingBlockRef_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlockRef, depth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlockRef, col_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlockRef, row_),
  };
  BuildingBlockRef_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BuildingBlockRef_descriptor_,
      BuildingBlockRef::default_instance_,
      BuildingBlockRef_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlockRef, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlockRef, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BuildingBlockRef));
  BuildingBlockList_descriptor_ = file->message_type(13);
  static const int BuildingBlockList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlockList, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlockList, blockrefs_),
  };
  BuildingBlockList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BuildingBlockList_descriptor_,
      BuildingBlockList::default_instance_,
      BuildingBlockList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlockList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlockList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BuildingBlockList));
  BigTileConfig_descriptor_ = file->message_type(14);
  static const int BigTileConfig_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BigTileConfig, zoomlevel_),
  };
  BigTileConfig_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BigTileConfig_descriptor_,
      BigTileConfig::default_instance_,
      BigTileConfig_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BigTileConfig, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BigTileConfig, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BigTileConfig));
  ZoomLevel_descriptor_ = file->message_type(15);
  static const int ZoomLevel_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ZoomLevel, level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ZoomLevel, power_),
  };
  ZoomLevel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ZoomLevel_descriptor_,
      ZoomLevel::default_instance_,
      ZoomLevel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ZoomLevel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ZoomLevel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ZoomLevel));
  RoadSubType_descriptor_ = file->enum_type(0);
  RoadDirection_descriptor_ = file->enum_type(1);
  RoadFunctionClass_descriptor_ = file->enum_type(2);
  AreaType_descriptor_ = file->enum_type(3);
  RingOrientation_descriptor_ = file->enum_type(4);
  PointType_descriptor_ = file->enum_type(5);
  LineType_descriptor_ = file->enum_type(6);
  FontStyle_descriptor_ = file->enum_type(7);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_map_2evector_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VectorMapRequest_descriptor_, &VectorMapRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TfcObj_descriptor_, &TfcObj::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Polygon_descriptor_, &Polygon::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Polyline_descriptor_, &Polyline::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VectorTrafficTile_descriptor_, &VectorTrafficTile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VectorMapTile_descriptor_, &VectorMapTile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FeatureName_descriptor_, &FeatureName::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HighwayShield_descriptor_, &HighwayShield::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RoadFeature_descriptor_, &RoadFeature::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AreaFeature_descriptor_, &AreaFeature::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LineFeature_descriptor_, &LineFeature::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PointFeature_descriptor_, &PointFeature::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BuildingBlockRef_descriptor_, &BuildingBlockRef::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BuildingBlockList_descriptor_, &BuildingBlockList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BigTileConfig_descriptor_, &BigTileConfig::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ZoomLevel_descriptor_, &ZoomLevel::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_map_2evector_2eproto() {
  delete VectorMapRequest::default_instance_;
  delete VectorMapRequest_reflection_;
  delete TfcObj::default_instance_;
  delete TfcObj_reflection_;
  delete Polygon::default_instance_;
  delete Polygon_reflection_;
  delete Polyline::default_instance_;
  delete Polyline_reflection_;
  delete VectorTrafficTile::default_instance_;
  delete VectorTrafficTile_reflection_;
  delete VectorMapTile::default_instance_;
  delete VectorMapTile_reflection_;
  delete FeatureName::default_instance_;
  delete FeatureName_reflection_;
  delete HighwayShield::default_instance_;
  delete HighwayShield_reflection_;
  delete RoadFeature::default_instance_;
  delete RoadFeature_reflection_;
  delete AreaFeature::default_instance_;
  delete AreaFeature_reflection_;
  delete LineFeature::default_instance_;
  delete LineFeature_reflection_;
  delete PointFeature::default_instance_;
  delete PointFeature_reflection_;
  delete BuildingBlockRef::default_instance_;
  delete BuildingBlockRef_reflection_;
  delete BuildingBlockList::default_instance_;
  delete BuildingBlockList_reflection_;
  delete BigTileConfig::default_instance_;
  delete BigTileConfig_reflection_;
  delete ZoomLevel::default_instance_;
  delete ZoomLevel_reflection_;
}

void protobuf_AddDesc_map_2evector_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::com::telenav::proto::protobuf_AddDesc_common_2eproto();
  ::com::telenav::proto::map::protobuf_AddDesc_map_2ecommon_2eproto();
  ::com::telenav::proto::protobuf_AddDesc_services_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020map.vector.proto\022\025com.telenav.proto.ma"
    "p\032\014common.proto\032\020map.common.proto\032\016servi"
    "ces.proto\"h\n\020VectorMapRequest\022\021\n\tzoomLev"
    "el\030\001 \001(\005\022\t\n\001x\030\002 \001(\005\022\t\n\001y\030\003 \001(\005\022+\n\007contex"
    "t\030\004 \001(\0132\032.com.telenav.proto.Context\"\?\n\006T"
    "fcObj\022\021\n\ttrafficId\030\001 \001(\t\022\021\n\tstart_idx\030\002 "
    "\001(\r\022\017\n\007end_idx\030\003 \001(\r\"a\n\007Polygon\022\022\n\006latlo"
    "n\030\001 \003(\021B\002\020\001\022B\n\006orient\030\002 \001(\0162&.com.telena"
    "v.proto.map.RingOrientation:\nOR_UNKNOWN\""
    "\205\001\n\010Polyline\022\022\n\006latlon\030\001 \003(\021B\002\020\001\0222\n\013tfcI"
    "d_right\030\002 \003(\0132\035.com.telenav.proto.map.Tf"
    "cObj\0221\n\ntfcId_left\030\003 \003(\0132\035.com.telenav.p"
    "roto.map.TfcObj\"\'\n\021VectorTrafficTile\022\022\n\006"
    "tmcIds\030\001 \003(\rB\002\020\001\"\252\002\n\rVectorMapTile\022.\n\002rf"
    "\030\001 \003(\0132\".com.telenav.proto.map.RoadFeatu"
    "re\022.\n\002af\030\002 \003(\0132\".com.telenav.proto.map.A"
    "reaFeature\022.\n\002lf\030\003 \003(\0132\".com.telenav.pro"
    "to.map.LineFeature\022/\n\002pf\030\004 \003(\0132#.com.tel"
    "enav.proto.map.PointFeature\022C\n\021buildingB"
    "lockList\030\005 \001(\0132(.com.telenav.proto.map.B"
    "uildingBlockList\022\023\n\013dataVersion\030\006 \001(\t\"<\n"
    "\013FeatureName\022\014\n\004name\030\001 \001(\t\022\r\n\005alias\030\002 \001("
    "\t\022\020\n\010language\030\003 \001(\t\"/\n\rHighwayShield\022\016\n\006"
    "number\030\001 \001(\t\022\016\n\006iconID\030\002 \001(\t\"\363\003\n\013RoadFea"
    "ture\022.\n\005lines\030\001 \003(\0132\037.com.telenav.proto."
    "map.Polyline\022=\n\010roadType\030\002 \001(\0162\037.com.tel"
    "enav.proto.map.RoadType:\nRT_UNKNOWN\022D\n\013r"
    "oadSubType\030\003 \001(\0162\".com.telenav.proto.map"
    ".RoadSubType:\013RST_UNKNOWN\022\020\n\010roadName\030\004 "
    "\001(\t\022\021\n\troadAlias\030\005 \001(\t\022\021\n\tfeatureID\030\017 \001("
    "\004\0225\n\troadNames\030\006 \003(\0132\".com.telenav.proto"
    ".map.FeatureName\0225\n\007shields\030\007 \003(\0132$.com."
    "telenav.proto.map.HighwayShield\022C\n\021roadF"
    "unctionClass\030\010 \001(\0162(.com.telenav.proto.m"
    "ap.RoadFunctionClass\022D\n\rroadDirection\030\t "
    "\001(\0162$.com.telenav.proto.map.RoadDirectio"
    "n:\007UNKONWN\"\351\001\n\013AreaFeature\022-\n\005rings\030\001 \003("
    "\0132\036.com.telenav.proto.map.Polygon\022\014\n\004nam"
    "e\030\002 \001(\t\022B\n\010mainType\030\003 \001(\0162\037.com.telenav."
    "proto.map.AreaType:\017BK_AREA_UNKNOWN\022\017\n\007s"
    "ubType\030\004 \001(\t\022\021\n\tfeatureID\030\017 \001(\004\0225\n\tareaN"
    "ames\030\005 \003(\0132\".com.telenav.proto.map.Featu"
    "reName\"\346\001\n\013LineFeature\022.\n\005lines\030\001 \003(\0132\037."
    "com.telenav.proto.map.Polyline\022\014\n\004name\030\002"
    " \001(\t\022B\n\010mainType\030\003 \001(\0162\037.com.telenav.pro"
    "to.map.LineType:\017BK_LINE_UNKNOWN\022\017\n\007subT"
    "ype\030\004 \001(\t\022\021\n\tfeatureID\030\017 \001(\004\0221\n\005names\030\006 "
    "\003(\0132\".com.telenav.proto.map.FeatureName\""
    "\230\003\n\014PointFeature\022\022\n\006latlon\030\001 \003(\021B\002\020\001\022>\n\010"
    "mainType\030\002 \001(\0162 .com.telenav.proto.map.P"
    "ointType:\nPT_UNKNOWN\022\017\n\007subType\030\003 \001(\t\022\014\n"
    "\004name\030\004 \001(\t\022\020\n\010fontSize\030\005 \001(\005\022\017\n\007country"
    "\030\006 \001(\t\022\025\n\trdNameOri\030\007 \003(\005B\002\020\001\0223\n\tfontSty"
    "le\030\010 \001(\0162 .com.telenav.proto.map.FontSty"
    "le\022/\n\006spline\030\t \001(\0132\037.com.telenav.proto.m"
    "ap.Polyline\022\023\n\013p_featureID\030\016 \003(\004\022\021\n\tfeat"
    "ureID\030\017 \001(\004\0226\n\npointNames\030\n \003(\0132\".com.te"
    "lenav.proto.map.FeatureName\022\025\n\rlandmark_"
    "icon\030\013 \001(\t\";\n\020BuildingBlockRef\022\r\n\005depth\030"
    "\001 \001(\r\022\013\n\003col\030\002 \001(\r\022\013\n\003row\030\003 \001(\r\"`\n\021Build"
    "ingBlockList\022\017\n\007version\030\001 \001(\005\022:\n\tblockRe"
    "fs\030\002 \003(\0132\'.com.telenav.proto.map.Buildin"
    "gBlockRef\"D\n\rBigTileConfig\0223\n\tzoomlevel\030"
    "\001 \003(\0132 .com.telenav.proto.map.ZoomLevel\""
    ")\n\tZoomLevel\022\r\n\005level\030\001 \001(\005\022\r\n\005power\030\002 \001"
    "(\005*n\n\013RoadSubType\022\017\n\013RST_UNKNOWN\020\000\022\016\n\nRS"
    "T_COMMON\020\001\022\020\n\014RST_JUNCTION\020\002\022\014\n\010RST_RAMP"
    "\020\003\022\016\n\nRST_BRIDGE\020\004\022\016\n\nRST_TUNNEL\020\005*Q\n\rRo"
    "adDirection\022\n\n\006CLOSED\020\000\022\014\n\010POSITIVE\020\001\022\014\n"
    "\010NEGATIVE\020\002\022\013\n\007BOTHWAY\020\003\022\013\n\007UNKONWN\020\004*E\n"
    "\021RoadFunctionClass\022\010\n\004FC_1\020\001\022\010\n\004FC_2\020\002\022\010"
    "\n\004FC_3\020\003\022\010\n\004FC_4\020\004\022\010\n\004FC_5\020\005*\320\003\n\010AreaTyp"
    "e\022\023\n\017BK_AREA_UNKNOWN\020\000\022\024\n\020BK_AREA_BUILDI"
    "NG\020\001\022\024\n\020BK_AREA_WOODLAND\020\002\022\021\n\rBK_AREA_BE"
    "ACH\020\003\022\020\n\014BK_AREA_PARK\020\004\022\022\n\016BK_AREA_ISLAN"
    "D\020\005\022\023\n\017BK_AREA_AIRPORT\020\006\022\031\n\025BK_AREA_AIRC"
    "RAFT_ROAD\020\007\022\026\n\022BK_AREA_PEDESTRIAN\020\010\022\024\n\020B"
    "K_AREA_MILITARY\020\t\022\027\n\023BK_AREA_RESERVATION"
    "\020\n\022\026\n\022BK_AREA_ELEVATIONI\020\013\022\023\n\017BK_AREA_CO"
    "LONIA\020\014\022\026\n\022BK_AREA_CONGESTION\020\r\022\033\n\027BK_AR"
    "EA_HURRICANE_PRONE\020\016\022\027\n\023BK_AREA_FLOOD_PR"
    "ONE\020\017\022\031\n\025BK_AREA_TSUNAMI_PRONE\020\020\022\021\n\rBK_A"
    "REA_WATER\020\021\022\023\n\017BK_AREA_BUILTUP\020\022\022\025\n\021BK_A"
    "REA_EXPO_AREA\020\023*J\n\017RingOrientation\022\016\n\nOR"
    "_UNKNOWN\020\000\022\020\n\014OR_CLOCKWISE\020\001\022\025\n\021OR_ANTI_"
    "CLOCKWISE\020\002*\252\001\n\tPointType\022\016\n\nPT_UNKNOWN\020"
    "\000\022\013\n\007PT_ROAD\020\001\022\013\n\007PT_ICON\020\002\022\013\n\007PT_LINE\020\003"
    "\022\013\n\007PT_AREA\020\004\022\013\n\007PT_CITY\020\005\022\014\n\010PT_POINT\020\006"
    "\022\024\n\020PT_GLOBAL_CENTER\020\007\022\023\n\017PT_HOUSE_NUMBE"
    "R\020\010\022\023\n\017PT_NEIGHBORHOOD\020\t*\225\001\n\010LineType\022\023\n"
    "\017BK_LINE_UNKNOWN\020\000\022\021\n\rBK_LINE_CANAL\020\001\022\020\n"
    "\014BK_LINE_RAIL\020\002\022\022\n\016BK_LINE_BORDER\020\003\022\022\n\016B"
    "K_LINE_DENOTE\020\004\022\022\n\016BK_LINE_RUNWAY\020\005\022\023\n\017B"
    "K_LINE_TAXIWAY\020\006*E\n\tFontStyle\022\016\n\nFT_UNKN"
    "OWN\020\000\022\014\n\010FT_PLAIN\020\001\022\r\n\tFT_ITALIC\020\002\022\013\n\007FT"
    "_BOLD\020\003B%\n\025com.telenav.map.protoB\014Vector"
    "Protoc", 3846);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "map.vector.proto", &protobuf_RegisterTypes);
  VectorMapRequest::default_instance_ = new VectorMapRequest();
  TfcObj::default_instance_ = new TfcObj();
  Polygon::default_instance_ = new Polygon();
  Polyline::default_instance_ = new Polyline();
  VectorTrafficTile::default_instance_ = new VectorTrafficTile();
  VectorMapTile::default_instance_ = new VectorMapTile();
  FeatureName::default_instance_ = new FeatureName();
  HighwayShield::default_instance_ = new HighwayShield();
  RoadFeature::default_instance_ = new RoadFeature();
  AreaFeature::default_instance_ = new AreaFeature();
  LineFeature::default_instance_ = new LineFeature();
  PointFeature::default_instance_ = new PointFeature();
  BuildingBlockRef::default_instance_ = new BuildingBlockRef();
  BuildingBlockList::default_instance_ = new BuildingBlockList();
  BigTileConfig::default_instance_ = new BigTileConfig();
  ZoomLevel::default_instance_ = new ZoomLevel();
  VectorMapRequest::default_instance_->InitAsDefaultInstance();
  TfcObj::default_instance_->InitAsDefaultInstance();
  Polygon::default_instance_->InitAsDefaultInstance();
  Polyline::default_instance_->InitAsDefaultInstance();
  VectorTrafficTile::default_instance_->InitAsDefaultInstance();
  VectorMapTile::default_instance_->InitAsDefaultInstance();
  FeatureName::default_instance_->InitAsDefaultInstance();
  HighwayShield::default_instance_->InitAsDefaultInstance();
  RoadFeature::default_instance_->InitAsDefaultInstance();
  AreaFeature::default_instance_->InitAsDefaultInstance();
  LineFeature::default_instance_->InitAsDefaultInstance();
  PointFeature::default_instance_->InitAsDefaultInstance();
  BuildingBlockRef::default_instance_->InitAsDefaultInstance();
  BuildingBlockList::default_instance_->InitAsDefaultInstance();
  BigTileConfig::default_instance_->InitAsDefaultInstance();
  ZoomLevel::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_map_2evector_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_map_2evector_2eproto {
  StaticDescriptorInitializer_map_2evector_2eproto() {
    protobuf_AddDesc_map_2evector_2eproto();
  }
} static_descriptor_initializer_map_2evector_2eproto_;
const ::google::protobuf::EnumDescriptor* RoadSubType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RoadSubType_descriptor_;
}
bool RoadSubType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RoadDirection_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RoadDirection_descriptor_;
}
bool RoadDirection_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RoadFunctionClass_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RoadFunctionClass_descriptor_;
}
bool RoadFunctionClass_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* AreaType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AreaType_descriptor_;
}
bool AreaType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RingOrientation_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RingOrientation_descriptor_;
}
bool RingOrientation_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PointType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PointType_descriptor_;
}
bool PointType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* LineType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LineType_descriptor_;
}
bool LineType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* FontStyle_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FontStyle_descriptor_;
}
bool FontStyle_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int VectorMapRequest::kZoomLevelFieldNumber;
const int VectorMapRequest::kXFieldNumber;
const int VectorMapRequest::kYFieldNumber;
const int VectorMapRequest::kContextFieldNumber;
#endif  // !_MSC_VER

VectorMapRequest::VectorMapRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VectorMapRequest::InitAsDefaultInstance() {
  context_ = const_cast< ::com::telenav::proto::Context*>(&::com::telenav::proto::Context::default_instance());
}

VectorMapRequest::VectorMapRequest(const VectorMapRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VectorMapRequest::SharedCtor() {
  _cached_size_ = 0;
  zoomlevel_ = 0;
  x_ = 0;
  y_ = 0;
  context_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VectorMapRequest::~VectorMapRequest() {
  SharedDtor();
}

void VectorMapRequest::SharedDtor() {
  if (this != default_instance_) {
    delete context_;
  }
}

void VectorMapRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VectorMapRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VectorMapRequest_descriptor_;
}

const VectorMapRequest& VectorMapRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

VectorMapRequest* VectorMapRequest::default_instance_ = NULL;

VectorMapRequest* VectorMapRequest::New() const {
  return new VectorMapRequest;
}

void VectorMapRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    zoomlevel_ = 0;
    x_ = 0;
    y_ = 0;
    if (has_context()) {
      if (context_ != NULL) context_->::com::telenav::proto::Context::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VectorMapRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 zoomLevel = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zoomlevel_)));
          set_has_zoomlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // optional int32 x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // optional int32 y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_context;
        break;
      }

      // optional .com.telenav.proto.Context context = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_context:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_context()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VectorMapRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 zoomLevel = 1;
  if (has_zoomlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->zoomlevel(), output);
  }

  // optional int32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // optional int32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

  // optional .com.telenav.proto.Context context = 4;
  if (has_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->context(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VectorMapRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 zoomLevel = 1;
  if (has_zoomlevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->zoomlevel(), target);
  }

  // optional int32 x = 2;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->x(), target);
  }

  // optional int32 y = 3;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->y(), target);
  }

  // optional .com.telenav.proto.Context context = 4;
  if (has_context()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->context(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VectorMapRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 zoomLevel = 1;
    if (has_zoomlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->zoomlevel());
    }

    // optional int32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

    // optional .com.telenav.proto.Context context = 4;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->context());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VectorMapRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VectorMapRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VectorMapRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VectorMapRequest::MergeFrom(const VectorMapRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_zoomlevel()) {
      set_zoomlevel(from.zoomlevel());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_context()) {
      mutable_context()->::com::telenav::proto::Context::MergeFrom(from.context());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VectorMapRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VectorMapRequest::CopyFrom(const VectorMapRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorMapRequest::IsInitialized() const {

  if (has_context()) {
    if (!this->context().IsInitialized()) return false;
  }
  return true;
}

void VectorMapRequest::Swap(VectorMapRequest* other) {
  if (other != this) {
    std::swap(zoomlevel_, other->zoomlevel_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(context_, other->context_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VectorMapRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VectorMapRequest_descriptor_;
  metadata.reflection = VectorMapRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TfcObj::kTrafficIdFieldNumber;
const int TfcObj::kStartIdxFieldNumber;
const int TfcObj::kEndIdxFieldNumber;
#endif  // !_MSC_VER

TfcObj::TfcObj()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TfcObj::InitAsDefaultInstance() {
}

TfcObj::TfcObj(const TfcObj& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TfcObj::SharedCtor() {
  _cached_size_ = 0;
  trafficid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  start_idx_ = 0u;
  end_idx_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TfcObj::~TfcObj() {
  SharedDtor();
}

void TfcObj::SharedDtor() {
  if (trafficid_ != &::google::protobuf::internal::kEmptyString) {
    delete trafficid_;
  }
  if (this != default_instance_) {
  }
}

void TfcObj::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TfcObj::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TfcObj_descriptor_;
}

const TfcObj& TfcObj::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

TfcObj* TfcObj::default_instance_ = NULL;

TfcObj* TfcObj::New() const {
  return new TfcObj;
}

void TfcObj::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_trafficid()) {
      if (trafficid_ != &::google::protobuf::internal::kEmptyString) {
        trafficid_->clear();
      }
    }
    start_idx_ = 0u;
    end_idx_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TfcObj::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string trafficId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_trafficid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->trafficid().data(), this->trafficid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_start_idx;
        break;
      }

      // optional uint32 start_idx = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start_idx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &start_idx_)));
          set_has_start_idx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_end_idx;
        break;
      }

      // optional uint32 end_idx = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_idx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_idx_)));
          set_has_end_idx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TfcObj::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string trafficId = 1;
  if (has_trafficid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->trafficid().data(), this->trafficid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->trafficid(), output);
  }

  // optional uint32 start_idx = 2;
  if (has_start_idx()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->start_idx(), output);
  }

  // optional uint32 end_idx = 3;
  if (has_end_idx()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->end_idx(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TfcObj::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string trafficId = 1;
  if (has_trafficid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->trafficid().data(), this->trafficid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->trafficid(), target);
  }

  // optional uint32 start_idx = 2;
  if (has_start_idx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->start_idx(), target);
  }

  // optional uint32 end_idx = 3;
  if (has_end_idx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->end_idx(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TfcObj::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string trafficId = 1;
    if (has_trafficid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->trafficid());
    }

    // optional uint32 start_idx = 2;
    if (has_start_idx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->start_idx());
    }

    // optional uint32 end_idx = 3;
    if (has_end_idx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_idx());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TfcObj::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TfcObj* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TfcObj*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TfcObj::MergeFrom(const TfcObj& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trafficid()) {
      set_trafficid(from.trafficid());
    }
    if (from.has_start_idx()) {
      set_start_idx(from.start_idx());
    }
    if (from.has_end_idx()) {
      set_end_idx(from.end_idx());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TfcObj::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TfcObj::CopyFrom(const TfcObj& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TfcObj::IsInitialized() const {

  return true;
}

void TfcObj::Swap(TfcObj* other) {
  if (other != this) {
    std::swap(trafficid_, other->trafficid_);
    std::swap(start_idx_, other->start_idx_);
    std::swap(end_idx_, other->end_idx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TfcObj::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TfcObj_descriptor_;
  metadata.reflection = TfcObj_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Polygon::kLatlonFieldNumber;
const int Polygon::kOrientFieldNumber;
#endif  // !_MSC_VER

Polygon::Polygon()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Polygon::InitAsDefaultInstance() {
}

Polygon::Polygon(const Polygon& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Polygon::SharedCtor() {
  _cached_size_ = 0;
  orient_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Polygon::~Polygon() {
  SharedDtor();
}

void Polygon::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Polygon::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Polygon::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Polygon_descriptor_;
}

const Polygon& Polygon::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

Polygon* Polygon::default_instance_ = NULL;

Polygon* Polygon::New() const {
  return new Polygon;
}

void Polygon::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    orient_ = 0;
  }
  latlon_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Polygon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated sint32 latlon = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, this->mutable_latlon())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 1, 10, input, this->mutable_latlon())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_orient;
        break;
      }

      // optional .com.telenav.proto.map.RingOrientation orient = 2 [default = OR_UNKNOWN];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_orient:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::RingOrientation_IsValid(value)) {
            set_orient(static_cast< ::com::telenav::proto::map::RingOrientation >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Polygon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated sint32 latlon = 1 [packed = true];
  if (this->latlon_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_latlon_cached_byte_size_);
  }
  for (int i = 0; i < this->latlon_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32NoTag(
      this->latlon(i), output);
  }

  // optional .com.telenav.proto.map.RingOrientation orient = 2 [default = OR_UNKNOWN];
  if (has_orient()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->orient(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Polygon::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated sint32 latlon = 1 [packed = true];
  if (this->latlon_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      1,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _latlon_cached_byte_size_, target);
  }
  for (int i = 0; i < this->latlon_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteSInt32NoTagToArray(this->latlon(i), target);
  }

  // optional .com.telenav.proto.map.RingOrientation orient = 2 [default = OR_UNKNOWN];
  if (has_orient()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->orient(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Polygon::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .com.telenav.proto.map.RingOrientation orient = 2 [default = OR_UNKNOWN];
    if (has_orient()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->orient());
    }

  }
  // repeated sint32 latlon = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->latlon_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        SInt32Size(this->latlon(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _latlon_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Polygon::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Polygon* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Polygon*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Polygon::MergeFrom(const Polygon& from) {
  GOOGLE_CHECK_NE(&from, this);
  latlon_.MergeFrom(from.latlon_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_orient()) {
      set_orient(from.orient());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Polygon::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Polygon::CopyFrom(const Polygon& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polygon::IsInitialized() const {

  return true;
}

void Polygon::Swap(Polygon* other) {
  if (other != this) {
    latlon_.Swap(&other->latlon_);
    std::swap(orient_, other->orient_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Polygon::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Polygon_descriptor_;
  metadata.reflection = Polygon_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Polyline::kLatlonFieldNumber;
const int Polyline::kTfcIdRightFieldNumber;
const int Polyline::kTfcIdLeftFieldNumber;
#endif  // !_MSC_VER

Polyline::Polyline()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Polyline::InitAsDefaultInstance() {
}

Polyline::Polyline(const Polyline& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Polyline::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Polyline::~Polyline() {
  SharedDtor();
}

void Polyline::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Polyline::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Polyline::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Polyline_descriptor_;
}

const Polyline& Polyline::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

Polyline* Polyline::default_instance_ = NULL;

Polyline* Polyline::New() const {
  return new Polyline;
}

void Polyline::Clear() {
  latlon_.Clear();
  tfcid_right_.Clear();
  tfcid_left_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Polyline::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated sint32 latlon = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, this->mutable_latlon())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 1, 10, input, this->mutable_latlon())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tfcId_right;
        break;
      }

      // repeated .com.telenav.proto.map.TfcObj tfcId_right = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tfcId_right:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tfcid_right()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tfcId_right;
        if (input->ExpectTag(26)) goto parse_tfcId_left;
        break;
      }

      // repeated .com.telenav.proto.map.TfcObj tfcId_left = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tfcId_left:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tfcid_left()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tfcId_left;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Polyline::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated sint32 latlon = 1 [packed = true];
  if (this->latlon_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_latlon_cached_byte_size_);
  }
  for (int i = 0; i < this->latlon_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32NoTag(
      this->latlon(i), output);
  }

  // repeated .com.telenav.proto.map.TfcObj tfcId_right = 2;
  for (int i = 0; i < this->tfcid_right_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->tfcid_right(i), output);
  }

  // repeated .com.telenav.proto.map.TfcObj tfcId_left = 3;
  for (int i = 0; i < this->tfcid_left_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->tfcid_left(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Polyline::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated sint32 latlon = 1 [packed = true];
  if (this->latlon_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      1,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _latlon_cached_byte_size_, target);
  }
  for (int i = 0; i < this->latlon_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteSInt32NoTagToArray(this->latlon(i), target);
  }

  // repeated .com.telenav.proto.map.TfcObj tfcId_right = 2;
  for (int i = 0; i < this->tfcid_right_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->tfcid_right(i), target);
  }

  // repeated .com.telenav.proto.map.TfcObj tfcId_left = 3;
  for (int i = 0; i < this->tfcid_left_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->tfcid_left(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Polyline::ByteSize() const {
  int total_size = 0;

  // repeated sint32 latlon = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->latlon_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        SInt32Size(this->latlon(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _latlon_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated .com.telenav.proto.map.TfcObj tfcId_right = 2;
  total_size += 1 * this->tfcid_right_size();
  for (int i = 0; i < this->tfcid_right_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tfcid_right(i));
  }

  // repeated .com.telenav.proto.map.TfcObj tfcId_left = 3;
  total_size += 1 * this->tfcid_left_size();
  for (int i = 0; i < this->tfcid_left_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tfcid_left(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Polyline::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Polyline* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Polyline*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Polyline::MergeFrom(const Polyline& from) {
  GOOGLE_CHECK_NE(&from, this);
  latlon_.MergeFrom(from.latlon_);
  tfcid_right_.MergeFrom(from.tfcid_right_);
  tfcid_left_.MergeFrom(from.tfcid_left_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Polyline::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Polyline::CopyFrom(const Polyline& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polyline::IsInitialized() const {

  return true;
}

void Polyline::Swap(Polyline* other) {
  if (other != this) {
    latlon_.Swap(&other->latlon_);
    tfcid_right_.Swap(&other->tfcid_right_);
    tfcid_left_.Swap(&other->tfcid_left_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Polyline::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Polyline_descriptor_;
  metadata.reflection = Polyline_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VectorTrafficTile::kTmcIdsFieldNumber;
#endif  // !_MSC_VER

VectorTrafficTile::VectorTrafficTile()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VectorTrafficTile::InitAsDefaultInstance() {
}

VectorTrafficTile::VectorTrafficTile(const VectorTrafficTile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VectorTrafficTile::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VectorTrafficTile::~VectorTrafficTile() {
  SharedDtor();
}

void VectorTrafficTile::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VectorTrafficTile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VectorTrafficTile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VectorTrafficTile_descriptor_;
}

const VectorTrafficTile& VectorTrafficTile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

VectorTrafficTile* VectorTrafficTile::default_instance_ = NULL;

VectorTrafficTile* VectorTrafficTile::New() const {
  return new VectorTrafficTile;
}

void VectorTrafficTile::Clear() {
  tmcids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VectorTrafficTile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 tmcIds = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_tmcids())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 10, input, this->mutable_tmcids())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VectorTrafficTile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 tmcIds = 1 [packed = true];
  if (this->tmcids_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_tmcids_cached_byte_size_);
  }
  for (int i = 0; i < this->tmcids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->tmcids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VectorTrafficTile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint32 tmcIds = 1 [packed = true];
  if (this->tmcids_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      1,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _tmcids_cached_byte_size_, target);
  }
  for (int i = 0; i < this->tmcids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->tmcids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VectorTrafficTile::ByteSize() const {
  int total_size = 0;

  // repeated uint32 tmcIds = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->tmcids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->tmcids(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _tmcids_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VectorTrafficTile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VectorTrafficTile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VectorTrafficTile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VectorTrafficTile::MergeFrom(const VectorTrafficTile& from) {
  GOOGLE_CHECK_NE(&from, this);
  tmcids_.MergeFrom(from.tmcids_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VectorTrafficTile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VectorTrafficTile::CopyFrom(const VectorTrafficTile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorTrafficTile::IsInitialized() const {

  return true;
}

void VectorTrafficTile::Swap(VectorTrafficTile* other) {
  if (other != this) {
    tmcids_.Swap(&other->tmcids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VectorTrafficTile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VectorTrafficTile_descriptor_;
  metadata.reflection = VectorTrafficTile_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VectorMapTile::kRfFieldNumber;
const int VectorMapTile::kAfFieldNumber;
const int VectorMapTile::kLfFieldNumber;
const int VectorMapTile::kPfFieldNumber;
const int VectorMapTile::kBuildingBlockListFieldNumber;
const int VectorMapTile::kDataVersionFieldNumber;
#endif  // !_MSC_VER

VectorMapTile::VectorMapTile()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VectorMapTile::InitAsDefaultInstance() {
  buildingblocklist_ = const_cast< ::com::telenav::proto::map::BuildingBlockList*>(&::com::telenav::proto::map::BuildingBlockList::default_instance());
}

VectorMapTile::VectorMapTile(const VectorMapTile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VectorMapTile::SharedCtor() {
  _cached_size_ = 0;
  buildingblocklist_ = NULL;
  dataversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VectorMapTile::~VectorMapTile() {
  SharedDtor();
}

void VectorMapTile::SharedDtor() {
  if (dataversion_ != &::google::protobuf::internal::kEmptyString) {
    delete dataversion_;
  }
  if (this != default_instance_) {
    delete buildingblocklist_;
  }
}

void VectorMapTile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VectorMapTile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VectorMapTile_descriptor_;
}

const VectorMapTile& VectorMapTile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

VectorMapTile* VectorMapTile::default_instance_ = NULL;

VectorMapTile* VectorMapTile::New() const {
  return new VectorMapTile;
}

void VectorMapTile::Clear() {
  if (_has_bits_[4 / 32] & (0xffu << (4 % 32))) {
    if (has_buildingblocklist()) {
      if (buildingblocklist_ != NULL) buildingblocklist_->::com::telenav::proto::map::BuildingBlockList::Clear();
    }
    if (has_dataversion()) {
      if (dataversion_ != &::google::protobuf::internal::kEmptyString) {
        dataversion_->clear();
      }
    }
  }
  rf_.Clear();
  af_.Clear();
  lf_.Clear();
  pf_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VectorMapTile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.RoadFeature rf = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_rf;
        if (input->ExpectTag(18)) goto parse_af;
        break;
      }

      // repeated .com.telenav.proto.map.AreaFeature af = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_af:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_af()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_af;
        if (input->ExpectTag(26)) goto parse_lf;
        break;
      }

      // repeated .com.telenav.proto.map.LineFeature lf = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_lf;
        if (input->ExpectTag(34)) goto parse_pf;
        break;
      }

      // repeated .com.telenav.proto.map.PointFeature pf = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_pf;
        if (input->ExpectTag(42)) goto parse_buildingBlockList;
        break;
      }

      // optional .com.telenav.proto.map.BuildingBlockList buildingBlockList = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_buildingBlockList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_buildingblocklist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_dataVersion;
        break;
      }

      // optional string dataVersion = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dataVersion:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dataversion()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->dataversion().data(), this->dataversion().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VectorMapTile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.RoadFeature rf = 1;
  for (int i = 0; i < this->rf_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->rf(i), output);
  }

  // repeated .com.telenav.proto.map.AreaFeature af = 2;
  for (int i = 0; i < this->af_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->af(i), output);
  }

  // repeated .com.telenav.proto.map.LineFeature lf = 3;
  for (int i = 0; i < this->lf_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->lf(i), output);
  }

  // repeated .com.telenav.proto.map.PointFeature pf = 4;
  for (int i = 0; i < this->pf_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->pf(i), output);
  }

  // optional .com.telenav.proto.map.BuildingBlockList buildingBlockList = 5;
  if (has_buildingblocklist()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->buildingblocklist(), output);
  }

  // optional string dataVersion = 6;
  if (has_dataversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->dataversion().data(), this->dataversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->dataversion(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VectorMapTile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .com.telenav.proto.map.RoadFeature rf = 1;
  for (int i = 0; i < this->rf_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->rf(i), target);
  }

  // repeated .com.telenav.proto.map.AreaFeature af = 2;
  for (int i = 0; i < this->af_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->af(i), target);
  }

  // repeated .com.telenav.proto.map.LineFeature lf = 3;
  for (int i = 0; i < this->lf_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->lf(i), target);
  }

  // repeated .com.telenav.proto.map.PointFeature pf = 4;
  for (int i = 0; i < this->pf_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->pf(i), target);
  }

  // optional .com.telenav.proto.map.BuildingBlockList buildingBlockList = 5;
  if (has_buildingblocklist()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->buildingblocklist(), target);
  }

  // optional string dataVersion = 6;
  if (has_dataversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->dataversion().data(), this->dataversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->dataversion(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VectorMapTile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[4 / 32] & (0xffu << (4 % 32))) {
    // optional .com.telenav.proto.map.BuildingBlockList buildingBlockList = 5;
    if (has_buildingblocklist()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->buildingblocklist());
    }

    // optional string dataVersion = 6;
    if (has_dataversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dataversion());
    }

  }
  // repeated .com.telenav.proto.map.RoadFeature rf = 1;
  total_size += 1 * this->rf_size();
  for (int i = 0; i < this->rf_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rf(i));
  }

  // repeated .com.telenav.proto.map.AreaFeature af = 2;
  total_size += 1 * this->af_size();
  for (int i = 0; i < this->af_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->af(i));
  }

  // repeated .com.telenav.proto.map.LineFeature lf = 3;
  total_size += 1 * this->lf_size();
  for (int i = 0; i < this->lf_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lf(i));
  }

  // repeated .com.telenav.proto.map.PointFeature pf = 4;
  total_size += 1 * this->pf_size();
  for (int i = 0; i < this->pf_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pf(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VectorMapTile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VectorMapTile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VectorMapTile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VectorMapTile::MergeFrom(const VectorMapTile& from) {
  GOOGLE_CHECK_NE(&from, this);
  rf_.MergeFrom(from.rf_);
  af_.MergeFrom(from.af_);
  lf_.MergeFrom(from.lf_);
  pf_.MergeFrom(from.pf_);
  if (from._has_bits_[4 / 32] & (0xffu << (4 % 32))) {
    if (from.has_buildingblocklist()) {
      mutable_buildingblocklist()->::com::telenav::proto::map::BuildingBlockList::MergeFrom(from.buildingblocklist());
    }
    if (from.has_dataversion()) {
      set_dataversion(from.dataversion());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VectorMapTile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VectorMapTile::CopyFrom(const VectorMapTile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorMapTile::IsInitialized() const {

  return true;
}

void VectorMapTile::Swap(VectorMapTile* other) {
  if (other != this) {
    rf_.Swap(&other->rf_);
    af_.Swap(&other->af_);
    lf_.Swap(&other->lf_);
    pf_.Swap(&other->pf_);
    std::swap(buildingblocklist_, other->buildingblocklist_);
    std::swap(dataversion_, other->dataversion_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VectorMapTile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VectorMapTile_descriptor_;
  metadata.reflection = VectorMapTile_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FeatureName::kNameFieldNumber;
const int FeatureName::kAliasFieldNumber;
const int FeatureName::kLanguageFieldNumber;
#endif  // !_MSC_VER

FeatureName::FeatureName()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FeatureName::InitAsDefaultInstance() {
}

FeatureName::FeatureName(const FeatureName& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FeatureName::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FeatureName::~FeatureName() {
  SharedDtor();
}

void FeatureName::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (this != default_instance_) {
  }
}

void FeatureName::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FeatureName::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FeatureName_descriptor_;
}

const FeatureName& FeatureName::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

FeatureName* FeatureName::default_instance_ = NULL;

FeatureName* FeatureName::New() const {
  return new FeatureName;
}

void FeatureName::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_alias()) {
      if (alias_ != &::google::protobuf::internal::kEmptyString) {
        alias_->clear();
      }
    }
    if (has_language()) {
      if (language_ != &::google::protobuf::internal::kEmptyString) {
        language_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FeatureName::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_alias;
        break;
      }

      // optional string alias = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_alias:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_alias()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->alias().data(), this->alias().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_language;
        break;
      }

      // optional string language = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_language:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->language().data(), this->language().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FeatureName::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->alias().data(), this->alias().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->alias(), output);
  }

  // optional string language = 3;
  if (has_language()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->language(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FeatureName::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->alias().data(), this->alias().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->alias(), target);
  }

  // optional string language = 3;
  if (has_language()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->language(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FeatureName::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string alias = 2;
    if (has_alias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->alias());
    }

    // optional string language = 3;
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FeatureName::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FeatureName* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FeatureName*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FeatureName::MergeFrom(const FeatureName& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_alias()) {
      set_alias(from.alias());
    }
    if (from.has_language()) {
      set_language(from.language());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FeatureName::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FeatureName::CopyFrom(const FeatureName& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureName::IsInitialized() const {

  return true;
}

void FeatureName::Swap(FeatureName* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(alias_, other->alias_);
    std::swap(language_, other->language_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FeatureName::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FeatureName_descriptor_;
  metadata.reflection = FeatureName_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HighwayShield::kNumberFieldNumber;
const int HighwayShield::kIconIDFieldNumber;
#endif  // !_MSC_VER

HighwayShield::HighwayShield()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HighwayShield::InitAsDefaultInstance() {
}

HighwayShield::HighwayShield(const HighwayShield& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HighwayShield::SharedCtor() {
  _cached_size_ = 0;
  number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HighwayShield::~HighwayShield() {
  SharedDtor();
}

void HighwayShield::SharedDtor() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (iconid_ != &::google::protobuf::internal::kEmptyString) {
    delete iconid_;
  }
  if (this != default_instance_) {
  }
}

void HighwayShield::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HighwayShield::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HighwayShield_descriptor_;
}

const HighwayShield& HighwayShield::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

HighwayShield* HighwayShield::default_instance_ = NULL;

HighwayShield* HighwayShield::New() const {
  return new HighwayShield;
}

void HighwayShield::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_number()) {
      if (number_ != &::google::protobuf::internal::kEmptyString) {
        number_->clear();
      }
    }
    if (has_iconid()) {
      if (iconid_ != &::google::protobuf::internal::kEmptyString) {
        iconid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HighwayShield::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string number = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_number()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->number().data(), this->number().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_iconID;
        break;
      }

      // optional string iconID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_iconID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_iconid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->iconid().data(), this->iconid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HighwayShield::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string number = 1;
  if (has_number()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->number().data(), this->number().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->number(), output);
  }

  // optional string iconID = 2;
  if (has_iconid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->iconid().data(), this->iconid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->iconid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HighwayShield::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string number = 1;
  if (has_number()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->number().data(), this->number().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->number(), target);
  }

  // optional string iconID = 2;
  if (has_iconid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->iconid().data(), this->iconid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->iconid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HighwayShield::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string number = 1;
    if (has_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->number());
    }

    // optional string iconID = 2;
    if (has_iconid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->iconid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HighwayShield::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HighwayShield* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HighwayShield*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HighwayShield::MergeFrom(const HighwayShield& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_number()) {
      set_number(from.number());
    }
    if (from.has_iconid()) {
      set_iconid(from.iconid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HighwayShield::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HighwayShield::CopyFrom(const HighwayShield& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HighwayShield::IsInitialized() const {

  return true;
}

void HighwayShield::Swap(HighwayShield* other) {
  if (other != this) {
    std::swap(number_, other->number_);
    std::swap(iconid_, other->iconid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HighwayShield::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HighwayShield_descriptor_;
  metadata.reflection = HighwayShield_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RoadFeature::kLinesFieldNumber;
const int RoadFeature::kRoadTypeFieldNumber;
const int RoadFeature::kRoadSubTypeFieldNumber;
const int RoadFeature::kRoadNameFieldNumber;
const int RoadFeature::kRoadAliasFieldNumber;
const int RoadFeature::kFeatureIDFieldNumber;
const int RoadFeature::kRoadNamesFieldNumber;
const int RoadFeature::kShieldsFieldNumber;
const int RoadFeature::kRoadFunctionClassFieldNumber;
const int RoadFeature::kRoadDirectionFieldNumber;
#endif  // !_MSC_VER

RoadFeature::RoadFeature()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RoadFeature::InitAsDefaultInstance() {
}

RoadFeature::RoadFeature(const RoadFeature& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RoadFeature::SharedCtor() {
  _cached_size_ = 0;
  roadtype_ = 0;
  roadsubtype_ = 0;
  roadname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  roadalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  featureid_ = GOOGLE_ULONGLONG(0);
  roadfunctionclass_ = 1;
  roaddirection_ = 4;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoadFeature::~RoadFeature() {
  SharedDtor();
}

void RoadFeature::SharedDtor() {
  if (roadname_ != &::google::protobuf::internal::kEmptyString) {
    delete roadname_;
  }
  if (roadalias_ != &::google::protobuf::internal::kEmptyString) {
    delete roadalias_;
  }
  if (this != default_instance_) {
  }
}

void RoadFeature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoadFeature::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RoadFeature_descriptor_;
}

const RoadFeature& RoadFeature::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

RoadFeature* RoadFeature::default_instance_ = NULL;

RoadFeature* RoadFeature::New() const {
  return new RoadFeature;
}

void RoadFeature::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    roadtype_ = 0;
    roadsubtype_ = 0;
    if (has_roadname()) {
      if (roadname_ != &::google::protobuf::internal::kEmptyString) {
        roadname_->clear();
      }
    }
    if (has_roadalias()) {
      if (roadalias_ != &::google::protobuf::internal::kEmptyString) {
        roadalias_->clear();
      }
    }
    featureid_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    roadfunctionclass_ = 1;
    roaddirection_ = 4;
  }
  lines_.Clear();
  roadnames_.Clear();
  shields_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RoadFeature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.Polyline lines = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lines:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lines()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_lines;
        if (input->ExpectTag(16)) goto parse_roadType;
        break;
      }

      // optional .com.telenav.proto.map.RoadType roadType = 2 [default = RT_UNKNOWN];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roadType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::RoadType_IsValid(value)) {
            set_roadtype(static_cast< ::com::telenav::proto::map::RoadType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_roadSubType;
        break;
      }

      // optional .com.telenav.proto.map.RoadSubType roadSubType = 3 [default = RST_UNKNOWN];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roadSubType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::RoadSubType_IsValid(value)) {
            set_roadsubtype(static_cast< ::com::telenav::proto::map::RoadSubType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_roadName;
        break;
      }

      // optional string roadName = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_roadName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_roadname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->roadname().data(), this->roadname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_roadAlias;
        break;
      }

      // optional string roadAlias = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_roadAlias:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_roadalias()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->roadalias().data(), this->roadalias().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_roadNames;
        break;
      }

      // repeated .com.telenav.proto.map.FeatureName roadNames = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_roadNames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_roadnames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_roadNames;
        if (input->ExpectTag(58)) goto parse_shields;
        break;
      }

      // repeated .com.telenav.proto.map.HighwayShield shields = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shields:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_shields()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_shields;
        if (input->ExpectTag(64)) goto parse_roadFunctionClass;
        break;
      }

      // optional .com.telenav.proto.map.RoadFunctionClass roadFunctionClass = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roadFunctionClass:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::RoadFunctionClass_IsValid(value)) {
            set_roadfunctionclass(static_cast< ::com::telenav::proto::map::RoadFunctionClass >(value));
          } else {
            mutable_unknown_fields()->AddVarint(8, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_roadDirection;
        break;
      }

      // optional .com.telenav.proto.map.RoadDirection roadDirection = 9 [default = UNKONWN];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roadDirection:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::RoadDirection_IsValid(value)) {
            set_roaddirection(static_cast< ::com::telenav::proto::map::RoadDirection >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_featureID;
        break;
      }

      // optional uint64 featureID = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_featureID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &featureid_)));
          set_has_featureid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RoadFeature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.Polyline lines = 1;
  for (int i = 0; i < this->lines_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->lines(i), output);
  }

  // optional .com.telenav.proto.map.RoadType roadType = 2 [default = RT_UNKNOWN];
  if (has_roadtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->roadtype(), output);
  }

  // optional .com.telenav.proto.map.RoadSubType roadSubType = 3 [default = RST_UNKNOWN];
  if (has_roadsubtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->roadsubtype(), output);
  }

  // optional string roadName = 4;
  if (has_roadname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->roadname().data(), this->roadname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->roadname(), output);
  }

  // optional string roadAlias = 5;
  if (has_roadalias()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->roadalias().data(), this->roadalias().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->roadalias(), output);
  }

  // repeated .com.telenav.proto.map.FeatureName roadNames = 6;
  for (int i = 0; i < this->roadnames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->roadnames(i), output);
  }

  // repeated .com.telenav.proto.map.HighwayShield shields = 7;
  for (int i = 0; i < this->shields_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->shields(i), output);
  }

  // optional .com.telenav.proto.map.RoadFunctionClass roadFunctionClass = 8;
  if (has_roadfunctionclass()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->roadfunctionclass(), output);
  }

  // optional .com.telenav.proto.map.RoadDirection roadDirection = 9 [default = UNKONWN];
  if (has_roaddirection()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->roaddirection(), output);
  }

  // optional uint64 featureID = 15;
  if (has_featureid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->featureid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RoadFeature::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .com.telenav.proto.map.Polyline lines = 1;
  for (int i = 0; i < this->lines_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->lines(i), target);
  }

  // optional .com.telenav.proto.map.RoadType roadType = 2 [default = RT_UNKNOWN];
  if (has_roadtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->roadtype(), target);
  }

  // optional .com.telenav.proto.map.RoadSubType roadSubType = 3 [default = RST_UNKNOWN];
  if (has_roadsubtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->roadsubtype(), target);
  }

  // optional string roadName = 4;
  if (has_roadname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->roadname().data(), this->roadname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->roadname(), target);
  }

  // optional string roadAlias = 5;
  if (has_roadalias()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->roadalias().data(), this->roadalias().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->roadalias(), target);
  }

  // repeated .com.telenav.proto.map.FeatureName roadNames = 6;
  for (int i = 0; i < this->roadnames_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->roadnames(i), target);
  }

  // repeated .com.telenav.proto.map.HighwayShield shields = 7;
  for (int i = 0; i < this->shields_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->shields(i), target);
  }

  // optional .com.telenav.proto.map.RoadFunctionClass roadFunctionClass = 8;
  if (has_roadfunctionclass()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->roadfunctionclass(), target);
  }

  // optional .com.telenav.proto.map.RoadDirection roadDirection = 9 [default = UNKONWN];
  if (has_roaddirection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->roaddirection(), target);
  }

  // optional uint64 featureID = 15;
  if (has_featureid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(15, this->featureid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RoadFeature::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .com.telenav.proto.map.RoadType roadType = 2 [default = RT_UNKNOWN];
    if (has_roadtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->roadtype());
    }

    // optional .com.telenav.proto.map.RoadSubType roadSubType = 3 [default = RST_UNKNOWN];
    if (has_roadsubtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->roadsubtype());
    }

    // optional string roadName = 4;
    if (has_roadname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->roadname());
    }

    // optional string roadAlias = 5;
    if (has_roadalias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->roadalias());
    }

    // optional uint64 featureID = 15;
    if (has_featureid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->featureid());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .com.telenav.proto.map.RoadFunctionClass roadFunctionClass = 8;
    if (has_roadfunctionclass()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->roadfunctionclass());
    }

    // optional .com.telenav.proto.map.RoadDirection roadDirection = 9 [default = UNKONWN];
    if (has_roaddirection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->roaddirection());
    }

  }
  // repeated .com.telenav.proto.map.Polyline lines = 1;
  total_size += 1 * this->lines_size();
  for (int i = 0; i < this->lines_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lines(i));
  }

  // repeated .com.telenav.proto.map.FeatureName roadNames = 6;
  total_size += 1 * this->roadnames_size();
  for (int i = 0; i < this->roadnames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->roadnames(i));
  }

  // repeated .com.telenav.proto.map.HighwayShield shields = 7;
  total_size += 1 * this->shields_size();
  for (int i = 0; i < this->shields_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->shields(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoadFeature::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RoadFeature* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RoadFeature*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RoadFeature::MergeFrom(const RoadFeature& from) {
  GOOGLE_CHECK_NE(&from, this);
  lines_.MergeFrom(from.lines_);
  roadnames_.MergeFrom(from.roadnames_);
  shields_.MergeFrom(from.shields_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_roadtype()) {
      set_roadtype(from.roadtype());
    }
    if (from.has_roadsubtype()) {
      set_roadsubtype(from.roadsubtype());
    }
    if (from.has_roadname()) {
      set_roadname(from.roadname());
    }
    if (from.has_roadalias()) {
      set_roadalias(from.roadalias());
    }
    if (from.has_featureid()) {
      set_featureid(from.featureid());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_roadfunctionclass()) {
      set_roadfunctionclass(from.roadfunctionclass());
    }
    if (from.has_roaddirection()) {
      set_roaddirection(from.roaddirection());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RoadFeature::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoadFeature::CopyFrom(const RoadFeature& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadFeature::IsInitialized() const {

  return true;
}

void RoadFeature::Swap(RoadFeature* other) {
  if (other != this) {
    lines_.Swap(&other->lines_);
    std::swap(roadtype_, other->roadtype_);
    std::swap(roadsubtype_, other->roadsubtype_);
    std::swap(roadname_, other->roadname_);
    std::swap(roadalias_, other->roadalias_);
    std::swap(featureid_, other->featureid_);
    roadnames_.Swap(&other->roadnames_);
    shields_.Swap(&other->shields_);
    std::swap(roadfunctionclass_, other->roadfunctionclass_);
    std::swap(roaddirection_, other->roaddirection_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RoadFeature::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RoadFeature_descriptor_;
  metadata.reflection = RoadFeature_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AreaFeature::kRingsFieldNumber;
const int AreaFeature::kNameFieldNumber;
const int AreaFeature::kMainTypeFieldNumber;
const int AreaFeature::kSubTypeFieldNumber;
const int AreaFeature::kFeatureIDFieldNumber;
const int AreaFeature::kAreaNamesFieldNumber;
#endif  // !_MSC_VER

AreaFeature::AreaFeature()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AreaFeature::InitAsDefaultInstance() {
}

AreaFeature::AreaFeature(const AreaFeature& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AreaFeature::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  maintype_ = 0;
  subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  featureid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AreaFeature::~AreaFeature() {
  SharedDtor();
}

void AreaFeature::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    delete subtype_;
  }
  if (this != default_instance_) {
  }
}

void AreaFeature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AreaFeature::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AreaFeature_descriptor_;
}

const AreaFeature& AreaFeature::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

AreaFeature* AreaFeature::default_instance_ = NULL;

AreaFeature* AreaFeature::New() const {
  return new AreaFeature;
}

void AreaFeature::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    maintype_ = 0;
    if (has_subtype()) {
      if (subtype_ != &::google::protobuf::internal::kEmptyString) {
        subtype_->clear();
      }
    }
    featureid_ = GOOGLE_ULONGLONG(0);
  }
  rings_.Clear();
  areanames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AreaFeature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.Polygon rings = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rings()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_rings;
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_mainType;
        break;
      }

      // optional .com.telenav.proto.map.AreaType mainType = 3 [default = BK_AREA_UNKNOWN];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mainType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::AreaType_IsValid(value)) {
            set_maintype(static_cast< ::com::telenav::proto::map::AreaType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_subType;
        break;
      }

      // optional string subType = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_subType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_subtype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->subtype().data(), this->subtype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_areaNames;
        break;
      }

      // repeated .com.telenav.proto.map.FeatureName areaNames = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_areaNames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_areanames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_areaNames;
        if (input->ExpectTag(120)) goto parse_featureID;
        break;
      }

      // optional uint64 featureID = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_featureID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &featureid_)));
          set_has_featureid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AreaFeature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.Polygon rings = 1;
  for (int i = 0; i < this->rings_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->rings(i), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional .com.telenav.proto.map.AreaType mainType = 3 [default = BK_AREA_UNKNOWN];
  if (has_maintype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->maintype(), output);
  }

  // optional string subType = 4;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->subtype().data(), this->subtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->subtype(), output);
  }

  // repeated .com.telenav.proto.map.FeatureName areaNames = 5;
  for (int i = 0; i < this->areanames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->areanames(i), output);
  }

  // optional uint64 featureID = 15;
  if (has_featureid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->featureid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AreaFeature::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .com.telenav.proto.map.Polygon rings = 1;
  for (int i = 0; i < this->rings_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->rings(i), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional .com.telenav.proto.map.AreaType mainType = 3 [default = BK_AREA_UNKNOWN];
  if (has_maintype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->maintype(), target);
  }

  // optional string subType = 4;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->subtype().data(), this->subtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->subtype(), target);
  }

  // repeated .com.telenav.proto.map.FeatureName areaNames = 5;
  for (int i = 0; i < this->areanames_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->areanames(i), target);
  }

  // optional uint64 featureID = 15;
  if (has_featureid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(15, this->featureid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AreaFeature::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .com.telenav.proto.map.AreaType mainType = 3 [default = BK_AREA_UNKNOWN];
    if (has_maintype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->maintype());
    }

    // optional string subType = 4;
    if (has_subtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->subtype());
    }

    // optional uint64 featureID = 15;
    if (has_featureid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->featureid());
    }

  }
  // repeated .com.telenav.proto.map.Polygon rings = 1;
  total_size += 1 * this->rings_size();
  for (int i = 0; i < this->rings_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rings(i));
  }

  // repeated .com.telenav.proto.map.FeatureName areaNames = 5;
  total_size += 1 * this->areanames_size();
  for (int i = 0; i < this->areanames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->areanames(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AreaFeature::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AreaFeature* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AreaFeature*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AreaFeature::MergeFrom(const AreaFeature& from) {
  GOOGLE_CHECK_NE(&from, this);
  rings_.MergeFrom(from.rings_);
  areanames_.MergeFrom(from.areanames_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_maintype()) {
      set_maintype(from.maintype());
    }
    if (from.has_subtype()) {
      set_subtype(from.subtype());
    }
    if (from.has_featureid()) {
      set_featureid(from.featureid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AreaFeature::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AreaFeature::CopyFrom(const AreaFeature& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AreaFeature::IsInitialized() const {

  return true;
}

void AreaFeature::Swap(AreaFeature* other) {
  if (other != this) {
    rings_.Swap(&other->rings_);
    std::swap(name_, other->name_);
    std::swap(maintype_, other->maintype_);
    std::swap(subtype_, other->subtype_);
    std::swap(featureid_, other->featureid_);
    areanames_.Swap(&other->areanames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AreaFeature::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AreaFeature_descriptor_;
  metadata.reflection = AreaFeature_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LineFeature::kLinesFieldNumber;
const int LineFeature::kNameFieldNumber;
const int LineFeature::kMainTypeFieldNumber;
const int LineFeature::kSubTypeFieldNumber;
const int LineFeature::kFeatureIDFieldNumber;
const int LineFeature::kNamesFieldNumber;
#endif  // !_MSC_VER

LineFeature::LineFeature()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LineFeature::InitAsDefaultInstance() {
}

LineFeature::LineFeature(const LineFeature& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LineFeature::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  maintype_ = 0;
  subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  featureid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LineFeature::~LineFeature() {
  SharedDtor();
}

void LineFeature::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    delete subtype_;
  }
  if (this != default_instance_) {
  }
}

void LineFeature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LineFeature::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LineFeature_descriptor_;
}

const LineFeature& LineFeature::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

LineFeature* LineFeature::default_instance_ = NULL;

LineFeature* LineFeature::New() const {
  return new LineFeature;
}

void LineFeature::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    maintype_ = 0;
    if (has_subtype()) {
      if (subtype_ != &::google::protobuf::internal::kEmptyString) {
        subtype_->clear();
      }
    }
    featureid_ = GOOGLE_ULONGLONG(0);
  }
  lines_.Clear();
  names_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LineFeature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.Polyline lines = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lines:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lines()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_lines;
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_mainType;
        break;
      }

      // optional .com.telenav.proto.map.LineType mainType = 3 [default = BK_LINE_UNKNOWN];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mainType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::LineType_IsValid(value)) {
            set_maintype(static_cast< ::com::telenav::proto::map::LineType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_subType;
        break;
      }

      // optional string subType = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_subType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_subtype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->subtype().data(), this->subtype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_names;
        break;
      }

      // repeated .com.telenav.proto.map.FeatureName names = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_names:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_names()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_names;
        if (input->ExpectTag(120)) goto parse_featureID;
        break;
      }

      // optional uint64 featureID = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_featureID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &featureid_)));
          set_has_featureid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LineFeature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.Polyline lines = 1;
  for (int i = 0; i < this->lines_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->lines(i), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional .com.telenav.proto.map.LineType mainType = 3 [default = BK_LINE_UNKNOWN];
  if (has_maintype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->maintype(), output);
  }

  // optional string subType = 4;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->subtype().data(), this->subtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->subtype(), output);
  }

  // repeated .com.telenav.proto.map.FeatureName names = 6;
  for (int i = 0; i < this->names_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->names(i), output);
  }

  // optional uint64 featureID = 15;
  if (has_featureid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->featureid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LineFeature::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .com.telenav.proto.map.Polyline lines = 1;
  for (int i = 0; i < this->lines_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->lines(i), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional .com.telenav.proto.map.LineType mainType = 3 [default = BK_LINE_UNKNOWN];
  if (has_maintype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->maintype(), target);
  }

  // optional string subType = 4;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->subtype().data(), this->subtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->subtype(), target);
  }

  // repeated .com.telenav.proto.map.FeatureName names = 6;
  for (int i = 0; i < this->names_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->names(i), target);
  }

  // optional uint64 featureID = 15;
  if (has_featureid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(15, this->featureid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LineFeature::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .com.telenav.proto.map.LineType mainType = 3 [default = BK_LINE_UNKNOWN];
    if (has_maintype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->maintype());
    }

    // optional string subType = 4;
    if (has_subtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->subtype());
    }

    // optional uint64 featureID = 15;
    if (has_featureid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->featureid());
    }

  }
  // repeated .com.telenav.proto.map.Polyline lines = 1;
  total_size += 1 * this->lines_size();
  for (int i = 0; i < this->lines_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lines(i));
  }

  // repeated .com.telenav.proto.map.FeatureName names = 6;
  total_size += 1 * this->names_size();
  for (int i = 0; i < this->names_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->names(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LineFeature::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LineFeature* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LineFeature*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LineFeature::MergeFrom(const LineFeature& from) {
  GOOGLE_CHECK_NE(&from, this);
  lines_.MergeFrom(from.lines_);
  names_.MergeFrom(from.names_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_maintype()) {
      set_maintype(from.maintype());
    }
    if (from.has_subtype()) {
      set_subtype(from.subtype());
    }
    if (from.has_featureid()) {
      set_featureid(from.featureid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LineFeature::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LineFeature::CopyFrom(const LineFeature& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LineFeature::IsInitialized() const {

  return true;
}

void LineFeature::Swap(LineFeature* other) {
  if (other != this) {
    lines_.Swap(&other->lines_);
    std::swap(name_, other->name_);
    std::swap(maintype_, other->maintype_);
    std::swap(subtype_, other->subtype_);
    std::swap(featureid_, other->featureid_);
    names_.Swap(&other->names_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LineFeature::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LineFeature_descriptor_;
  metadata.reflection = LineFeature_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PointFeature::kLatlonFieldNumber;
const int PointFeature::kMainTypeFieldNumber;
const int PointFeature::kSubTypeFieldNumber;
const int PointFeature::kNameFieldNumber;
const int PointFeature::kFontSizeFieldNumber;
const int PointFeature::kCountryFieldNumber;
const int PointFeature::kRdNameOriFieldNumber;
const int PointFeature::kFontStyleFieldNumber;
const int PointFeature::kSplineFieldNumber;
const int PointFeature::kPFeatureIDFieldNumber;
const int PointFeature::kFeatureIDFieldNumber;
const int PointFeature::kPointNamesFieldNumber;
const int PointFeature::kLandmarkIconFieldNumber;
#endif  // !_MSC_VER

PointFeature::PointFeature()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PointFeature::InitAsDefaultInstance() {
  spline_ = const_cast< ::com::telenav::proto::map::Polyline*>(&::com::telenav::proto::map::Polyline::default_instance());
}

PointFeature::PointFeature(const PointFeature& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PointFeature::SharedCtor() {
  _cached_size_ = 0;
  maintype_ = 0;
  subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fontsize_ = 0;
  country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fontstyle_ = 0;
  spline_ = NULL;
  featureid_ = GOOGLE_ULONGLONG(0);
  landmark_icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PointFeature::~PointFeature() {
  SharedDtor();
}

void PointFeature::SharedDtor() {
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    delete subtype_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    delete country_;
  }
  if (landmark_icon_ != &::google::protobuf::internal::kEmptyString) {
    delete landmark_icon_;
  }
  if (this != default_instance_) {
    delete spline_;
  }
}

void PointFeature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PointFeature::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PointFeature_descriptor_;
}

const PointFeature& PointFeature::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

PointFeature* PointFeature::default_instance_ = NULL;

PointFeature* PointFeature::New() const {
  return new PointFeature;
}

void PointFeature::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    maintype_ = 0;
    if (has_subtype()) {
      if (subtype_ != &::google::protobuf::internal::kEmptyString) {
        subtype_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    fontsize_ = 0;
    if (has_country()) {
      if (country_ != &::google::protobuf::internal::kEmptyString) {
        country_->clear();
      }
    }
    fontstyle_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_spline()) {
      if (spline_ != NULL) spline_->::com::telenav::proto::map::Polyline::Clear();
    }
    featureid_ = GOOGLE_ULONGLONG(0);
    if (has_landmark_icon()) {
      if (landmark_icon_ != &::google::protobuf::internal::kEmptyString) {
        landmark_icon_->clear();
      }
    }
  }
  latlon_.Clear();
  rdnameori_.Clear();
  p_featureid_.Clear();
  pointnames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PointFeature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated sint32 latlon = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, this->mutable_latlon())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 1, 10, input, this->mutable_latlon())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mainType;
        break;
      }

      // optional .com.telenav.proto.map.PointType mainType = 2 [default = PT_UNKNOWN];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mainType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::PointType_IsValid(value)) {
            set_maintype(static_cast< ::com::telenav::proto::map::PointType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_subType;
        break;
      }

      // optional string subType = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_subType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_subtype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->subtype().data(), this->subtype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_name;
        break;
      }

      // optional string name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_fontSize;
        break;
      }

      // optional int32 fontSize = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fontSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fontsize_)));
          set_has_fontsize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_country;
        break;
      }

      // optional string country = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_country:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_country()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->country().data(), this->country().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_rdNameOri;
        break;
      }

      // repeated int32 rdNameOri = 7 [packed = true];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rdNameOri:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_rdnameori())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 58, input, this->mutable_rdnameori())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_fontStyle;
        break;
      }

      // optional .com.telenav.proto.map.FontStyle fontStyle = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fontStyle:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::FontStyle_IsValid(value)) {
            set_fontstyle(static_cast< ::com::telenav::proto::map::FontStyle >(value));
          } else {
            mutable_unknown_fields()->AddVarint(8, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_spline;
        break;
      }

      // optional .com.telenav.proto.map.Polyline spline = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_spline:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_spline()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_pointNames;
        break;
      }

      // repeated .com.telenav.proto.map.FeatureName pointNames = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pointNames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pointnames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_pointNames;
        if (input->ExpectTag(90)) goto parse_landmark_icon;
        break;
      }

      // optional string landmark_icon = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_landmark_icon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_landmark_icon()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->landmark_icon().data(), this->landmark_icon().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_p_featureID;
        break;
      }

      // repeated uint64 p_featureID = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_p_featureID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 112, input, this->mutable_p_featureid())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_p_featureid())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_p_featureID;
        if (input->ExpectTag(120)) goto parse_featureID;
        break;
      }

      // optional uint64 featureID = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_featureID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &featureid_)));
          set_has_featureid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PointFeature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated sint32 latlon = 1 [packed = true];
  if (this->latlon_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_latlon_cached_byte_size_);
  }
  for (int i = 0; i < this->latlon_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32NoTag(
      this->latlon(i), output);
  }

  // optional .com.telenav.proto.map.PointType mainType = 2 [default = PT_UNKNOWN];
  if (has_maintype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->maintype(), output);
  }

  // optional string subType = 3;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->subtype().data(), this->subtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->subtype(), output);
  }

  // optional string name = 4;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->name(), output);
  }

  // optional int32 fontSize = 5;
  if (has_fontsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->fontsize(), output);
  }

  // optional string country = 6;
  if (has_country()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->country().data(), this->country().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->country(), output);
  }

  // repeated int32 rdNameOri = 7 [packed = true];
  if (this->rdnameori_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(7, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_rdnameori_cached_byte_size_);
  }
  for (int i = 0; i < this->rdnameori_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->rdnameori(i), output);
  }

  // optional .com.telenav.proto.map.FontStyle fontStyle = 8;
  if (has_fontstyle()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->fontstyle(), output);
  }

  // optional .com.telenav.proto.map.Polyline spline = 9;
  if (has_spline()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->spline(), output);
  }

  // repeated .com.telenav.proto.map.FeatureName pointNames = 10;
  for (int i = 0; i < this->pointnames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->pointnames(i), output);
  }

  // optional string landmark_icon = 11;
  if (has_landmark_icon()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->landmark_icon().data(), this->landmark_icon().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->landmark_icon(), output);
  }

  // repeated uint64 p_featureID = 14;
  for (int i = 0; i < this->p_featureid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      14, this->p_featureid(i), output);
  }

  // optional uint64 featureID = 15;
  if (has_featureid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->featureid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PointFeature::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated sint32 latlon = 1 [packed = true];
  if (this->latlon_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      1,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _latlon_cached_byte_size_, target);
  }
  for (int i = 0; i < this->latlon_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteSInt32NoTagToArray(this->latlon(i), target);
  }

  // optional .com.telenav.proto.map.PointType mainType = 2 [default = PT_UNKNOWN];
  if (has_maintype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->maintype(), target);
  }

  // optional string subType = 3;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->subtype().data(), this->subtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->subtype(), target);
  }

  // optional string name = 4;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->name(), target);
  }

  // optional int32 fontSize = 5;
  if (has_fontsize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->fontsize(), target);
  }

  // optional string country = 6;
  if (has_country()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->country().data(), this->country().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->country(), target);
  }

  // repeated int32 rdNameOri = 7 [packed = true];
  if (this->rdnameori_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      7,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _rdnameori_cached_byte_size_, target);
  }
  for (int i = 0; i < this->rdnameori_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->rdnameori(i), target);
  }

  // optional .com.telenav.proto.map.FontStyle fontStyle = 8;
  if (has_fontstyle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->fontstyle(), target);
  }

  // optional .com.telenav.proto.map.Polyline spline = 9;
  if (has_spline()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->spline(), target);
  }

  // repeated .com.telenav.proto.map.FeatureName pointNames = 10;
  for (int i = 0; i < this->pointnames_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->pointnames(i), target);
  }

  // optional string landmark_icon = 11;
  if (has_landmark_icon()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->landmark_icon().data(), this->landmark_icon().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->landmark_icon(), target);
  }

  // repeated uint64 p_featureID = 14;
  for (int i = 0; i < this->p_featureid_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(14, this->p_featureid(i), target);
  }

  // optional uint64 featureID = 15;
  if (has_featureid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(15, this->featureid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PointFeature::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .com.telenav.proto.map.PointType mainType = 2 [default = PT_UNKNOWN];
    if (has_maintype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->maintype());
    }

    // optional string subType = 3;
    if (has_subtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->subtype());
    }

    // optional string name = 4;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 fontSize = 5;
    if (has_fontsize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fontsize());
    }

    // optional string country = 6;
    if (has_country()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->country());
    }

    // optional .com.telenav.proto.map.FontStyle fontStyle = 8;
    if (has_fontstyle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->fontstyle());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .com.telenav.proto.map.Polyline spline = 9;
    if (has_spline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->spline());
    }

    // optional uint64 featureID = 15;
    if (has_featureid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->featureid());
    }

    // optional string landmark_icon = 11;
    if (has_landmark_icon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->landmark_icon());
    }

  }
  // repeated sint32 latlon = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->latlon_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        SInt32Size(this->latlon(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _latlon_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated int32 rdNameOri = 7 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->rdnameori_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->rdnameori(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _rdnameori_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated uint64 p_featureID = 14;
  {
    int data_size = 0;
    for (int i = 0; i < this->p_featureid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->p_featureid(i));
    }
    total_size += 1 * this->p_featureid_size() + data_size;
  }

  // repeated .com.telenav.proto.map.FeatureName pointNames = 10;
  total_size += 1 * this->pointnames_size();
  for (int i = 0; i < this->pointnames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pointnames(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PointFeature::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PointFeature* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PointFeature*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PointFeature::MergeFrom(const PointFeature& from) {
  GOOGLE_CHECK_NE(&from, this);
  latlon_.MergeFrom(from.latlon_);
  rdnameori_.MergeFrom(from.rdnameori_);
  p_featureid_.MergeFrom(from.p_featureid_);
  pointnames_.MergeFrom(from.pointnames_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_maintype()) {
      set_maintype(from.maintype());
    }
    if (from.has_subtype()) {
      set_subtype(from.subtype());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_fontsize()) {
      set_fontsize(from.fontsize());
    }
    if (from.has_country()) {
      set_country(from.country());
    }
    if (from.has_fontstyle()) {
      set_fontstyle(from.fontstyle());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_spline()) {
      mutable_spline()->::com::telenav::proto::map::Polyline::MergeFrom(from.spline());
    }
    if (from.has_featureid()) {
      set_featureid(from.featureid());
    }
    if (from.has_landmark_icon()) {
      set_landmark_icon(from.landmark_icon());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PointFeature::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PointFeature::CopyFrom(const PointFeature& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointFeature::IsInitialized() const {

  return true;
}

void PointFeature::Swap(PointFeature* other) {
  if (other != this) {
    latlon_.Swap(&other->latlon_);
    std::swap(maintype_, other->maintype_);
    std::swap(subtype_, other->subtype_);
    std::swap(name_, other->name_);
    std::swap(fontsize_, other->fontsize_);
    std::swap(country_, other->country_);
    rdnameori_.Swap(&other->rdnameori_);
    std::swap(fontstyle_, other->fontstyle_);
    std::swap(spline_, other->spline_);
    p_featureid_.Swap(&other->p_featureid_);
    std::swap(featureid_, other->featureid_);
    pointnames_.Swap(&other->pointnames_);
    std::swap(landmark_icon_, other->landmark_icon_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PointFeature::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PointFeature_descriptor_;
  metadata.reflection = PointFeature_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BuildingBlockRef::kDepthFieldNumber;
const int BuildingBlockRef::kColFieldNumber;
const int BuildingBlockRef::kRowFieldNumber;
#endif  // !_MSC_VER

BuildingBlockRef::BuildingBlockRef()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BuildingBlockRef::InitAsDefaultInstance() {
}

BuildingBlockRef::BuildingBlockRef(const BuildingBlockRef& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BuildingBlockRef::SharedCtor() {
  _cached_size_ = 0;
  depth_ = 0u;
  col_ = 0u;
  row_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuildingBlockRef::~BuildingBlockRef() {
  SharedDtor();
}

void BuildingBlockRef::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BuildingBlockRef::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BuildingBlockRef::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BuildingBlockRef_descriptor_;
}

const BuildingBlockRef& BuildingBlockRef::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

BuildingBlockRef* BuildingBlockRef::default_instance_ = NULL;

BuildingBlockRef* BuildingBlockRef::New() const {
  return new BuildingBlockRef;
}

void BuildingBlockRef::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    depth_ = 0u;
    col_ = 0u;
    row_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BuildingBlockRef::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 depth = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &depth_)));
          set_has_depth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_col;
        break;
      }

      // optional uint32 col = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_col:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &col_)));
          set_has_col();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_row;
        break;
      }

      // optional uint32 row = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_row:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &row_)));
          set_has_row();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuildingBlockRef::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 depth = 1;
  if (has_depth()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->depth(), output);
  }

  // optional uint32 col = 2;
  if (has_col()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->col(), output);
  }

  // optional uint32 row = 3;
  if (has_row()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->row(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BuildingBlockRef::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 depth = 1;
  if (has_depth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->depth(), target);
  }

  // optional uint32 col = 2;
  if (has_col()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->col(), target);
  }

  // optional uint32 row = 3;
  if (has_row()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->row(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BuildingBlockRef::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 depth = 1;
    if (has_depth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->depth());
    }

    // optional uint32 col = 2;
    if (has_col()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->col());
    }

    // optional uint32 row = 3;
    if (has_row()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->row());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuildingBlockRef::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BuildingBlockRef* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BuildingBlockRef*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BuildingBlockRef::MergeFrom(const BuildingBlockRef& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_depth()) {
      set_depth(from.depth());
    }
    if (from.has_col()) {
      set_col(from.col());
    }
    if (from.has_row()) {
      set_row(from.row());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BuildingBlockRef::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BuildingBlockRef::CopyFrom(const BuildingBlockRef& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuildingBlockRef::IsInitialized() const {

  return true;
}

void BuildingBlockRef::Swap(BuildingBlockRef* other) {
  if (other != this) {
    std::swap(depth_, other->depth_);
    std::swap(col_, other->col_);
    std::swap(row_, other->row_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BuildingBlockRef::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BuildingBlockRef_descriptor_;
  metadata.reflection = BuildingBlockRef_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BuildingBlockList::kVersionFieldNumber;
const int BuildingBlockList::kBlockRefsFieldNumber;
#endif  // !_MSC_VER

BuildingBlockList::BuildingBlockList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BuildingBlockList::InitAsDefaultInstance() {
}

BuildingBlockList::BuildingBlockList(const BuildingBlockList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BuildingBlockList::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuildingBlockList::~BuildingBlockList() {
  SharedDtor();
}

void BuildingBlockList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BuildingBlockList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BuildingBlockList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BuildingBlockList_descriptor_;
}

const BuildingBlockList& BuildingBlockList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

BuildingBlockList* BuildingBlockList::default_instance_ = NULL;

BuildingBlockList* BuildingBlockList::New() const {
  return new BuildingBlockList;
}

void BuildingBlockList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0;
  }
  blockrefs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BuildingBlockList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_blockRefs;
        break;
      }

      // repeated .com.telenav.proto.map.BuildingBlockRef blockRefs = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_blockRefs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_blockrefs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_blockRefs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuildingBlockList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->version(), output);
  }

  // repeated .com.telenav.proto.map.BuildingBlockRef blockRefs = 2;
  for (int i = 0; i < this->blockrefs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->blockrefs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BuildingBlockList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->version(), target);
  }

  // repeated .com.telenav.proto.map.BuildingBlockRef blockRefs = 2;
  for (int i = 0; i < this->blockrefs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->blockrefs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BuildingBlockList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->version());
    }

  }
  // repeated .com.telenav.proto.map.BuildingBlockRef blockRefs = 2;
  total_size += 1 * this->blockrefs_size();
  for (int i = 0; i < this->blockrefs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->blockrefs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuildingBlockList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BuildingBlockList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BuildingBlockList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BuildingBlockList::MergeFrom(const BuildingBlockList& from) {
  GOOGLE_CHECK_NE(&from, this);
  blockrefs_.MergeFrom(from.blockrefs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BuildingBlockList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BuildingBlockList::CopyFrom(const BuildingBlockList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuildingBlockList::IsInitialized() const {

  return true;
}

void BuildingBlockList::Swap(BuildingBlockList* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    blockrefs_.Swap(&other->blockrefs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BuildingBlockList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BuildingBlockList_descriptor_;
  metadata.reflection = BuildingBlockList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BigTileConfig::kZoomlevelFieldNumber;
#endif  // !_MSC_VER

BigTileConfig::BigTileConfig()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BigTileConfig::InitAsDefaultInstance() {
}

BigTileConfig::BigTileConfig(const BigTileConfig& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BigTileConfig::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BigTileConfig::~BigTileConfig() {
  SharedDtor();
}

void BigTileConfig::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BigTileConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BigTileConfig::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BigTileConfig_descriptor_;
}

const BigTileConfig& BigTileConfig::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

BigTileConfig* BigTileConfig::default_instance_ = NULL;

BigTileConfig* BigTileConfig::New() const {
  return new BigTileConfig;
}

void BigTileConfig::Clear() {
  zoomlevel_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BigTileConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.ZoomLevel zoomlevel = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_zoomlevel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_zoomlevel()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_zoomlevel;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BigTileConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.ZoomLevel zoomlevel = 1;
  for (int i = 0; i < this->zoomlevel_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->zoomlevel(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BigTileConfig::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .com.telenav.proto.map.ZoomLevel zoomlevel = 1;
  for (int i = 0; i < this->zoomlevel_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->zoomlevel(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BigTileConfig::ByteSize() const {
  int total_size = 0;

  // repeated .com.telenav.proto.map.ZoomLevel zoomlevel = 1;
  total_size += 1 * this->zoomlevel_size();
  for (int i = 0; i < this->zoomlevel_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->zoomlevel(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BigTileConfig::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BigTileConfig* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BigTileConfig*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BigTileConfig::MergeFrom(const BigTileConfig& from) {
  GOOGLE_CHECK_NE(&from, this);
  zoomlevel_.MergeFrom(from.zoomlevel_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BigTileConfig::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BigTileConfig::CopyFrom(const BigTileConfig& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BigTileConfig::IsInitialized() const {

  return true;
}

void BigTileConfig::Swap(BigTileConfig* other) {
  if (other != this) {
    zoomlevel_.Swap(&other->zoomlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BigTileConfig::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BigTileConfig_descriptor_;
  metadata.reflection = BigTileConfig_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ZoomLevel::kLevelFieldNumber;
const int ZoomLevel::kPowerFieldNumber;
#endif  // !_MSC_VER

ZoomLevel::ZoomLevel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ZoomLevel::InitAsDefaultInstance() {
}

ZoomLevel::ZoomLevel(const ZoomLevel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ZoomLevel::SharedCtor() {
  _cached_size_ = 0;
  level_ = 0;
  power_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ZoomLevel::~ZoomLevel() {
  SharedDtor();
}

void ZoomLevel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ZoomLevel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ZoomLevel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ZoomLevel_descriptor_;
}

const ZoomLevel& ZoomLevel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
  return *default_instance_;
}

ZoomLevel* ZoomLevel::default_instance_ = NULL;

ZoomLevel* ZoomLevel::New() const {
  return new ZoomLevel;
}

void ZoomLevel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    level_ = 0;
    power_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ZoomLevel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 level = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_power;
        break;
      }

      // optional int32 power = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_power:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &power_)));
          set_has_power();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ZoomLevel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 level = 1;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->level(), output);
  }

  // optional int32 power = 2;
  if (has_power()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->power(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ZoomLevel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 level = 1;
  if (has_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->level(), target);
  }

  // optional int32 power = 2;
  if (has_power()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->power(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ZoomLevel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 level = 1;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

    // optional int32 power = 2;
    if (has_power()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->power());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ZoomLevel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ZoomLevel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ZoomLevel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ZoomLevel::MergeFrom(const ZoomLevel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_power()) {
      set_power(from.power());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ZoomLevel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ZoomLevel::CopyFrom(const ZoomLevel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ZoomLevel::IsInitialized() const {

  return true;
}

void ZoomLevel::Swap(ZoomLevel* other) {
  if (other != this) {
    std::swap(level_, other->level_);
    std::swap(power_, other->power_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ZoomLevel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ZoomLevel_descriptor_;
  metadata.reflection = ZoomLevel_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace map
}  // namespace proto
}  // namespace telenav
}  // namespace com

// @@protoc_insertion_point(global_scope)
