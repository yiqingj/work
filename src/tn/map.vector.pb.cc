// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map.vector.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "map.vector.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace telenav {
namespace proto {
namespace map {

void protobuf_ShutdownFile_map_2evector_2eproto() {
  delete VectorMapRequest::default_instance_;
  delete TfcObj::default_instance_;
  delete Polygon::default_instance_;
  delete Polyline::default_instance_;
  delete VectorTrafficTile::default_instance_;
  delete VectorMapTile::default_instance_;
  delete FeatureName::default_instance_;
  delete HighwayShield::default_instance_;
  delete RoadFeature::default_instance_;
  delete AreaFeature::default_instance_;
  delete LineFeature::default_instance_;
  delete PointFeature::default_instance_;
  delete BuildingBlockRef::default_instance_;
  delete BuildingBlockList::default_instance_;
  delete BigTileConfig::default_instance_;
  delete ZoomLevel::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_map_2evector_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_map_2evector_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::com::telenav::proto::protobuf_AddDesc_common_2eproto();
  ::com::telenav::proto::map::protobuf_AddDesc_map_2ecommon_2eproto();
  ::com::telenav::proto::protobuf_AddDesc_services_2eproto();
  VectorMapRequest::default_instance_ = new VectorMapRequest();
  TfcObj::default_instance_ = new TfcObj();
  Polygon::default_instance_ = new Polygon();
  Polyline::default_instance_ = new Polyline();
  VectorTrafficTile::default_instance_ = new VectorTrafficTile();
  VectorMapTile::default_instance_ = new VectorMapTile();
  FeatureName::default_instance_ = new FeatureName();
  HighwayShield::default_instance_ = new HighwayShield();
  RoadFeature::default_instance_ = new RoadFeature();
  AreaFeature::default_instance_ = new AreaFeature();
  LineFeature::default_instance_ = new LineFeature();
  PointFeature::default_instance_ = new PointFeature();
  BuildingBlockRef::default_instance_ = new BuildingBlockRef();
  BuildingBlockList::default_instance_ = new BuildingBlockList();
  BigTileConfig::default_instance_ = new BigTileConfig();
  ZoomLevel::default_instance_ = new ZoomLevel();
  VectorMapRequest::default_instance_->InitAsDefaultInstance();
  TfcObj::default_instance_->InitAsDefaultInstance();
  Polygon::default_instance_->InitAsDefaultInstance();
  Polyline::default_instance_->InitAsDefaultInstance();
  VectorTrafficTile::default_instance_->InitAsDefaultInstance();
  VectorMapTile::default_instance_->InitAsDefaultInstance();
  FeatureName::default_instance_->InitAsDefaultInstance();
  HighwayShield::default_instance_->InitAsDefaultInstance();
  RoadFeature::default_instance_->InitAsDefaultInstance();
  AreaFeature::default_instance_->InitAsDefaultInstance();
  LineFeature::default_instance_->InitAsDefaultInstance();
  PointFeature::default_instance_->InitAsDefaultInstance();
  BuildingBlockRef::default_instance_->InitAsDefaultInstance();
  BuildingBlockList::default_instance_->InitAsDefaultInstance();
  BigTileConfig::default_instance_->InitAsDefaultInstance();
  ZoomLevel::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_map_2evector_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_map_2evector_2eproto_once_);
void protobuf_AddDesc_map_2evector_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_map_2evector_2eproto_once_,
                 &protobuf_AddDesc_map_2evector_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_map_2evector_2eproto {
  StaticDescriptorInitializer_map_2evector_2eproto() {
    protobuf_AddDesc_map_2evector_2eproto();
  }
} static_descriptor_initializer_map_2evector_2eproto_;
#endif
bool RoadSubType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

bool RoadDirection_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

bool RoadFunctionClass_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

bool AreaType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      return true;
    default:
      return false;
  }
}

bool RingOrientation_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool PointType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

bool LineType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

bool FontStyle_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int VectorMapRequest::kZoomLevelFieldNumber;
const int VectorMapRequest::kXFieldNumber;
const int VectorMapRequest::kYFieldNumber;
const int VectorMapRequest::kContextFieldNumber;
#endif  // !_MSC_VER

VectorMapRequest::VectorMapRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void VectorMapRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  context_ = const_cast< ::com::telenav::proto::Context*>(
      ::com::telenav::proto::Context::internal_default_instance());
#else
  context_ = const_cast< ::com::telenav::proto::Context*>(&::com::telenav::proto::Context::default_instance());
#endif
}

VectorMapRequest::VectorMapRequest(const VectorMapRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void VectorMapRequest::SharedCtor() {
  _cached_size_ = 0;
  zoomlevel_ = 0;
  x_ = 0;
  y_ = 0;
  context_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VectorMapRequest::~VectorMapRequest() {
  SharedDtor();
}

void VectorMapRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete context_;
  }
}

void VectorMapRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VectorMapRequest& VectorMapRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

VectorMapRequest* VectorMapRequest::default_instance_ = NULL;

VectorMapRequest* VectorMapRequest::New() const {
  return new VectorMapRequest;
}

void VectorMapRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    zoomlevel_ = 0;
    x_ = 0;
    y_ = 0;
    if (has_context()) {
      if (context_ != NULL) context_->::com::telenav::proto::Context::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool VectorMapRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 zoomLevel = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zoomlevel_)));
          set_has_zoomlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // optional int32 x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // optional int32 y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_context;
        break;
      }

      // optional .com.telenav.proto.Context context = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_context:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_context()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VectorMapRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 zoomLevel = 1;
  if (has_zoomlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->zoomlevel(), output);
  }

  // optional int32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // optional int32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

  // optional .com.telenav.proto.Context context = 4;
  if (has_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->context(), output);
  }

}

int VectorMapRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 zoomLevel = 1;
    if (has_zoomlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->zoomlevel());
    }

    // optional int32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

    // optional .com.telenav.proto.Context context = 4;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->context());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VectorMapRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VectorMapRequest*>(&from));
}

void VectorMapRequest::MergeFrom(const VectorMapRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_zoomlevel()) {
      set_zoomlevel(from.zoomlevel());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_context()) {
      mutable_context()->::com::telenav::proto::Context::MergeFrom(from.context());
    }
  }
}

void VectorMapRequest::CopyFrom(const VectorMapRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorMapRequest::IsInitialized() const {

  if (has_context()) {
    if (!this->context().IsInitialized()) return false;
  }
  return true;
}

void VectorMapRequest::Swap(VectorMapRequest* other) {
  if (other != this) {
    std::swap(zoomlevel_, other->zoomlevel_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(context_, other->context_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VectorMapRequest::GetTypeName() const {
  return "com.telenav.proto.map.VectorMapRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int TfcObj::kTrafficIdFieldNumber;
const int TfcObj::kStartIdxFieldNumber;
const int TfcObj::kEndIdxFieldNumber;
#endif  // !_MSC_VER

TfcObj::TfcObj()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TfcObj::InitAsDefaultInstance() {
}

TfcObj::TfcObj(const TfcObj& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TfcObj::SharedCtor() {
  _cached_size_ = 0;
  trafficid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  start_idx_ = 0u;
  end_idx_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TfcObj::~TfcObj() {
  SharedDtor();
}

void TfcObj::SharedDtor() {
  if (trafficid_ != &::google::protobuf::internal::kEmptyString) {
    delete trafficid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TfcObj::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TfcObj& TfcObj::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

TfcObj* TfcObj::default_instance_ = NULL;

TfcObj* TfcObj::New() const {
  return new TfcObj;
}

void TfcObj::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_trafficid()) {
      if (trafficid_ != &::google::protobuf::internal::kEmptyString) {
        trafficid_->clear();
      }
    }
    start_idx_ = 0u;
    end_idx_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TfcObj::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string trafficId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_trafficid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_start_idx;
        break;
      }

      // optional uint32 start_idx = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start_idx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &start_idx_)));
          set_has_start_idx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_end_idx;
        break;
      }

      // optional uint32 end_idx = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_idx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_idx_)));
          set_has_end_idx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TfcObj::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string trafficId = 1;
  if (has_trafficid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->trafficid(), output);
  }

  // optional uint32 start_idx = 2;
  if (has_start_idx()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->start_idx(), output);
  }

  // optional uint32 end_idx = 3;
  if (has_end_idx()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->end_idx(), output);
  }

}

int TfcObj::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string trafficId = 1;
    if (has_trafficid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->trafficid());
    }

    // optional uint32 start_idx = 2;
    if (has_start_idx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->start_idx());
    }

    // optional uint32 end_idx = 3;
    if (has_end_idx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_idx());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TfcObj::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TfcObj*>(&from));
}

void TfcObj::MergeFrom(const TfcObj& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trafficid()) {
      set_trafficid(from.trafficid());
    }
    if (from.has_start_idx()) {
      set_start_idx(from.start_idx());
    }
    if (from.has_end_idx()) {
      set_end_idx(from.end_idx());
    }
  }
}

void TfcObj::CopyFrom(const TfcObj& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TfcObj::IsInitialized() const {

  return true;
}

void TfcObj::Swap(TfcObj* other) {
  if (other != this) {
    std::swap(trafficid_, other->trafficid_);
    std::swap(start_idx_, other->start_idx_);
    std::swap(end_idx_, other->end_idx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TfcObj::GetTypeName() const {
  return "com.telenav.proto.map.TfcObj";
}


// ===================================================================

#ifndef _MSC_VER
const int Polygon::kLatlonFieldNumber;
const int Polygon::kOrientFieldNumber;
#endif  // !_MSC_VER

Polygon::Polygon()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Polygon::InitAsDefaultInstance() {
}

Polygon::Polygon(const Polygon& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Polygon::SharedCtor() {
  _cached_size_ = 0;
  orient_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Polygon::~Polygon() {
  SharedDtor();
}

void Polygon::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Polygon::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Polygon& Polygon::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

Polygon* Polygon::default_instance_ = NULL;

Polygon* Polygon::New() const {
  return new Polygon;
}

void Polygon::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    orient_ = 0;
  }
  latlon_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Polygon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated sint32 latlon = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, this->mutable_latlon())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 1, 10, input, this->mutable_latlon())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_orient;
        break;
      }

      // optional .com.telenav.proto.map.RingOrientation orient = 2 [default = OR_UNKNOWN];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_orient:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::RingOrientation_IsValid(value)) {
            set_orient(static_cast< ::com::telenav::proto::map::RingOrientation >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Polygon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated sint32 latlon = 1 [packed = true];
  if (this->latlon_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_latlon_cached_byte_size_);
  }
  for (int i = 0; i < this->latlon_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32NoTag(
      this->latlon(i), output);
  }

  // optional .com.telenav.proto.map.RingOrientation orient = 2 [default = OR_UNKNOWN];
  if (has_orient()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->orient(), output);
  }

}

int Polygon::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .com.telenav.proto.map.RingOrientation orient = 2 [default = OR_UNKNOWN];
    if (has_orient()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->orient());
    }

  }
  // repeated sint32 latlon = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->latlon_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        SInt32Size(this->latlon(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _latlon_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Polygon::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Polygon*>(&from));
}

void Polygon::MergeFrom(const Polygon& from) {
  GOOGLE_CHECK_NE(&from, this);
  latlon_.MergeFrom(from.latlon_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_orient()) {
      set_orient(from.orient());
    }
  }
}

void Polygon::CopyFrom(const Polygon& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polygon::IsInitialized() const {

  return true;
}

void Polygon::Swap(Polygon* other) {
  if (other != this) {
    latlon_.Swap(&other->latlon_);
    std::swap(orient_, other->orient_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Polygon::GetTypeName() const {
  return "com.telenav.proto.map.Polygon";
}


// ===================================================================

#ifndef _MSC_VER
const int Polyline::kLatlonFieldNumber;
const int Polyline::kTfcIdRightFieldNumber;
const int Polyline::kTfcIdLeftFieldNumber;
#endif  // !_MSC_VER

Polyline::Polyline()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Polyline::InitAsDefaultInstance() {
}

Polyline::Polyline(const Polyline& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Polyline::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Polyline::~Polyline() {
  SharedDtor();
}

void Polyline::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Polyline::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Polyline& Polyline::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

Polyline* Polyline::default_instance_ = NULL;

Polyline* Polyline::New() const {
  return new Polyline;
}

void Polyline::Clear() {
  latlon_.Clear();
  tfcid_right_.Clear();
  tfcid_left_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Polyline::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated sint32 latlon = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, this->mutable_latlon())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 1, 10, input, this->mutable_latlon())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tfcId_right;
        break;
      }

      // repeated .com.telenav.proto.map.TfcObj tfcId_right = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tfcId_right:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tfcid_right()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tfcId_right;
        if (input->ExpectTag(26)) goto parse_tfcId_left;
        break;
      }

      // repeated .com.telenav.proto.map.TfcObj tfcId_left = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tfcId_left:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tfcid_left()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tfcId_left;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Polyline::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated sint32 latlon = 1 [packed = true];
  if (this->latlon_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_latlon_cached_byte_size_);
  }
  for (int i = 0; i < this->latlon_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32NoTag(
      this->latlon(i), output);
  }

  // repeated .com.telenav.proto.map.TfcObj tfcId_right = 2;
  for (int i = 0; i < this->tfcid_right_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->tfcid_right(i), output);
  }

  // repeated .com.telenav.proto.map.TfcObj tfcId_left = 3;
  for (int i = 0; i < this->tfcid_left_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->tfcid_left(i), output);
  }

}

int Polyline::ByteSize() const {
  int total_size = 0;

  // repeated sint32 latlon = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->latlon_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        SInt32Size(this->latlon(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _latlon_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated .com.telenav.proto.map.TfcObj tfcId_right = 2;
  total_size += 1 * this->tfcid_right_size();
  for (int i = 0; i < this->tfcid_right_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tfcid_right(i));
  }

  // repeated .com.telenav.proto.map.TfcObj tfcId_left = 3;
  total_size += 1 * this->tfcid_left_size();
  for (int i = 0; i < this->tfcid_left_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tfcid_left(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Polyline::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Polyline*>(&from));
}

void Polyline::MergeFrom(const Polyline& from) {
  GOOGLE_CHECK_NE(&from, this);
  latlon_.MergeFrom(from.latlon_);
  tfcid_right_.MergeFrom(from.tfcid_right_);
  tfcid_left_.MergeFrom(from.tfcid_left_);
}

void Polyline::CopyFrom(const Polyline& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polyline::IsInitialized() const {

  return true;
}

void Polyline::Swap(Polyline* other) {
  if (other != this) {
    latlon_.Swap(&other->latlon_);
    tfcid_right_.Swap(&other->tfcid_right_);
    tfcid_left_.Swap(&other->tfcid_left_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Polyline::GetTypeName() const {
  return "com.telenav.proto.map.Polyline";
}


// ===================================================================

#ifndef _MSC_VER
const int VectorTrafficTile::kTmcIdsFieldNumber;
#endif  // !_MSC_VER

VectorTrafficTile::VectorTrafficTile()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void VectorTrafficTile::InitAsDefaultInstance() {
}

VectorTrafficTile::VectorTrafficTile(const VectorTrafficTile& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void VectorTrafficTile::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VectorTrafficTile::~VectorTrafficTile() {
  SharedDtor();
}

void VectorTrafficTile::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void VectorTrafficTile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VectorTrafficTile& VectorTrafficTile::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

VectorTrafficTile* VectorTrafficTile::default_instance_ = NULL;

VectorTrafficTile* VectorTrafficTile::New() const {
  return new VectorTrafficTile;
}

void VectorTrafficTile::Clear() {
  tmcids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool VectorTrafficTile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 tmcIds = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_tmcids())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 10, input, this->mutable_tmcids())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VectorTrafficTile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 tmcIds = 1 [packed = true];
  if (this->tmcids_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_tmcids_cached_byte_size_);
  }
  for (int i = 0; i < this->tmcids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->tmcids(i), output);
  }

}

int VectorTrafficTile::ByteSize() const {
  int total_size = 0;

  // repeated uint32 tmcIds = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->tmcids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->tmcids(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _tmcids_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VectorTrafficTile::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VectorTrafficTile*>(&from));
}

void VectorTrafficTile::MergeFrom(const VectorTrafficTile& from) {
  GOOGLE_CHECK_NE(&from, this);
  tmcids_.MergeFrom(from.tmcids_);
}

void VectorTrafficTile::CopyFrom(const VectorTrafficTile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorTrafficTile::IsInitialized() const {

  return true;
}

void VectorTrafficTile::Swap(VectorTrafficTile* other) {
  if (other != this) {
    tmcids_.Swap(&other->tmcids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VectorTrafficTile::GetTypeName() const {
  return "com.telenav.proto.map.VectorTrafficTile";
}


// ===================================================================

#ifndef _MSC_VER
const int VectorMapTile::kRfFieldNumber;
const int VectorMapTile::kAfFieldNumber;
const int VectorMapTile::kLfFieldNumber;
const int VectorMapTile::kPfFieldNumber;
const int VectorMapTile::kBuildingBlockListFieldNumber;
const int VectorMapTile::kDataVersionFieldNumber;
#endif  // !_MSC_VER

VectorMapTile::VectorMapTile()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void VectorMapTile::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  buildingblocklist_ = const_cast< ::com::telenav::proto::map::BuildingBlockList*>(
      ::com::telenav::proto::map::BuildingBlockList::internal_default_instance());
#else
  buildingblocklist_ = const_cast< ::com::telenav::proto::map::BuildingBlockList*>(&::com::telenav::proto::map::BuildingBlockList::default_instance());
#endif
}

VectorMapTile::VectorMapTile(const VectorMapTile& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void VectorMapTile::SharedCtor() {
  _cached_size_ = 0;
  buildingblocklist_ = NULL;
  dataversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VectorMapTile::~VectorMapTile() {
  SharedDtor();
}

void VectorMapTile::SharedDtor() {
  if (dataversion_ != &::google::protobuf::internal::kEmptyString) {
    delete dataversion_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete buildingblocklist_;
  }
}

void VectorMapTile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VectorMapTile& VectorMapTile::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

VectorMapTile* VectorMapTile::default_instance_ = NULL;

VectorMapTile* VectorMapTile::New() const {
  return new VectorMapTile;
}

void VectorMapTile::Clear() {
  if (_has_bits_[4 / 32] & (0xffu << (4 % 32))) {
    if (has_buildingblocklist()) {
      if (buildingblocklist_ != NULL) buildingblocklist_->::com::telenav::proto::map::BuildingBlockList::Clear();
    }
    if (has_dataversion()) {
      if (dataversion_ != &::google::protobuf::internal::kEmptyString) {
        dataversion_->clear();
      }
    }
  }
  rf_.Clear();
  af_.Clear();
  lf_.Clear();
  pf_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool VectorMapTile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.RoadFeature rf = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_rf;
        if (input->ExpectTag(18)) goto parse_af;
        break;
      }

      // repeated .com.telenav.proto.map.AreaFeature af = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_af:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_af()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_af;
        if (input->ExpectTag(26)) goto parse_lf;
        break;
      }

      // repeated .com.telenav.proto.map.LineFeature lf = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_lf;
        if (input->ExpectTag(34)) goto parse_pf;
        break;
      }

      // repeated .com.telenav.proto.map.PointFeature pf = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_pf;
        if (input->ExpectTag(42)) goto parse_buildingBlockList;
        break;
      }

      // optional .com.telenav.proto.map.BuildingBlockList buildingBlockList = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_buildingBlockList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_buildingblocklist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_dataVersion;
        break;
      }

      // optional string dataVersion = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dataVersion:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dataversion()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VectorMapTile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.RoadFeature rf = 1;
  for (int i = 0; i < this->rf_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->rf(i), output);
  }

  // repeated .com.telenav.proto.map.AreaFeature af = 2;
  for (int i = 0; i < this->af_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->af(i), output);
  }

  // repeated .com.telenav.proto.map.LineFeature lf = 3;
  for (int i = 0; i < this->lf_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->lf(i), output);
  }

  // repeated .com.telenav.proto.map.PointFeature pf = 4;
  for (int i = 0; i < this->pf_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->pf(i), output);
  }

  // optional .com.telenav.proto.map.BuildingBlockList buildingBlockList = 5;
  if (has_buildingblocklist()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->buildingblocklist(), output);
  }

  // optional string dataVersion = 6;
  if (has_dataversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->dataversion(), output);
  }

}

int VectorMapTile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[4 / 32] & (0xffu << (4 % 32))) {
    // optional .com.telenav.proto.map.BuildingBlockList buildingBlockList = 5;
    if (has_buildingblocklist()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->buildingblocklist());
    }

    // optional string dataVersion = 6;
    if (has_dataversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dataversion());
    }

  }
  // repeated .com.telenav.proto.map.RoadFeature rf = 1;
  total_size += 1 * this->rf_size();
  for (int i = 0; i < this->rf_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rf(i));
  }

  // repeated .com.telenav.proto.map.AreaFeature af = 2;
  total_size += 1 * this->af_size();
  for (int i = 0; i < this->af_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->af(i));
  }

  // repeated .com.telenav.proto.map.LineFeature lf = 3;
  total_size += 1 * this->lf_size();
  for (int i = 0; i < this->lf_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lf(i));
  }

  // repeated .com.telenav.proto.map.PointFeature pf = 4;
  total_size += 1 * this->pf_size();
  for (int i = 0; i < this->pf_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pf(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VectorMapTile::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VectorMapTile*>(&from));
}

void VectorMapTile::MergeFrom(const VectorMapTile& from) {
  GOOGLE_CHECK_NE(&from, this);
  rf_.MergeFrom(from.rf_);
  af_.MergeFrom(from.af_);
  lf_.MergeFrom(from.lf_);
  pf_.MergeFrom(from.pf_);
  if (from._has_bits_[4 / 32] & (0xffu << (4 % 32))) {
    if (from.has_buildingblocklist()) {
      mutable_buildingblocklist()->::com::telenav::proto::map::BuildingBlockList::MergeFrom(from.buildingblocklist());
    }
    if (from.has_dataversion()) {
      set_dataversion(from.dataversion());
    }
  }
}

void VectorMapTile::CopyFrom(const VectorMapTile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorMapTile::IsInitialized() const {

  return true;
}

void VectorMapTile::Swap(VectorMapTile* other) {
  if (other != this) {
    rf_.Swap(&other->rf_);
    af_.Swap(&other->af_);
    lf_.Swap(&other->lf_);
    pf_.Swap(&other->pf_);
    std::swap(buildingblocklist_, other->buildingblocklist_);
    std::swap(dataversion_, other->dataversion_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VectorMapTile::GetTypeName() const {
  return "com.telenav.proto.map.VectorMapTile";
}


// ===================================================================

#ifndef _MSC_VER
const int FeatureName::kNameFieldNumber;
const int FeatureName::kAliasFieldNumber;
const int FeatureName::kLanguageFieldNumber;
#endif  // !_MSC_VER

FeatureName::FeatureName()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FeatureName::InitAsDefaultInstance() {
}

FeatureName::FeatureName(const FeatureName& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FeatureName::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FeatureName::~FeatureName() {
  SharedDtor();
}

void FeatureName::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    delete alias_;
  }
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FeatureName::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FeatureName& FeatureName::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

FeatureName* FeatureName::default_instance_ = NULL;

FeatureName* FeatureName::New() const {
  return new FeatureName;
}

void FeatureName::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_alias()) {
      if (alias_ != &::google::protobuf::internal::kEmptyString) {
        alias_->clear();
      }
    }
    if (has_language()) {
      if (language_ != &::google::protobuf::internal::kEmptyString) {
        language_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FeatureName::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_alias;
        break;
      }

      // optional string alias = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_alias:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_alias()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_language;
        break;
      }

      // optional string language = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_language:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FeatureName::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->alias(), output);
  }

  // optional string language = 3;
  if (has_language()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->language(), output);
  }

}

int FeatureName::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string alias = 2;
    if (has_alias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->alias());
    }

    // optional string language = 3;
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FeatureName::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FeatureName*>(&from));
}

void FeatureName::MergeFrom(const FeatureName& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_alias()) {
      set_alias(from.alias());
    }
    if (from.has_language()) {
      set_language(from.language());
    }
  }
}

void FeatureName::CopyFrom(const FeatureName& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureName::IsInitialized() const {

  return true;
}

void FeatureName::Swap(FeatureName* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(alias_, other->alias_);
    std::swap(language_, other->language_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FeatureName::GetTypeName() const {
  return "com.telenav.proto.map.FeatureName";
}


// ===================================================================

#ifndef _MSC_VER
const int HighwayShield::kNumberFieldNumber;
const int HighwayShield::kIconIDFieldNumber;
#endif  // !_MSC_VER

HighwayShield::HighwayShield()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HighwayShield::InitAsDefaultInstance() {
}

HighwayShield::HighwayShield(const HighwayShield& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HighwayShield::SharedCtor() {
  _cached_size_ = 0;
  number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  iconid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HighwayShield::~HighwayShield() {
  SharedDtor();
}

void HighwayShield::SharedDtor() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (iconid_ != &::google::protobuf::internal::kEmptyString) {
    delete iconid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void HighwayShield::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HighwayShield& HighwayShield::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

HighwayShield* HighwayShield::default_instance_ = NULL;

HighwayShield* HighwayShield::New() const {
  return new HighwayShield;
}

void HighwayShield::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_number()) {
      if (number_ != &::google::protobuf::internal::kEmptyString) {
        number_->clear();
      }
    }
    if (has_iconid()) {
      if (iconid_ != &::google::protobuf::internal::kEmptyString) {
        iconid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HighwayShield::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string number = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_number()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_iconID;
        break;
      }

      // optional string iconID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_iconID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_iconid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HighwayShield::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string number = 1;
  if (has_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->number(), output);
  }

  // optional string iconID = 2;
  if (has_iconid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->iconid(), output);
  }

}

int HighwayShield::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string number = 1;
    if (has_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->number());
    }

    // optional string iconID = 2;
    if (has_iconid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->iconid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HighwayShield::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HighwayShield*>(&from));
}

void HighwayShield::MergeFrom(const HighwayShield& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_number()) {
      set_number(from.number());
    }
    if (from.has_iconid()) {
      set_iconid(from.iconid());
    }
  }
}

void HighwayShield::CopyFrom(const HighwayShield& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HighwayShield::IsInitialized() const {

  return true;
}

void HighwayShield::Swap(HighwayShield* other) {
  if (other != this) {
    std::swap(number_, other->number_);
    std::swap(iconid_, other->iconid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HighwayShield::GetTypeName() const {
  return "com.telenav.proto.map.HighwayShield";
}


// ===================================================================

#ifndef _MSC_VER
const int RoadFeature::kLinesFieldNumber;
const int RoadFeature::kRoadTypeFieldNumber;
const int RoadFeature::kRoadSubTypeFieldNumber;
const int RoadFeature::kRoadNameFieldNumber;
const int RoadFeature::kRoadAliasFieldNumber;
const int RoadFeature::kFeatureIDFieldNumber;
const int RoadFeature::kRoadNamesFieldNumber;
const int RoadFeature::kShieldsFieldNumber;
const int RoadFeature::kRoadFunctionClassFieldNumber;
const int RoadFeature::kRoadDirectionFieldNumber;
#endif  // !_MSC_VER

RoadFeature::RoadFeature()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RoadFeature::InitAsDefaultInstance() {
}

RoadFeature::RoadFeature(const RoadFeature& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RoadFeature::SharedCtor() {
  _cached_size_ = 0;
  roadtype_ = 0;
  roadsubtype_ = 0;
  roadname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  roadalias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  featureid_ = GOOGLE_ULONGLONG(0);
  roadfunctionclass_ = 1;
  roaddirection_ = 4;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoadFeature::~RoadFeature() {
  SharedDtor();
}

void RoadFeature::SharedDtor() {
  if (roadname_ != &::google::protobuf::internal::kEmptyString) {
    delete roadname_;
  }
  if (roadalias_ != &::google::protobuf::internal::kEmptyString) {
    delete roadalias_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RoadFeature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RoadFeature& RoadFeature::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

RoadFeature* RoadFeature::default_instance_ = NULL;

RoadFeature* RoadFeature::New() const {
  return new RoadFeature;
}

void RoadFeature::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    roadtype_ = 0;
    roadsubtype_ = 0;
    if (has_roadname()) {
      if (roadname_ != &::google::protobuf::internal::kEmptyString) {
        roadname_->clear();
      }
    }
    if (has_roadalias()) {
      if (roadalias_ != &::google::protobuf::internal::kEmptyString) {
        roadalias_->clear();
      }
    }
    featureid_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    roadfunctionclass_ = 1;
    roaddirection_ = 4;
  }
  lines_.Clear();
  roadnames_.Clear();
  shields_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RoadFeature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.Polyline lines = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lines:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lines()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_lines;
        if (input->ExpectTag(16)) goto parse_roadType;
        break;
      }

      // optional .com.telenav.proto.map.RoadType roadType = 2 [default = RT_UNKNOWN];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roadType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::RoadType_IsValid(value)) {
            set_roadtype(static_cast< ::com::telenav::proto::map::RoadType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_roadSubType;
        break;
      }

      // optional .com.telenav.proto.map.RoadSubType roadSubType = 3 [default = RST_UNKNOWN];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roadSubType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::RoadSubType_IsValid(value)) {
            set_roadsubtype(static_cast< ::com::telenav::proto::map::RoadSubType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_roadName;
        break;
      }

      // optional string roadName = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_roadName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_roadname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_roadAlias;
        break;
      }

      // optional string roadAlias = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_roadAlias:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_roadalias()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_roadNames;
        break;
      }

      // repeated .com.telenav.proto.map.FeatureName roadNames = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_roadNames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_roadnames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_roadNames;
        if (input->ExpectTag(58)) goto parse_shields;
        break;
      }

      // repeated .com.telenav.proto.map.HighwayShield shields = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shields:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_shields()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_shields;
        if (input->ExpectTag(64)) goto parse_roadFunctionClass;
        break;
      }

      // optional .com.telenav.proto.map.RoadFunctionClass roadFunctionClass = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roadFunctionClass:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::RoadFunctionClass_IsValid(value)) {
            set_roadfunctionclass(static_cast< ::com::telenav::proto::map::RoadFunctionClass >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_roadDirection;
        break;
      }

      // optional .com.telenav.proto.map.RoadDirection roadDirection = 9 [default = UNKONWN];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roadDirection:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::RoadDirection_IsValid(value)) {
            set_roaddirection(static_cast< ::com::telenav::proto::map::RoadDirection >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_featureID;
        break;
      }

      // optional uint64 featureID = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_featureID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &featureid_)));
          set_has_featureid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RoadFeature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.Polyline lines = 1;
  for (int i = 0; i < this->lines_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->lines(i), output);
  }

  // optional .com.telenav.proto.map.RoadType roadType = 2 [default = RT_UNKNOWN];
  if (has_roadtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->roadtype(), output);
  }

  // optional .com.telenav.proto.map.RoadSubType roadSubType = 3 [default = RST_UNKNOWN];
  if (has_roadsubtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->roadsubtype(), output);
  }

  // optional string roadName = 4;
  if (has_roadname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->roadname(), output);
  }

  // optional string roadAlias = 5;
  if (has_roadalias()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->roadalias(), output);
  }

  // repeated .com.telenav.proto.map.FeatureName roadNames = 6;
  for (int i = 0; i < this->roadnames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->roadnames(i), output);
  }

  // repeated .com.telenav.proto.map.HighwayShield shields = 7;
  for (int i = 0; i < this->shields_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->shields(i), output);
  }

  // optional .com.telenav.proto.map.RoadFunctionClass roadFunctionClass = 8;
  if (has_roadfunctionclass()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->roadfunctionclass(), output);
  }

  // optional .com.telenav.proto.map.RoadDirection roadDirection = 9 [default = UNKONWN];
  if (has_roaddirection()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->roaddirection(), output);
  }

  // optional uint64 featureID = 15;
  if (has_featureid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->featureid(), output);
  }

}

int RoadFeature::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .com.telenav.proto.map.RoadType roadType = 2 [default = RT_UNKNOWN];
    if (has_roadtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->roadtype());
    }

    // optional .com.telenav.proto.map.RoadSubType roadSubType = 3 [default = RST_UNKNOWN];
    if (has_roadsubtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->roadsubtype());
    }

    // optional string roadName = 4;
    if (has_roadname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->roadname());
    }

    // optional string roadAlias = 5;
    if (has_roadalias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->roadalias());
    }

    // optional uint64 featureID = 15;
    if (has_featureid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->featureid());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .com.telenav.proto.map.RoadFunctionClass roadFunctionClass = 8;
    if (has_roadfunctionclass()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->roadfunctionclass());
    }

    // optional .com.telenav.proto.map.RoadDirection roadDirection = 9 [default = UNKONWN];
    if (has_roaddirection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->roaddirection());
    }

  }
  // repeated .com.telenav.proto.map.Polyline lines = 1;
  total_size += 1 * this->lines_size();
  for (int i = 0; i < this->lines_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lines(i));
  }

  // repeated .com.telenav.proto.map.FeatureName roadNames = 6;
  total_size += 1 * this->roadnames_size();
  for (int i = 0; i < this->roadnames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->roadnames(i));
  }

  // repeated .com.telenav.proto.map.HighwayShield shields = 7;
  total_size += 1 * this->shields_size();
  for (int i = 0; i < this->shields_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->shields(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoadFeature::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RoadFeature*>(&from));
}

void RoadFeature::MergeFrom(const RoadFeature& from) {
  GOOGLE_CHECK_NE(&from, this);
  lines_.MergeFrom(from.lines_);
  roadnames_.MergeFrom(from.roadnames_);
  shields_.MergeFrom(from.shields_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_roadtype()) {
      set_roadtype(from.roadtype());
    }
    if (from.has_roadsubtype()) {
      set_roadsubtype(from.roadsubtype());
    }
    if (from.has_roadname()) {
      set_roadname(from.roadname());
    }
    if (from.has_roadalias()) {
      set_roadalias(from.roadalias());
    }
    if (from.has_featureid()) {
      set_featureid(from.featureid());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_roadfunctionclass()) {
      set_roadfunctionclass(from.roadfunctionclass());
    }
    if (from.has_roaddirection()) {
      set_roaddirection(from.roaddirection());
    }
  }
}

void RoadFeature::CopyFrom(const RoadFeature& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadFeature::IsInitialized() const {

  return true;
}

void RoadFeature::Swap(RoadFeature* other) {
  if (other != this) {
    lines_.Swap(&other->lines_);
    std::swap(roadtype_, other->roadtype_);
    std::swap(roadsubtype_, other->roadsubtype_);
    std::swap(roadname_, other->roadname_);
    std::swap(roadalias_, other->roadalias_);
    std::swap(featureid_, other->featureid_);
    roadnames_.Swap(&other->roadnames_);
    shields_.Swap(&other->shields_);
    std::swap(roadfunctionclass_, other->roadfunctionclass_);
    std::swap(roaddirection_, other->roaddirection_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RoadFeature::GetTypeName() const {
  return "com.telenav.proto.map.RoadFeature";
}


// ===================================================================

#ifndef _MSC_VER
const int AreaFeature::kRingsFieldNumber;
const int AreaFeature::kNameFieldNumber;
const int AreaFeature::kMainTypeFieldNumber;
const int AreaFeature::kSubTypeFieldNumber;
const int AreaFeature::kFeatureIDFieldNumber;
const int AreaFeature::kAreaNamesFieldNumber;
#endif  // !_MSC_VER

AreaFeature::AreaFeature()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AreaFeature::InitAsDefaultInstance() {
}

AreaFeature::AreaFeature(const AreaFeature& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AreaFeature::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  maintype_ = 0;
  subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  featureid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AreaFeature::~AreaFeature() {
  SharedDtor();
}

void AreaFeature::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    delete subtype_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AreaFeature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AreaFeature& AreaFeature::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

AreaFeature* AreaFeature::default_instance_ = NULL;

AreaFeature* AreaFeature::New() const {
  return new AreaFeature;
}

void AreaFeature::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    maintype_ = 0;
    if (has_subtype()) {
      if (subtype_ != &::google::protobuf::internal::kEmptyString) {
        subtype_->clear();
      }
    }
    featureid_ = GOOGLE_ULONGLONG(0);
  }
  rings_.Clear();
  areanames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AreaFeature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.Polygon rings = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rings()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_rings;
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_mainType;
        break;
      }

      // optional .com.telenav.proto.map.AreaType mainType = 3 [default = BK_AREA_UNKNOWN];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mainType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::AreaType_IsValid(value)) {
            set_maintype(static_cast< ::com::telenav::proto::map::AreaType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_subType;
        break;
      }

      // optional string subType = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_subType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_subtype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_areaNames;
        break;
      }

      // repeated .com.telenav.proto.map.FeatureName areaNames = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_areaNames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_areanames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_areaNames;
        if (input->ExpectTag(120)) goto parse_featureID;
        break;
      }

      // optional uint64 featureID = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_featureID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &featureid_)));
          set_has_featureid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AreaFeature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.Polygon rings = 1;
  for (int i = 0; i < this->rings_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->rings(i), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional .com.telenav.proto.map.AreaType mainType = 3 [default = BK_AREA_UNKNOWN];
  if (has_maintype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->maintype(), output);
  }

  // optional string subType = 4;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->subtype(), output);
  }

  // repeated .com.telenav.proto.map.FeatureName areaNames = 5;
  for (int i = 0; i < this->areanames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->areanames(i), output);
  }

  // optional uint64 featureID = 15;
  if (has_featureid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->featureid(), output);
  }

}

int AreaFeature::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .com.telenav.proto.map.AreaType mainType = 3 [default = BK_AREA_UNKNOWN];
    if (has_maintype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->maintype());
    }

    // optional string subType = 4;
    if (has_subtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->subtype());
    }

    // optional uint64 featureID = 15;
    if (has_featureid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->featureid());
    }

  }
  // repeated .com.telenav.proto.map.Polygon rings = 1;
  total_size += 1 * this->rings_size();
  for (int i = 0; i < this->rings_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rings(i));
  }

  // repeated .com.telenav.proto.map.FeatureName areaNames = 5;
  total_size += 1 * this->areanames_size();
  for (int i = 0; i < this->areanames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->areanames(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AreaFeature::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AreaFeature*>(&from));
}

void AreaFeature::MergeFrom(const AreaFeature& from) {
  GOOGLE_CHECK_NE(&from, this);
  rings_.MergeFrom(from.rings_);
  areanames_.MergeFrom(from.areanames_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_maintype()) {
      set_maintype(from.maintype());
    }
    if (from.has_subtype()) {
      set_subtype(from.subtype());
    }
    if (from.has_featureid()) {
      set_featureid(from.featureid());
    }
  }
}

void AreaFeature::CopyFrom(const AreaFeature& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AreaFeature::IsInitialized() const {

  return true;
}

void AreaFeature::Swap(AreaFeature* other) {
  if (other != this) {
    rings_.Swap(&other->rings_);
    std::swap(name_, other->name_);
    std::swap(maintype_, other->maintype_);
    std::swap(subtype_, other->subtype_);
    std::swap(featureid_, other->featureid_);
    areanames_.Swap(&other->areanames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AreaFeature::GetTypeName() const {
  return "com.telenav.proto.map.AreaFeature";
}


// ===================================================================

#ifndef _MSC_VER
const int LineFeature::kLinesFieldNumber;
const int LineFeature::kNameFieldNumber;
const int LineFeature::kMainTypeFieldNumber;
const int LineFeature::kSubTypeFieldNumber;
const int LineFeature::kFeatureIDFieldNumber;
const int LineFeature::kNamesFieldNumber;
#endif  // !_MSC_VER

LineFeature::LineFeature()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LineFeature::InitAsDefaultInstance() {
}

LineFeature::LineFeature(const LineFeature& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LineFeature::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  maintype_ = 0;
  subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  featureid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LineFeature::~LineFeature() {
  SharedDtor();
}

void LineFeature::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    delete subtype_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LineFeature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LineFeature& LineFeature::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

LineFeature* LineFeature::default_instance_ = NULL;

LineFeature* LineFeature::New() const {
  return new LineFeature;
}

void LineFeature::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    maintype_ = 0;
    if (has_subtype()) {
      if (subtype_ != &::google::protobuf::internal::kEmptyString) {
        subtype_->clear();
      }
    }
    featureid_ = GOOGLE_ULONGLONG(0);
  }
  lines_.Clear();
  names_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LineFeature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.Polyline lines = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lines:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lines()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_lines;
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_mainType;
        break;
      }

      // optional .com.telenav.proto.map.LineType mainType = 3 [default = BK_LINE_UNKNOWN];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mainType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::LineType_IsValid(value)) {
            set_maintype(static_cast< ::com::telenav::proto::map::LineType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_subType;
        break;
      }

      // optional string subType = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_subType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_subtype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_names;
        break;
      }

      // repeated .com.telenav.proto.map.FeatureName names = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_names:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_names()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_names;
        if (input->ExpectTag(120)) goto parse_featureID;
        break;
      }

      // optional uint64 featureID = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_featureID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &featureid_)));
          set_has_featureid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LineFeature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.Polyline lines = 1;
  for (int i = 0; i < this->lines_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->lines(i), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional .com.telenav.proto.map.LineType mainType = 3 [default = BK_LINE_UNKNOWN];
  if (has_maintype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->maintype(), output);
  }

  // optional string subType = 4;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->subtype(), output);
  }

  // repeated .com.telenav.proto.map.FeatureName names = 6;
  for (int i = 0; i < this->names_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->names(i), output);
  }

  // optional uint64 featureID = 15;
  if (has_featureid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->featureid(), output);
  }

}

int LineFeature::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .com.telenav.proto.map.LineType mainType = 3 [default = BK_LINE_UNKNOWN];
    if (has_maintype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->maintype());
    }

    // optional string subType = 4;
    if (has_subtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->subtype());
    }

    // optional uint64 featureID = 15;
    if (has_featureid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->featureid());
    }

  }
  // repeated .com.telenav.proto.map.Polyline lines = 1;
  total_size += 1 * this->lines_size();
  for (int i = 0; i < this->lines_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lines(i));
  }

  // repeated .com.telenav.proto.map.FeatureName names = 6;
  total_size += 1 * this->names_size();
  for (int i = 0; i < this->names_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->names(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LineFeature::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LineFeature*>(&from));
}

void LineFeature::MergeFrom(const LineFeature& from) {
  GOOGLE_CHECK_NE(&from, this);
  lines_.MergeFrom(from.lines_);
  names_.MergeFrom(from.names_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_maintype()) {
      set_maintype(from.maintype());
    }
    if (from.has_subtype()) {
      set_subtype(from.subtype());
    }
    if (from.has_featureid()) {
      set_featureid(from.featureid());
    }
  }
}

void LineFeature::CopyFrom(const LineFeature& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LineFeature::IsInitialized() const {

  return true;
}

void LineFeature::Swap(LineFeature* other) {
  if (other != this) {
    lines_.Swap(&other->lines_);
    std::swap(name_, other->name_);
    std::swap(maintype_, other->maintype_);
    std::swap(subtype_, other->subtype_);
    std::swap(featureid_, other->featureid_);
    names_.Swap(&other->names_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LineFeature::GetTypeName() const {
  return "com.telenav.proto.map.LineFeature";
}


// ===================================================================

#ifndef _MSC_VER
const int PointFeature::kLatlonFieldNumber;
const int PointFeature::kMainTypeFieldNumber;
const int PointFeature::kSubTypeFieldNumber;
const int PointFeature::kNameFieldNumber;
const int PointFeature::kFontSizeFieldNumber;
const int PointFeature::kCountryFieldNumber;
const int PointFeature::kRdNameOriFieldNumber;
const int PointFeature::kFontStyleFieldNumber;
const int PointFeature::kSplineFieldNumber;
const int PointFeature::kPFeatureIDFieldNumber;
const int PointFeature::kFeatureIDFieldNumber;
const int PointFeature::kPointNamesFieldNumber;
const int PointFeature::kLandmarkIconFieldNumber;
#endif  // !_MSC_VER

PointFeature::PointFeature()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PointFeature::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  spline_ = const_cast< ::com::telenav::proto::map::Polyline*>(
      ::com::telenav::proto::map::Polyline::internal_default_instance());
#else
  spline_ = const_cast< ::com::telenav::proto::map::Polyline*>(&::com::telenav::proto::map::Polyline::default_instance());
#endif
}

PointFeature::PointFeature(const PointFeature& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PointFeature::SharedCtor() {
  _cached_size_ = 0;
  maintype_ = 0;
  subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fontsize_ = 0;
  country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fontstyle_ = 0;
  spline_ = NULL;
  featureid_ = GOOGLE_ULONGLONG(0);
  landmark_icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PointFeature::~PointFeature() {
  SharedDtor();
}

void PointFeature::SharedDtor() {
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    delete subtype_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    delete country_;
  }
  if (landmark_icon_ != &::google::protobuf::internal::kEmptyString) {
    delete landmark_icon_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete spline_;
  }
}

void PointFeature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PointFeature& PointFeature::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

PointFeature* PointFeature::default_instance_ = NULL;

PointFeature* PointFeature::New() const {
  return new PointFeature;
}

void PointFeature::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    maintype_ = 0;
    if (has_subtype()) {
      if (subtype_ != &::google::protobuf::internal::kEmptyString) {
        subtype_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    fontsize_ = 0;
    if (has_country()) {
      if (country_ != &::google::protobuf::internal::kEmptyString) {
        country_->clear();
      }
    }
    fontstyle_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_spline()) {
      if (spline_ != NULL) spline_->::com::telenav::proto::map::Polyline::Clear();
    }
    featureid_ = GOOGLE_ULONGLONG(0);
    if (has_landmark_icon()) {
      if (landmark_icon_ != &::google::protobuf::internal::kEmptyString) {
        landmark_icon_->clear();
      }
    }
  }
  latlon_.Clear();
  rdnameori_.Clear();
  p_featureid_.Clear();
  pointnames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PointFeature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated sint32 latlon = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, this->mutable_latlon())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 1, 10, input, this->mutable_latlon())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mainType;
        break;
      }

      // optional .com.telenav.proto.map.PointType mainType = 2 [default = PT_UNKNOWN];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mainType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::PointType_IsValid(value)) {
            set_maintype(static_cast< ::com::telenav::proto::map::PointType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_subType;
        break;
      }

      // optional string subType = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_subType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_subtype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_name;
        break;
      }

      // optional string name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_fontSize;
        break;
      }

      // optional int32 fontSize = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fontSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fontsize_)));
          set_has_fontsize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_country;
        break;
      }

      // optional string country = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_country:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_country()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_rdNameOri;
        break;
      }

      // repeated int32 rdNameOri = 7 [packed = true];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rdNameOri:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_rdnameori())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 58, input, this->mutable_rdnameori())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_fontStyle;
        break;
      }

      // optional .com.telenav.proto.map.FontStyle fontStyle = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fontStyle:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::telenav::proto::map::FontStyle_IsValid(value)) {
            set_fontstyle(static_cast< ::com::telenav::proto::map::FontStyle >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_spline;
        break;
      }

      // optional .com.telenav.proto.map.Polyline spline = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_spline:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_spline()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_pointNames;
        break;
      }

      // repeated .com.telenav.proto.map.FeatureName pointNames = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pointNames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pointnames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_pointNames;
        if (input->ExpectTag(90)) goto parse_landmark_icon;
        break;
      }

      // optional string landmark_icon = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_landmark_icon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_landmark_icon()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_p_featureID;
        break;
      }

      // repeated uint64 p_featureID = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_p_featureID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 112, input, this->mutable_p_featureid())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_p_featureid())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_p_featureID;
        if (input->ExpectTag(120)) goto parse_featureID;
        break;
      }

      // optional uint64 featureID = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_featureID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &featureid_)));
          set_has_featureid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PointFeature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated sint32 latlon = 1 [packed = true];
  if (this->latlon_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_latlon_cached_byte_size_);
  }
  for (int i = 0; i < this->latlon_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32NoTag(
      this->latlon(i), output);
  }

  // optional .com.telenav.proto.map.PointType mainType = 2 [default = PT_UNKNOWN];
  if (has_maintype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->maintype(), output);
  }

  // optional string subType = 3;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->subtype(), output);
  }

  // optional string name = 4;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->name(), output);
  }

  // optional int32 fontSize = 5;
  if (has_fontsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->fontsize(), output);
  }

  // optional string country = 6;
  if (has_country()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->country(), output);
  }

  // repeated int32 rdNameOri = 7 [packed = true];
  if (this->rdnameori_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(7, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_rdnameori_cached_byte_size_);
  }
  for (int i = 0; i < this->rdnameori_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->rdnameori(i), output);
  }

  // optional .com.telenav.proto.map.FontStyle fontStyle = 8;
  if (has_fontstyle()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->fontstyle(), output);
  }

  // optional .com.telenav.proto.map.Polyline spline = 9;
  if (has_spline()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->spline(), output);
  }

  // repeated .com.telenav.proto.map.FeatureName pointNames = 10;
  for (int i = 0; i < this->pointnames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->pointnames(i), output);
  }

  // optional string landmark_icon = 11;
  if (has_landmark_icon()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->landmark_icon(), output);
  }

  // repeated uint64 p_featureID = 14;
  for (int i = 0; i < this->p_featureid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      14, this->p_featureid(i), output);
  }

  // optional uint64 featureID = 15;
  if (has_featureid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->featureid(), output);
  }

}

int PointFeature::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .com.telenav.proto.map.PointType mainType = 2 [default = PT_UNKNOWN];
    if (has_maintype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->maintype());
    }

    // optional string subType = 3;
    if (has_subtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->subtype());
    }

    // optional string name = 4;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 fontSize = 5;
    if (has_fontsize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fontsize());
    }

    // optional string country = 6;
    if (has_country()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->country());
    }

    // optional .com.telenav.proto.map.FontStyle fontStyle = 8;
    if (has_fontstyle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->fontstyle());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .com.telenav.proto.map.Polyline spline = 9;
    if (has_spline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->spline());
    }

    // optional uint64 featureID = 15;
    if (has_featureid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->featureid());
    }

    // optional string landmark_icon = 11;
    if (has_landmark_icon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->landmark_icon());
    }

  }
  // repeated sint32 latlon = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->latlon_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        SInt32Size(this->latlon(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _latlon_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated int32 rdNameOri = 7 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->rdnameori_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->rdnameori(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _rdnameori_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated uint64 p_featureID = 14;
  {
    int data_size = 0;
    for (int i = 0; i < this->p_featureid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->p_featureid(i));
    }
    total_size += 1 * this->p_featureid_size() + data_size;
  }

  // repeated .com.telenav.proto.map.FeatureName pointNames = 10;
  total_size += 1 * this->pointnames_size();
  for (int i = 0; i < this->pointnames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pointnames(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PointFeature::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PointFeature*>(&from));
}

void PointFeature::MergeFrom(const PointFeature& from) {
  GOOGLE_CHECK_NE(&from, this);
  latlon_.MergeFrom(from.latlon_);
  rdnameori_.MergeFrom(from.rdnameori_);
  p_featureid_.MergeFrom(from.p_featureid_);
  pointnames_.MergeFrom(from.pointnames_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_maintype()) {
      set_maintype(from.maintype());
    }
    if (from.has_subtype()) {
      set_subtype(from.subtype());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_fontsize()) {
      set_fontsize(from.fontsize());
    }
    if (from.has_country()) {
      set_country(from.country());
    }
    if (from.has_fontstyle()) {
      set_fontstyle(from.fontstyle());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_spline()) {
      mutable_spline()->::com::telenav::proto::map::Polyline::MergeFrom(from.spline());
    }
    if (from.has_featureid()) {
      set_featureid(from.featureid());
    }
    if (from.has_landmark_icon()) {
      set_landmark_icon(from.landmark_icon());
    }
  }
}

void PointFeature::CopyFrom(const PointFeature& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointFeature::IsInitialized() const {

  return true;
}

void PointFeature::Swap(PointFeature* other) {
  if (other != this) {
    latlon_.Swap(&other->latlon_);
    std::swap(maintype_, other->maintype_);
    std::swap(subtype_, other->subtype_);
    std::swap(name_, other->name_);
    std::swap(fontsize_, other->fontsize_);
    std::swap(country_, other->country_);
    rdnameori_.Swap(&other->rdnameori_);
    std::swap(fontstyle_, other->fontstyle_);
    std::swap(spline_, other->spline_);
    p_featureid_.Swap(&other->p_featureid_);
    std::swap(featureid_, other->featureid_);
    pointnames_.Swap(&other->pointnames_);
    std::swap(landmark_icon_, other->landmark_icon_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PointFeature::GetTypeName() const {
  return "com.telenav.proto.map.PointFeature";
}


// ===================================================================

#ifndef _MSC_VER
const int BuildingBlockRef::kDepthFieldNumber;
const int BuildingBlockRef::kColFieldNumber;
const int BuildingBlockRef::kRowFieldNumber;
#endif  // !_MSC_VER

BuildingBlockRef::BuildingBlockRef()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BuildingBlockRef::InitAsDefaultInstance() {
}

BuildingBlockRef::BuildingBlockRef(const BuildingBlockRef& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BuildingBlockRef::SharedCtor() {
  _cached_size_ = 0;
  depth_ = 0u;
  col_ = 0u;
  row_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuildingBlockRef::~BuildingBlockRef() {
  SharedDtor();
}

void BuildingBlockRef::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BuildingBlockRef::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BuildingBlockRef& BuildingBlockRef::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

BuildingBlockRef* BuildingBlockRef::default_instance_ = NULL;

BuildingBlockRef* BuildingBlockRef::New() const {
  return new BuildingBlockRef;
}

void BuildingBlockRef::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    depth_ = 0u;
    col_ = 0u;
    row_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BuildingBlockRef::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 depth = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &depth_)));
          set_has_depth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_col;
        break;
      }

      // optional uint32 col = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_col:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &col_)));
          set_has_col();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_row;
        break;
      }

      // optional uint32 row = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_row:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &row_)));
          set_has_row();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuildingBlockRef::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 depth = 1;
  if (has_depth()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->depth(), output);
  }

  // optional uint32 col = 2;
  if (has_col()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->col(), output);
  }

  // optional uint32 row = 3;
  if (has_row()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->row(), output);
  }

}

int BuildingBlockRef::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 depth = 1;
    if (has_depth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->depth());
    }

    // optional uint32 col = 2;
    if (has_col()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->col());
    }

    // optional uint32 row = 3;
    if (has_row()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->row());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuildingBlockRef::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BuildingBlockRef*>(&from));
}

void BuildingBlockRef::MergeFrom(const BuildingBlockRef& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_depth()) {
      set_depth(from.depth());
    }
    if (from.has_col()) {
      set_col(from.col());
    }
    if (from.has_row()) {
      set_row(from.row());
    }
  }
}

void BuildingBlockRef::CopyFrom(const BuildingBlockRef& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuildingBlockRef::IsInitialized() const {

  return true;
}

void BuildingBlockRef::Swap(BuildingBlockRef* other) {
  if (other != this) {
    std::swap(depth_, other->depth_);
    std::swap(col_, other->col_);
    std::swap(row_, other->row_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BuildingBlockRef::GetTypeName() const {
  return "com.telenav.proto.map.BuildingBlockRef";
}


// ===================================================================

#ifndef _MSC_VER
const int BuildingBlockList::kVersionFieldNumber;
const int BuildingBlockList::kBlockRefsFieldNumber;
#endif  // !_MSC_VER

BuildingBlockList::BuildingBlockList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BuildingBlockList::InitAsDefaultInstance() {
}

BuildingBlockList::BuildingBlockList(const BuildingBlockList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BuildingBlockList::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuildingBlockList::~BuildingBlockList() {
  SharedDtor();
}

void BuildingBlockList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BuildingBlockList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BuildingBlockList& BuildingBlockList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

BuildingBlockList* BuildingBlockList::default_instance_ = NULL;

BuildingBlockList* BuildingBlockList::New() const {
  return new BuildingBlockList;
}

void BuildingBlockList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0;
  }
  blockrefs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BuildingBlockList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_blockRefs;
        break;
      }

      // repeated .com.telenav.proto.map.BuildingBlockRef blockRefs = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_blockRefs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_blockrefs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_blockRefs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuildingBlockList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->version(), output);
  }

  // repeated .com.telenav.proto.map.BuildingBlockRef blockRefs = 2;
  for (int i = 0; i < this->blockrefs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->blockrefs(i), output);
  }

}

int BuildingBlockList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->version());
    }

  }
  // repeated .com.telenav.proto.map.BuildingBlockRef blockRefs = 2;
  total_size += 1 * this->blockrefs_size();
  for (int i = 0; i < this->blockrefs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->blockrefs(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuildingBlockList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BuildingBlockList*>(&from));
}

void BuildingBlockList::MergeFrom(const BuildingBlockList& from) {
  GOOGLE_CHECK_NE(&from, this);
  blockrefs_.MergeFrom(from.blockrefs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
  }
}

void BuildingBlockList::CopyFrom(const BuildingBlockList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuildingBlockList::IsInitialized() const {

  return true;
}

void BuildingBlockList::Swap(BuildingBlockList* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    blockrefs_.Swap(&other->blockrefs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BuildingBlockList::GetTypeName() const {
  return "com.telenav.proto.map.BuildingBlockList";
}


// ===================================================================

#ifndef _MSC_VER
const int BigTileConfig::kZoomlevelFieldNumber;
#endif  // !_MSC_VER

BigTileConfig::BigTileConfig()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BigTileConfig::InitAsDefaultInstance() {
}

BigTileConfig::BigTileConfig(const BigTileConfig& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BigTileConfig::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BigTileConfig::~BigTileConfig() {
  SharedDtor();
}

void BigTileConfig::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BigTileConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BigTileConfig& BigTileConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

BigTileConfig* BigTileConfig::default_instance_ = NULL;

BigTileConfig* BigTileConfig::New() const {
  return new BigTileConfig;
}

void BigTileConfig::Clear() {
  zoomlevel_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BigTileConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.telenav.proto.map.ZoomLevel zoomlevel = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_zoomlevel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_zoomlevel()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_zoomlevel;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BigTileConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .com.telenav.proto.map.ZoomLevel zoomlevel = 1;
  for (int i = 0; i < this->zoomlevel_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->zoomlevel(i), output);
  }

}

int BigTileConfig::ByteSize() const {
  int total_size = 0;

  // repeated .com.telenav.proto.map.ZoomLevel zoomlevel = 1;
  total_size += 1 * this->zoomlevel_size();
  for (int i = 0; i < this->zoomlevel_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->zoomlevel(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BigTileConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BigTileConfig*>(&from));
}

void BigTileConfig::MergeFrom(const BigTileConfig& from) {
  GOOGLE_CHECK_NE(&from, this);
  zoomlevel_.MergeFrom(from.zoomlevel_);
}

void BigTileConfig::CopyFrom(const BigTileConfig& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BigTileConfig::IsInitialized() const {

  return true;
}

void BigTileConfig::Swap(BigTileConfig* other) {
  if (other != this) {
    zoomlevel_.Swap(&other->zoomlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BigTileConfig::GetTypeName() const {
  return "com.telenav.proto.map.BigTileConfig";
}


// ===================================================================

#ifndef _MSC_VER
const int ZoomLevel::kLevelFieldNumber;
const int ZoomLevel::kPowerFieldNumber;
#endif  // !_MSC_VER

ZoomLevel::ZoomLevel()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ZoomLevel::InitAsDefaultInstance() {
}

ZoomLevel::ZoomLevel(const ZoomLevel& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ZoomLevel::SharedCtor() {
  _cached_size_ = 0;
  level_ = 0;
  power_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ZoomLevel::~ZoomLevel() {
  SharedDtor();
}

void ZoomLevel::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ZoomLevel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ZoomLevel& ZoomLevel::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_map_2evector_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_map_2evector_2eproto();
#endif
  return *default_instance_;
}

ZoomLevel* ZoomLevel::default_instance_ = NULL;

ZoomLevel* ZoomLevel::New() const {
  return new ZoomLevel;
}

void ZoomLevel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    level_ = 0;
    power_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ZoomLevel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 level = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_power;
        break;
      }

      // optional int32 power = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_power:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &power_)));
          set_has_power();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ZoomLevel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 level = 1;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->level(), output);
  }

  // optional int32 power = 2;
  if (has_power()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->power(), output);
  }

}

int ZoomLevel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 level = 1;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

    // optional int32 power = 2;
    if (has_power()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->power());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ZoomLevel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ZoomLevel*>(&from));
}

void ZoomLevel::MergeFrom(const ZoomLevel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_power()) {
      set_power(from.power());
    }
  }
}

void ZoomLevel::CopyFrom(const ZoomLevel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ZoomLevel::IsInitialized() const {

  return true;
}

void ZoomLevel::Swap(ZoomLevel* other) {
  if (other != this) {
    std::swap(level_, other->level_);
    std::swap(power_, other->power_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ZoomLevel::GetTypeName() const {
  return "com.telenav.proto.map.ZoomLevel";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace map
}  // namespace proto
}  // namespace telenav
}  // namespace com

// @@protoc_insertion_point(global_scope)
