// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace telenav {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class LatLon;
class Address;
class Street;
class SearchQuery;
class Facet;
class Currency;
class NameValuePair;

enum CurrencyCode {
  AED = 784,
  AFN = 971,
  ALL = 8,
  AMD = 51,
  ANG = 532,
  AOA = 973,
  ARS = 32,
  AUD = 36,
  AWG = 533,
  AZN = 944,
  BAM = 977,
  BBD = 52,
  BDT = 50,
  BGN = 975,
  BHD = 48,
  BIF = 108,
  BMD = 60,
  BND = 96,
  BOB = 68,
  BOV = 984,
  BRL = 986,
  BTN = 64,
  BWP = 72,
  BYR = 974,
  BZD = 84,
  CAD = 124,
  CDF = 976,
  CHE = 947,
  CHF = 756,
  CHW = 948,
  CLF = 990,
  CLP = 152,
  CNY = 156,
  COP = 170,
  COU = 970,
  CRC = 188,
  CUC = 931,
  CUP = 192,
  CVE = 132,
  CZK = 203,
  DJF = 262,
  DKK = 208,
  DOP = 214,
  DZD = 12,
  EGP = 818,
  ERN = 232,
  ETB = 230,
  EUR = 978,
  FJD = 242,
  FKP = 238,
  GBP = 826,
  GEL = 981,
  GHS = 936,
  GIP = 292,
  GMD = 270,
  GNF = 324,
  GTQ = 320,
  GYD = 328,
  HKD = 344,
  HNL = 340,
  HRK = 191,
  HTG = 332,
  HUF = 348,
  IDR = 360,
  ILS = 376,
  INR = 356,
  IQD = 368,
  IRR = 364,
  ISK = 352,
  JMD = 388,
  JOD = 400,
  JPY = 392,
  KES = 404,
  KGS = 417,
  KHR = 116,
  KMF = 174,
  KPW = 408,
  KRW = 410,
  KWD = 414,
  KYD = 136,
  KZT = 398,
  LAK = 418,
  LBP = 422,
  LKR = 144,
  LRD = 430,
  LSL = 426,
  LTL = 440,
  LVL = 428,
  LYD = 434,
  MAD = 504,
  MDL = 498,
  MGA = 969,
  MKD = 807,
  MMK = 104,
  MNT = 496,
  MOP = 446,
  MRO = 478,
  MUR = 480,
  MVR = 462,
  MWK = 454,
  MXN = 484,
  MXV = 979,
  MYR = 458,
  MZN = 943,
  NAD = 516,
  NGN = 566,
  NIO = 558,
  NOK = 578,
  NPR = 524,
  NZD = 554,
  OMR = 512,
  PAB = 590,
  PEN = 604,
  PGK = 598,
  PHP = 608,
  PKR = 586,
  PLN = 985,
  PYG = 600,
  QAR = 634,
  RON = 946,
  RSD = 941,
  RUB = 643,
  RWF = 646,
  SAR = 682,
  SBD = 90,
  SCR = 690,
  SDG = 938,
  SEK = 752,
  SGD = 702,
  SHP = 654,
  SLL = 694,
  SOS = 706,
  SRD = 968,
  SSP = 728,
  STD = 678,
  SYP = 760,
  SZL = 748,
  THB = 764,
  TJS = 972,
  TMT = 934,
  TND = 788,
  TOP = 776,
  TRY = 949,
  TTD = 780,
  TWD = 901,
  TZS = 834,
  UAH = 980,
  UGX = 800,
  USD = 840,
  USN = 997,
  USS = 998,
  UYI = 940,
  UYU = 858,
  UZS = 860,
  VEF = 937,
  VND = 704,
  VUV = 548,
  WST = 882,
  XAF = 950,
  XAG = 961,
  XAU = 959,
  XBA = 955,
  XBB = 956,
  XBC = 957,
  XBD = 958,
  XCD = 951,
  XDR = 960,
  XOF = 952,
  XPD = 964,
  XPF = 953,
  XPT = 962,
  YER = 886,
  ZAR = 710,
  ZMW = 967
};
bool CurrencyCode_IsValid(int value);
const CurrencyCode CurrencyCode_MIN = ALL;
const CurrencyCode CurrencyCode_MAX = USS;
const int CurrencyCode_ARRAYSIZE = CurrencyCode_MAX + 1;

enum Country {
  AD = 1,
  AE = 2,
  AF = 3,
  AG = 4,
  AI = 5,
  AL = 6,
  AM = 7,
  AN = 8,
  AO = 9,
  AQ = 10,
  AR = 11,
  AS = 12,
  AT = 13,
  AU = 14,
  AW = 15,
  AX = 16,
  AZ = 17,
  BA = 18,
  BB = 19,
  BD = 20,
  BE = 21,
  BF = 22,
  BG = 23,
  BH = 24,
  BI = 25,
  BJ = 26,
  BL = 27,
  BM = 28,
  BN = 29,
  BO = 30,
  BR = 31,
  BS = 32,
  BT = 33,
  BV = 34,
  BW = 35,
  BY = 36,
  BZ = 37,
  CA = 38,
  CC = 39,
  CD = 40,
  CF = 41,
  CG = 42,
  CH = 43,
  CI = 44,
  CK = 45,
  CL = 46,
  CM = 47,
  CN = 48,
  CO = 49,
  CR = 50,
  CU = 51,
  CV = 52,
  CX = 53,
  CY = 54,
  CZ = 55,
  DE = 56,
  DJ = 57,
  DK = 58,
  DM = 59,
  DO = 60,
  DZ = 61,
  EC = 62,
  EE = 63,
  EG = 64,
  EH = 65,
  ER = 66,
  ES = 67,
  ET = 68,
  FI = 69,
  FJ = 70,
  FK = 71,
  FM = 72,
  FO = 73,
  FR = 74,
  GA = 75,
  GB = 76,
  GD = 77,
  GE = 78,
  GF = 79,
  GG = 80,
  GH = 81,
  GI = 82,
  GL = 83,
  GM = 84,
  GN = 85,
  GP = 86,
  GQ = 87,
  GR = 88,
  GS = 89,
  GT = 90,
  GU = 91,
  GW = 92,
  GY = 93,
  HK = 94,
  HM = 95,
  HN = 96,
  HR = 97,
  HT = 98,
  HU = 99,
  ID = 100,
  IE = 101,
  IL = 102,
  IM = 103,
  IO = 105,
  IQ = 106,
  IR = 107,
  IS = 108,
  IT = 109,
  JE = 110,
  JM = 111,
  JO = 112,
  JP = 113,
  KE = 114,
  KG = 115,
  KH = 116,
  KI = 117,
  KM = 118,
  KN = 119,
  KP = 120,
  KR = 121,
  KW = 122,
  KY = 123,
  KZ = 124,
  LA = 125,
  LB = 126,
  LC = 127,
  LI = 128,
  LK = 129,
  LR = 130,
  LS = 131,
  LT = 132,
  LU = 133,
  LV = 134,
  LY = 135,
  MA = 136,
  MC = 137,
  MD = 138,
  ME = 139,
  MF = 140,
  MG = 141,
  MH = 142,
  MK = 143,
  ML = 144,
  MM = 145,
  MN = 146,
  MO = 147,
  MP = 148,
  MQ = 149,
  MR = 150,
  MS = 151,
  MT = 152,
  MU = 153,
  MV = 154,
  MW = 155,
  MX = 156,
  MY = 157,
  MZ = 158,
  NA = 159,
  NC = 160,
  NE = 161,
  NF = 162,
  NG = 163,
  NI = 164,
  NL = 165,
  NP = 167,
  NR = 168,
  NU = 169,
  NZ = 170,
  OM = 171,
  PA = 172,
  PE = 173,
  PF = 174,
  PG = 175,
  PH = 176,
  PK = 177,
  PL = 178,
  PM = 179,
  PN = 180,
  PR = 181,
  PS = 182,
  PT = 183,
  PW = 184,
  PY = 185,
  QA = 186,
  RE = 187,
  RO = 188,
  RS = 189,
  RU = 190,
  RW = 191,
  SA = 192,
  SB = 193,
  SC = 194,
  SD = 195,
  SE = 196,
  SG = 197,
  SH = 198,
  SI = 199,
  SJ = 200,
  SK = 201,
  SL = 202,
  SM = 203,
  SN = 204,
  SO = 205,
  SR = 206,
  ST = 207,
  SV = 208,
  SY = 209,
  SZ = 210,
  TC = 211,
  TD = 212,
  TF = 213,
  TG = 214,
  TH = 215,
  TJ = 216,
  TK = 217,
  TL = 218,
  TM = 219,
  TN = 220,
  TO = 221,
  TR = 222,
  TT = 223,
  TV = 224,
  TW = 225,
  TZ = 226,
  UA = 227,
  UG = 228,
  UM = 229,
  US = 230,
  UY = 231,
  UZ = 232,
  VA = 233,
  VC = 234,
  VE = 235,
  VG = 236,
  VI = 237,
  VN = 238,
  VU = 239,
  WF = 240,
  WS = 241,
  YE = 242,
  YT = 243,
  ZA = 244,
  ZM = 245
};
bool Country_IsValid(int value);
const Country Country_MIN = AD;
const Country Country_MAX = ZM;
const int Country_ARRAYSIZE = Country_MAX + 1;

// ===================================================================

class LatLon : public ::google::protobuf::MessageLite {
 public:
  LatLon();
  virtual ~LatLon();

  LatLon(const LatLon& from);

  inline LatLon& operator=(const LatLon& from) {
    CopyFrom(from);
    return *this;
  }

  static const LatLon& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LatLon* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LatLon* other);

  // implements Message ----------------------------------------------

  LatLon* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LatLon& from);
  void MergeFrom(const LatLon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline double lat() const;
  inline void set_lat(double value);

  // required double lon = 2;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 2;
  inline double lon() const;
  inline void set_lon(double value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.LatLon)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();

  double lat_;
  double lon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LatLon* default_instance_;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::MessageLite {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  static const Address& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Address* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  Address* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string formatted_address = 10;
  inline bool has_formatted_address() const;
  inline void clear_formatted_address();
  static const int kFormattedAddressFieldNumber = 10;
  inline const ::std::string& formatted_address() const;
  inline void set_formatted_address(const ::std::string& value);
  inline void set_formatted_address(const char* value);
  inline void set_formatted_address(const char* value, size_t size);
  inline ::std::string* mutable_formatted_address();
  inline ::std::string* release_formatted_address();
  inline void set_allocated_formatted_address(::std::string* formatted_address);

  // optional string house_number = 20;
  inline bool has_house_number() const;
  inline void clear_house_number();
  static const int kHouseNumberFieldNumber = 20;
  inline const ::std::string& house_number() const;
  inline void set_house_number(const ::std::string& value);
  inline void set_house_number(const char* value);
  inline void set_house_number(const char* value, size_t size);
  inline ::std::string* mutable_house_number();
  inline ::std::string* release_house_number();
  inline void set_allocated_house_number(::std::string* house_number);

  // optional string suite = 30;
  inline bool has_suite() const;
  inline void clear_suite();
  static const int kSuiteFieldNumber = 30;
  inline const ::std::string& suite() const;
  inline void set_suite(const ::std::string& value);
  inline void set_suite(const char* value);
  inline void set_suite(const char* value, size_t size);
  inline ::std::string* mutable_suite();
  inline ::std::string* release_suite();
  inline void set_allocated_suite(::std::string* suite);

  // optional string sub_street = 40;
  inline bool has_sub_street() const;
  inline void clear_sub_street();
  static const int kSubStreetFieldNumber = 40;
  inline const ::std::string& sub_street() const;
  inline void set_sub_street(const ::std::string& value);
  inline void set_sub_street(const char* value);
  inline void set_sub_street(const char* value, size_t size);
  inline ::std::string* mutable_sub_street();
  inline ::std::string* release_sub_street();
  inline void set_allocated_sub_street(::std::string* sub_street);

  // optional .com.telenav.proto.Street street = 50;
  inline bool has_street() const;
  inline void clear_street();
  static const int kStreetFieldNumber = 50;
  inline const ::com::telenav::proto::Street& street() const;
  inline ::com::telenav::proto::Street* mutable_street();
  inline ::com::telenav::proto::Street* release_street();
  inline void set_allocated_street(::com::telenav::proto::Street* street);

  // optional .com.telenav.proto.Street cross_street = 60;
  inline bool has_cross_street() const;
  inline void clear_cross_street();
  static const int kCrossStreetFieldNumber = 60;
  inline const ::com::telenav::proto::Street& cross_street() const;
  inline ::com::telenav::proto::Street* mutable_cross_street();
  inline ::com::telenav::proto::Street* release_cross_street();
  inline void set_allocated_cross_street(::com::telenav::proto::Street* cross_street);

  // optional string sub_locality = 70;
  inline bool has_sub_locality() const;
  inline void clear_sub_locality();
  static const int kSubLocalityFieldNumber = 70;
  inline const ::std::string& sub_locality() const;
  inline void set_sub_locality(const ::std::string& value);
  inline void set_sub_locality(const char* value);
  inline void set_sub_locality(const char* value, size_t size);
  inline ::std::string* mutable_sub_locality();
  inline ::std::string* release_sub_locality();
  inline void set_allocated_sub_locality(::std::string* sub_locality);

  // optional string locality = 80;
  inline bool has_locality() const;
  inline void clear_locality();
  static const int kLocalityFieldNumber = 80;
  inline const ::std::string& locality() const;
  inline void set_locality(const ::std::string& value);
  inline void set_locality(const char* value);
  inline void set_locality(const char* value, size_t size);
  inline ::std::string* mutable_locality();
  inline ::std::string* release_locality();
  inline void set_allocated_locality(::std::string* locality);

  // optional string city = 90;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 90;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string county = 100;
  inline bool has_county() const;
  inline void clear_county();
  static const int kCountyFieldNumber = 100;
  inline const ::std::string& county() const;
  inline void set_county(const ::std::string& value);
  inline void set_county(const char* value);
  inline void set_county(const char* value, size_t size);
  inline ::std::string* mutable_county();
  inline ::std::string* release_county();
  inline void set_allocated_county(::std::string* county);

  // optional string state = 110;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 110;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional .com.telenav.proto.Country country = 120;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 120;
  inline ::com::telenav::proto::Country country() const;
  inline void set_country(::com::telenav::proto::Country value);

  // optional string postal_code = 130;
  inline bool has_postal_code() const;
  inline void clear_postal_code();
  static const int kPostalCodeFieldNumber = 130;
  inline const ::std::string& postal_code() const;
  inline void set_postal_code(const ::std::string& value);
  inline void set_postal_code(const char* value);
  inline void set_postal_code(const char* value, size_t size);
  inline ::std::string* mutable_postal_code();
  inline ::std::string* release_postal_code();
  inline void set_allocated_postal_code(::std::string* postal_code);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.Address)
 private:
  inline void set_has_formatted_address();
  inline void clear_has_formatted_address();
  inline void set_has_house_number();
  inline void clear_has_house_number();
  inline void set_has_suite();
  inline void clear_has_suite();
  inline void set_has_sub_street();
  inline void clear_has_sub_street();
  inline void set_has_street();
  inline void clear_has_street();
  inline void set_has_cross_street();
  inline void clear_has_cross_street();
  inline void set_has_sub_locality();
  inline void clear_has_sub_locality();
  inline void set_has_locality();
  inline void clear_has_locality();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_county();
  inline void clear_has_county();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_postal_code();
  inline void clear_has_postal_code();

  ::std::string* formatted_address_;
  ::std::string* house_number_;
  ::std::string* suite_;
  ::std::string* sub_street_;
  ::com::telenav::proto::Street* street_;
  ::com::telenav::proto::Street* cross_street_;
  ::std::string* sub_locality_;
  ::std::string* locality_;
  ::std::string* city_;
  ::std::string* county_;
  ::std::string* state_;
  ::std::string* postal_code_;
  int country_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class Street : public ::google::protobuf::MessageLite {
 public:
  Street();
  virtual ~Street();

  Street(const Street& from);

  inline Street& operator=(const Street& from) {
    CopyFrom(from);
    return *this;
  }

  static const Street& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Street* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Street* other);

  // implements Message ----------------------------------------------

  Street* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Street& from);
  void MergeFrom(const Street& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string dirs = 10;
  inline int dirs_size() const;
  inline void clear_dirs();
  static const int kDirsFieldNumber = 10;
  inline const ::std::string& dirs(int index) const;
  inline ::std::string* mutable_dirs(int index);
  inline void set_dirs(int index, const ::std::string& value);
  inline void set_dirs(int index, const char* value);
  inline void set_dirs(int index, const char* value, size_t size);
  inline ::std::string* add_dirs();
  inline void add_dirs(const ::std::string& value);
  inline void add_dirs(const char* value);
  inline void add_dirs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& dirs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dirs();

  // optional string body = 20;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 20;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const char* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // optional string type = 30;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 30;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string formatted_name = 40;
  inline bool has_formatted_name() const;
  inline void clear_formatted_name();
  static const int kFormattedNameFieldNumber = 40;
  inline const ::std::string& formatted_name() const;
  inline void set_formatted_name(const ::std::string& value);
  inline void set_formatted_name(const char* value);
  inline void set_formatted_name(const char* value, size_t size);
  inline ::std::string* mutable_formatted_name();
  inline ::std::string* release_formatted_name();
  inline void set_allocated_formatted_name(::std::string* formatted_name);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.Street)
 private:
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_formatted_name();
  inline void clear_has_formatted_name();

  ::google::protobuf::RepeatedPtrField< ::std::string> dirs_;
  ::std::string* body_;
  ::std::string* type_;
  ::std::string* formatted_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Street* default_instance_;
};
// -------------------------------------------------------------------

class SearchQuery : public ::google::protobuf::MessageLite {
 public:
  SearchQuery();
  virtual ~SearchQuery();

  SearchQuery(const SearchQuery& from);

  inline SearchQuery& operator=(const SearchQuery& from) {
    CopyFrom(from);
    return *this;
  }

  static const SearchQuery& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SearchQuery* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SearchQuery* other);

  // implements Message ----------------------------------------------

  SearchQuery* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SearchQuery& from);
  void MergeFrom(const SearchQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string domain = 10;
  inline int domain_size() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 10;
  inline const ::std::string& domain(int index) const;
  inline ::std::string* mutable_domain(int index);
  inline void set_domain(int index, const ::std::string& value);
  inline void set_domain(int index, const char* value);
  inline void set_domain(int index, const char* value, size_t size);
  inline ::std::string* add_domain();
  inline void add_domain(const ::std::string& value);
  inline void add_domain(const char* value);
  inline void add_domain(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& domain() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_domain();

  // repeated string category = 20;
  inline int category_size() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 20;
  inline const ::std::string& category(int index) const;
  inline ::std::string* mutable_category(int index);
  inline void set_category(int index, const ::std::string& value);
  inline void set_category(int index, const char* value);
  inline void set_category(int index, const char* value, size_t size);
  inline ::std::string* add_category();
  inline void add_category(const ::std::string& value);
  inline void add_category(const char* value);
  inline void add_category(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& category() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_category();

  // @@protoc_insertion_point(class_scope:com.telenav.proto.SearchQuery)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> domain_;
  ::google::protobuf::RepeatedPtrField< ::std::string> category_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static SearchQuery* default_instance_;
};
// -------------------------------------------------------------------

class Facet : public ::google::protobuf::MessageLite {
 public:
  Facet();
  virtual ~Facet();

  Facet(const Facet& from);

  inline Facet& operator=(const Facet& from) {
    CopyFrom(from);
    return *this;
  }

  static const Facet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Facet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Facet* other);

  // implements Message ----------------------------------------------

  Facet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Facet& from);
  void MergeFrom(const Facet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string facet_data = 20;
  inline bool has_facet_data() const;
  inline void clear_facet_data();
  static const int kFacetDataFieldNumber = 20;
  inline const ::std::string& facet_data() const;
  inline void set_facet_data(const ::std::string& value);
  inline void set_facet_data(const char* value);
  inline void set_facet_data(const char* value, size_t size);
  inline ::std::string* mutable_facet_data();
  inline ::std::string* release_facet_data();
  inline void set_allocated_facet_data(::std::string* facet_data);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.Facet)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_facet_data();
  inline void clear_has_facet_data();

  ::std::string* type_;
  ::std::string* facet_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Facet* default_instance_;
};
// -------------------------------------------------------------------

class Currency : public ::google::protobuf::MessageLite {
 public:
  Currency();
  virtual ~Currency();

  Currency(const Currency& from);

  inline Currency& operator=(const Currency& from) {
    CopyFrom(from);
    return *this;
  }

  static const Currency& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Currency* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Currency* other);

  // implements Message ----------------------------------------------

  Currency* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Currency& from);
  void MergeFrom(const Currency& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float value = 10;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 10;
  inline float value() const;
  inline void set_value(float value);

  // required .com.telenav.proto.CurrencyCode iso_code = 20;
  inline bool has_iso_code() const;
  inline void clear_iso_code();
  static const int kIsoCodeFieldNumber = 20;
  inline ::com::telenav::proto::CurrencyCode iso_code() const;
  inline void set_iso_code(::com::telenav::proto::CurrencyCode value);

  // optional string symbol = 30;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 30;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.Currency)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_iso_code();
  inline void clear_has_iso_code();
  inline void set_has_symbol();
  inline void clear_has_symbol();

  float value_;
  int iso_code_;
  ::std::string* symbol_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Currency* default_instance_;
};
// -------------------------------------------------------------------

class NameValuePair : public ::google::protobuf::MessageLite {
 public:
  NameValuePair();
  virtual ~NameValuePair();

  NameValuePair(const NameValuePair& from);

  inline NameValuePair& operator=(const NameValuePair& from) {
    CopyFrom(from);
    return *this;
  }

  static const NameValuePair& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NameValuePair* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NameValuePair* other);

  // implements Message ----------------------------------------------

  NameValuePair* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NameValuePair& from);
  void MergeFrom(const NameValuePair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 20;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 20;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:com.telenav.proto.NameValuePair)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static NameValuePair* default_instance_;
};
// ===================================================================


// ===================================================================

// LatLon

// required double lat = 1;
inline bool LatLon::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LatLon::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LatLon::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LatLon::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double LatLon::lat() const {
  return lat_;
}
inline void LatLon::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// required double lon = 2;
inline bool LatLon::has_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LatLon::set_has_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LatLon::clear_has_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LatLon::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double LatLon::lon() const {
  return lon_;
}
inline void LatLon::set_lon(double value) {
  set_has_lon();
  lon_ = value;
}

// -------------------------------------------------------------------

// Address

// optional string formatted_address = 10;
inline bool Address::has_formatted_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_formatted_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_formatted_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_formatted_address() {
  if (formatted_address_ != &::google::protobuf::internal::kEmptyString) {
    formatted_address_->clear();
  }
  clear_has_formatted_address();
}
inline const ::std::string& Address::formatted_address() const {
  return *formatted_address_;
}
inline void Address::set_formatted_address(const ::std::string& value) {
  set_has_formatted_address();
  if (formatted_address_ == &::google::protobuf::internal::kEmptyString) {
    formatted_address_ = new ::std::string;
  }
  formatted_address_->assign(value);
}
inline void Address::set_formatted_address(const char* value) {
  set_has_formatted_address();
  if (formatted_address_ == &::google::protobuf::internal::kEmptyString) {
    formatted_address_ = new ::std::string;
  }
  formatted_address_->assign(value);
}
inline void Address::set_formatted_address(const char* value, size_t size) {
  set_has_formatted_address();
  if (formatted_address_ == &::google::protobuf::internal::kEmptyString) {
    formatted_address_ = new ::std::string;
  }
  formatted_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_formatted_address() {
  set_has_formatted_address();
  if (formatted_address_ == &::google::protobuf::internal::kEmptyString) {
    formatted_address_ = new ::std::string;
  }
  return formatted_address_;
}
inline ::std::string* Address::release_formatted_address() {
  clear_has_formatted_address();
  if (formatted_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = formatted_address_;
    formatted_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_formatted_address(::std::string* formatted_address) {
  if (formatted_address_ != &::google::protobuf::internal::kEmptyString) {
    delete formatted_address_;
  }
  if (formatted_address) {
    set_has_formatted_address();
    formatted_address_ = formatted_address;
  } else {
    clear_has_formatted_address();
    formatted_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string house_number = 20;
inline bool Address::has_house_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address::set_has_house_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address::clear_has_house_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address::clear_house_number() {
  if (house_number_ != &::google::protobuf::internal::kEmptyString) {
    house_number_->clear();
  }
  clear_has_house_number();
}
inline const ::std::string& Address::house_number() const {
  return *house_number_;
}
inline void Address::set_house_number(const ::std::string& value) {
  set_has_house_number();
  if (house_number_ == &::google::protobuf::internal::kEmptyString) {
    house_number_ = new ::std::string;
  }
  house_number_->assign(value);
}
inline void Address::set_house_number(const char* value) {
  set_has_house_number();
  if (house_number_ == &::google::protobuf::internal::kEmptyString) {
    house_number_ = new ::std::string;
  }
  house_number_->assign(value);
}
inline void Address::set_house_number(const char* value, size_t size) {
  set_has_house_number();
  if (house_number_ == &::google::protobuf::internal::kEmptyString) {
    house_number_ = new ::std::string;
  }
  house_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_house_number() {
  set_has_house_number();
  if (house_number_ == &::google::protobuf::internal::kEmptyString) {
    house_number_ = new ::std::string;
  }
  return house_number_;
}
inline ::std::string* Address::release_house_number() {
  clear_has_house_number();
  if (house_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = house_number_;
    house_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_house_number(::std::string* house_number) {
  if (house_number_ != &::google::protobuf::internal::kEmptyString) {
    delete house_number_;
  }
  if (house_number) {
    set_has_house_number();
    house_number_ = house_number;
  } else {
    clear_has_house_number();
    house_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string suite = 30;
inline bool Address::has_suite() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Address::set_has_suite() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Address::clear_has_suite() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Address::clear_suite() {
  if (suite_ != &::google::protobuf::internal::kEmptyString) {
    suite_->clear();
  }
  clear_has_suite();
}
inline const ::std::string& Address::suite() const {
  return *suite_;
}
inline void Address::set_suite(const ::std::string& value) {
  set_has_suite();
  if (suite_ == &::google::protobuf::internal::kEmptyString) {
    suite_ = new ::std::string;
  }
  suite_->assign(value);
}
inline void Address::set_suite(const char* value) {
  set_has_suite();
  if (suite_ == &::google::protobuf::internal::kEmptyString) {
    suite_ = new ::std::string;
  }
  suite_->assign(value);
}
inline void Address::set_suite(const char* value, size_t size) {
  set_has_suite();
  if (suite_ == &::google::protobuf::internal::kEmptyString) {
    suite_ = new ::std::string;
  }
  suite_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_suite() {
  set_has_suite();
  if (suite_ == &::google::protobuf::internal::kEmptyString) {
    suite_ = new ::std::string;
  }
  return suite_;
}
inline ::std::string* Address::release_suite() {
  clear_has_suite();
  if (suite_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suite_;
    suite_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_suite(::std::string* suite) {
  if (suite_ != &::google::protobuf::internal::kEmptyString) {
    delete suite_;
  }
  if (suite) {
    set_has_suite();
    suite_ = suite;
  } else {
    clear_has_suite();
    suite_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sub_street = 40;
inline bool Address::has_sub_street() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Address::set_has_sub_street() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Address::clear_has_sub_street() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Address::clear_sub_street() {
  if (sub_street_ != &::google::protobuf::internal::kEmptyString) {
    sub_street_->clear();
  }
  clear_has_sub_street();
}
inline const ::std::string& Address::sub_street() const {
  return *sub_street_;
}
inline void Address::set_sub_street(const ::std::string& value) {
  set_has_sub_street();
  if (sub_street_ == &::google::protobuf::internal::kEmptyString) {
    sub_street_ = new ::std::string;
  }
  sub_street_->assign(value);
}
inline void Address::set_sub_street(const char* value) {
  set_has_sub_street();
  if (sub_street_ == &::google::protobuf::internal::kEmptyString) {
    sub_street_ = new ::std::string;
  }
  sub_street_->assign(value);
}
inline void Address::set_sub_street(const char* value, size_t size) {
  set_has_sub_street();
  if (sub_street_ == &::google::protobuf::internal::kEmptyString) {
    sub_street_ = new ::std::string;
  }
  sub_street_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_sub_street() {
  set_has_sub_street();
  if (sub_street_ == &::google::protobuf::internal::kEmptyString) {
    sub_street_ = new ::std::string;
  }
  return sub_street_;
}
inline ::std::string* Address::release_sub_street() {
  clear_has_sub_street();
  if (sub_street_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sub_street_;
    sub_street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_sub_street(::std::string* sub_street) {
  if (sub_street_ != &::google::protobuf::internal::kEmptyString) {
    delete sub_street_;
  }
  if (sub_street) {
    set_has_sub_street();
    sub_street_ = sub_street;
  } else {
    clear_has_sub_street();
    sub_street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.telenav.proto.Street street = 50;
inline bool Address::has_street() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Address::set_has_street() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Address::clear_has_street() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Address::clear_street() {
  if (street_ != NULL) street_->::com::telenav::proto::Street::Clear();
  clear_has_street();
}
inline const ::com::telenav::proto::Street& Address::street() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return street_ != NULL ? *street_ : *default_instance().street_;
#else
  return street_ != NULL ? *street_ : *default_instance_->street_;
#endif
}
inline ::com::telenav::proto::Street* Address::mutable_street() {
  set_has_street();
  if (street_ == NULL) street_ = new ::com::telenav::proto::Street;
  return street_;
}
inline ::com::telenav::proto::Street* Address::release_street() {
  clear_has_street();
  ::com::telenav::proto::Street* temp = street_;
  street_ = NULL;
  return temp;
}
inline void Address::set_allocated_street(::com::telenav::proto::Street* street) {
  delete street_;
  street_ = street;
  if (street) {
    set_has_street();
  } else {
    clear_has_street();
  }
}

// optional .com.telenav.proto.Street cross_street = 60;
inline bool Address::has_cross_street() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Address::set_has_cross_street() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Address::clear_has_cross_street() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Address::clear_cross_street() {
  if (cross_street_ != NULL) cross_street_->::com::telenav::proto::Street::Clear();
  clear_has_cross_street();
}
inline const ::com::telenav::proto::Street& Address::cross_street() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cross_street_ != NULL ? *cross_street_ : *default_instance().cross_street_;
#else
  return cross_street_ != NULL ? *cross_street_ : *default_instance_->cross_street_;
#endif
}
inline ::com::telenav::proto::Street* Address::mutable_cross_street() {
  set_has_cross_street();
  if (cross_street_ == NULL) cross_street_ = new ::com::telenav::proto::Street;
  return cross_street_;
}
inline ::com::telenav::proto::Street* Address::release_cross_street() {
  clear_has_cross_street();
  ::com::telenav::proto::Street* temp = cross_street_;
  cross_street_ = NULL;
  return temp;
}
inline void Address::set_allocated_cross_street(::com::telenav::proto::Street* cross_street) {
  delete cross_street_;
  cross_street_ = cross_street;
  if (cross_street) {
    set_has_cross_street();
  } else {
    clear_has_cross_street();
  }
}

// optional string sub_locality = 70;
inline bool Address::has_sub_locality() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Address::set_has_sub_locality() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Address::clear_has_sub_locality() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Address::clear_sub_locality() {
  if (sub_locality_ != &::google::protobuf::internal::kEmptyString) {
    sub_locality_->clear();
  }
  clear_has_sub_locality();
}
inline const ::std::string& Address::sub_locality() const {
  return *sub_locality_;
}
inline void Address::set_sub_locality(const ::std::string& value) {
  set_has_sub_locality();
  if (sub_locality_ == &::google::protobuf::internal::kEmptyString) {
    sub_locality_ = new ::std::string;
  }
  sub_locality_->assign(value);
}
inline void Address::set_sub_locality(const char* value) {
  set_has_sub_locality();
  if (sub_locality_ == &::google::protobuf::internal::kEmptyString) {
    sub_locality_ = new ::std::string;
  }
  sub_locality_->assign(value);
}
inline void Address::set_sub_locality(const char* value, size_t size) {
  set_has_sub_locality();
  if (sub_locality_ == &::google::protobuf::internal::kEmptyString) {
    sub_locality_ = new ::std::string;
  }
  sub_locality_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_sub_locality() {
  set_has_sub_locality();
  if (sub_locality_ == &::google::protobuf::internal::kEmptyString) {
    sub_locality_ = new ::std::string;
  }
  return sub_locality_;
}
inline ::std::string* Address::release_sub_locality() {
  clear_has_sub_locality();
  if (sub_locality_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sub_locality_;
    sub_locality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_sub_locality(::std::string* sub_locality) {
  if (sub_locality_ != &::google::protobuf::internal::kEmptyString) {
    delete sub_locality_;
  }
  if (sub_locality) {
    set_has_sub_locality();
    sub_locality_ = sub_locality;
  } else {
    clear_has_sub_locality();
    sub_locality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string locality = 80;
inline bool Address::has_locality() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Address::set_has_locality() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Address::clear_has_locality() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Address::clear_locality() {
  if (locality_ != &::google::protobuf::internal::kEmptyString) {
    locality_->clear();
  }
  clear_has_locality();
}
inline const ::std::string& Address::locality() const {
  return *locality_;
}
inline void Address::set_locality(const ::std::string& value) {
  set_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    locality_ = new ::std::string;
  }
  locality_->assign(value);
}
inline void Address::set_locality(const char* value) {
  set_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    locality_ = new ::std::string;
  }
  locality_->assign(value);
}
inline void Address::set_locality(const char* value, size_t size) {
  set_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    locality_ = new ::std::string;
  }
  locality_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_locality() {
  set_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    locality_ = new ::std::string;
  }
  return locality_;
}
inline ::std::string* Address::release_locality() {
  clear_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locality_;
    locality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_locality(::std::string* locality) {
  if (locality_ != &::google::protobuf::internal::kEmptyString) {
    delete locality_;
  }
  if (locality) {
    set_has_locality();
    locality_ = locality;
  } else {
    clear_has_locality();
    locality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string city = 90;
inline bool Address::has_city() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Address::set_has_city() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Address::clear_has_city() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Address::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& Address::city() const {
  return *city_;
}
inline void Address::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void Address::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void Address::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* Address::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string county = 100;
inline bool Address::has_county() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Address::set_has_county() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Address::clear_has_county() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Address::clear_county() {
  if (county_ != &::google::protobuf::internal::kEmptyString) {
    county_->clear();
  }
  clear_has_county();
}
inline const ::std::string& Address::county() const {
  return *county_;
}
inline void Address::set_county(const ::std::string& value) {
  set_has_county();
  if (county_ == &::google::protobuf::internal::kEmptyString) {
    county_ = new ::std::string;
  }
  county_->assign(value);
}
inline void Address::set_county(const char* value) {
  set_has_county();
  if (county_ == &::google::protobuf::internal::kEmptyString) {
    county_ = new ::std::string;
  }
  county_->assign(value);
}
inline void Address::set_county(const char* value, size_t size) {
  set_has_county();
  if (county_ == &::google::protobuf::internal::kEmptyString) {
    county_ = new ::std::string;
  }
  county_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_county() {
  set_has_county();
  if (county_ == &::google::protobuf::internal::kEmptyString) {
    county_ = new ::std::string;
  }
  return county_;
}
inline ::std::string* Address::release_county() {
  clear_has_county();
  if (county_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = county_;
    county_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_county(::std::string* county) {
  if (county_ != &::google::protobuf::internal::kEmptyString) {
    delete county_;
  }
  if (county) {
    set_has_county();
    county_ = county;
  } else {
    clear_has_county();
    county_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state = 110;
inline bool Address::has_state() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Address::set_has_state() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Address::clear_has_state() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Address::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& Address::state() const {
  return *state_;
}
inline void Address::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void Address::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void Address::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* Address::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.telenav.proto.Country country = 120;
inline bool Address::has_country() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Address::set_has_country() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Address::clear_has_country() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Address::clear_country() {
  country_ = 1;
  clear_has_country();
}
inline ::com::telenav::proto::Country Address::country() const {
  return static_cast< ::com::telenav::proto::Country >(country_);
}
inline void Address::set_country(::com::telenav::proto::Country value) {
  assert(::com::telenav::proto::Country_IsValid(value));
  set_has_country();
  country_ = value;
}

// optional string postal_code = 130;
inline bool Address::has_postal_code() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Address::set_has_postal_code() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Address::clear_has_postal_code() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Address::clear_postal_code() {
  if (postal_code_ != &::google::protobuf::internal::kEmptyString) {
    postal_code_->clear();
  }
  clear_has_postal_code();
}
inline const ::std::string& Address::postal_code() const {
  return *postal_code_;
}
inline void Address::set_postal_code(const ::std::string& value) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(value);
}
inline void Address::set_postal_code(const char* value) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(value);
}
inline void Address::set_postal_code(const char* value, size_t size) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_postal_code() {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  return postal_code_;
}
inline ::std::string* Address::release_postal_code() {
  clear_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = postal_code_;
    postal_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_postal_code(::std::string* postal_code) {
  if (postal_code_ != &::google::protobuf::internal::kEmptyString) {
    delete postal_code_;
  }
  if (postal_code) {
    set_has_postal_code();
    postal_code_ = postal_code;
  } else {
    clear_has_postal_code();
    postal_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Street

// repeated string dirs = 10;
inline int Street::dirs_size() const {
  return dirs_.size();
}
inline void Street::clear_dirs() {
  dirs_.Clear();
}
inline const ::std::string& Street::dirs(int index) const {
  return dirs_.Get(index);
}
inline ::std::string* Street::mutable_dirs(int index) {
  return dirs_.Mutable(index);
}
inline void Street::set_dirs(int index, const ::std::string& value) {
  dirs_.Mutable(index)->assign(value);
}
inline void Street::set_dirs(int index, const char* value) {
  dirs_.Mutable(index)->assign(value);
}
inline void Street::set_dirs(int index, const char* value, size_t size) {
  dirs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Street::add_dirs() {
  return dirs_.Add();
}
inline void Street::add_dirs(const ::std::string& value) {
  dirs_.Add()->assign(value);
}
inline void Street::add_dirs(const char* value) {
  dirs_.Add()->assign(value);
}
inline void Street::add_dirs(const char* value, size_t size) {
  dirs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Street::dirs() const {
  return dirs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Street::mutable_dirs() {
  return &dirs_;
}

// optional string body = 20;
inline bool Street::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Street::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Street::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Street::clear_body() {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& Street::body() const {
  return *body_;
}
inline void Street::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void Street::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void Street::set_body(const char* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Street::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  return body_;
}
inline ::std::string* Street::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Street::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 30;
inline bool Street::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Street::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Street::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Street::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Street::type() const {
  return *type_;
}
inline void Street::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Street::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Street::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Street::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* Street::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Street::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string formatted_name = 40;
inline bool Street::has_formatted_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Street::set_has_formatted_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Street::clear_has_formatted_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Street::clear_formatted_name() {
  if (formatted_name_ != &::google::protobuf::internal::kEmptyString) {
    formatted_name_->clear();
  }
  clear_has_formatted_name();
}
inline const ::std::string& Street::formatted_name() const {
  return *formatted_name_;
}
inline void Street::set_formatted_name(const ::std::string& value) {
  set_has_formatted_name();
  if (formatted_name_ == &::google::protobuf::internal::kEmptyString) {
    formatted_name_ = new ::std::string;
  }
  formatted_name_->assign(value);
}
inline void Street::set_formatted_name(const char* value) {
  set_has_formatted_name();
  if (formatted_name_ == &::google::protobuf::internal::kEmptyString) {
    formatted_name_ = new ::std::string;
  }
  formatted_name_->assign(value);
}
inline void Street::set_formatted_name(const char* value, size_t size) {
  set_has_formatted_name();
  if (formatted_name_ == &::google::protobuf::internal::kEmptyString) {
    formatted_name_ = new ::std::string;
  }
  formatted_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Street::mutable_formatted_name() {
  set_has_formatted_name();
  if (formatted_name_ == &::google::protobuf::internal::kEmptyString) {
    formatted_name_ = new ::std::string;
  }
  return formatted_name_;
}
inline ::std::string* Street::release_formatted_name() {
  clear_has_formatted_name();
  if (formatted_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = formatted_name_;
    formatted_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Street::set_allocated_formatted_name(::std::string* formatted_name) {
  if (formatted_name_ != &::google::protobuf::internal::kEmptyString) {
    delete formatted_name_;
  }
  if (formatted_name) {
    set_has_formatted_name();
    formatted_name_ = formatted_name;
  } else {
    clear_has_formatted_name();
    formatted_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SearchQuery

// repeated string domain = 10;
inline int SearchQuery::domain_size() const {
  return domain_.size();
}
inline void SearchQuery::clear_domain() {
  domain_.Clear();
}
inline const ::std::string& SearchQuery::domain(int index) const {
  return domain_.Get(index);
}
inline ::std::string* SearchQuery::mutable_domain(int index) {
  return domain_.Mutable(index);
}
inline void SearchQuery::set_domain(int index, const ::std::string& value) {
  domain_.Mutable(index)->assign(value);
}
inline void SearchQuery::set_domain(int index, const char* value) {
  domain_.Mutable(index)->assign(value);
}
inline void SearchQuery::set_domain(int index, const char* value, size_t size) {
  domain_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchQuery::add_domain() {
  return domain_.Add();
}
inline void SearchQuery::add_domain(const ::std::string& value) {
  domain_.Add()->assign(value);
}
inline void SearchQuery::add_domain(const char* value) {
  domain_.Add()->assign(value);
}
inline void SearchQuery::add_domain(const char* value, size_t size) {
  domain_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SearchQuery::domain() const {
  return domain_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SearchQuery::mutable_domain() {
  return &domain_;
}

// repeated string category = 20;
inline int SearchQuery::category_size() const {
  return category_.size();
}
inline void SearchQuery::clear_category() {
  category_.Clear();
}
inline const ::std::string& SearchQuery::category(int index) const {
  return category_.Get(index);
}
inline ::std::string* SearchQuery::mutable_category(int index) {
  return category_.Mutable(index);
}
inline void SearchQuery::set_category(int index, const ::std::string& value) {
  category_.Mutable(index)->assign(value);
}
inline void SearchQuery::set_category(int index, const char* value) {
  category_.Mutable(index)->assign(value);
}
inline void SearchQuery::set_category(int index, const char* value, size_t size) {
  category_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchQuery::add_category() {
  return category_.Add();
}
inline void SearchQuery::add_category(const ::std::string& value) {
  category_.Add()->assign(value);
}
inline void SearchQuery::add_category(const char* value) {
  category_.Add()->assign(value);
}
inline void SearchQuery::add_category(const char* value, size_t size) {
  category_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SearchQuery::category() const {
  return category_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SearchQuery::mutable_category() {
  return &category_;
}

// -------------------------------------------------------------------

// Facet

// required string type = 10;
inline bool Facet::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Facet::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Facet::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Facet::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Facet::type() const {
  return *type_;
}
inline void Facet::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Facet::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Facet::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Facet::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* Facet::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Facet::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string facet_data = 20;
inline bool Facet::has_facet_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Facet::set_has_facet_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Facet::clear_has_facet_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Facet::clear_facet_data() {
  if (facet_data_ != &::google::protobuf::internal::kEmptyString) {
    facet_data_->clear();
  }
  clear_has_facet_data();
}
inline const ::std::string& Facet::facet_data() const {
  return *facet_data_;
}
inline void Facet::set_facet_data(const ::std::string& value) {
  set_has_facet_data();
  if (facet_data_ == &::google::protobuf::internal::kEmptyString) {
    facet_data_ = new ::std::string;
  }
  facet_data_->assign(value);
}
inline void Facet::set_facet_data(const char* value) {
  set_has_facet_data();
  if (facet_data_ == &::google::protobuf::internal::kEmptyString) {
    facet_data_ = new ::std::string;
  }
  facet_data_->assign(value);
}
inline void Facet::set_facet_data(const char* value, size_t size) {
  set_has_facet_data();
  if (facet_data_ == &::google::protobuf::internal::kEmptyString) {
    facet_data_ = new ::std::string;
  }
  facet_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Facet::mutable_facet_data() {
  set_has_facet_data();
  if (facet_data_ == &::google::protobuf::internal::kEmptyString) {
    facet_data_ = new ::std::string;
  }
  return facet_data_;
}
inline ::std::string* Facet::release_facet_data() {
  clear_has_facet_data();
  if (facet_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = facet_data_;
    facet_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Facet::set_allocated_facet_data(::std::string* facet_data) {
  if (facet_data_ != &::google::protobuf::internal::kEmptyString) {
    delete facet_data_;
  }
  if (facet_data) {
    set_has_facet_data();
    facet_data_ = facet_data;
  } else {
    clear_has_facet_data();
    facet_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Currency

// required float value = 10;
inline bool Currency::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Currency::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Currency::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Currency::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float Currency::value() const {
  return value_;
}
inline void Currency::set_value(float value) {
  set_has_value();
  value_ = value;
}

// required .com.telenav.proto.CurrencyCode iso_code = 20;
inline bool Currency::has_iso_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Currency::set_has_iso_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Currency::clear_has_iso_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Currency::clear_iso_code() {
  iso_code_ = 784;
  clear_has_iso_code();
}
inline ::com::telenav::proto::CurrencyCode Currency::iso_code() const {
  return static_cast< ::com::telenav::proto::CurrencyCode >(iso_code_);
}
inline void Currency::set_iso_code(::com::telenav::proto::CurrencyCode value) {
  assert(::com::telenav::proto::CurrencyCode_IsValid(value));
  set_has_iso_code();
  iso_code_ = value;
}

// optional string symbol = 30;
inline bool Currency::has_symbol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Currency::set_has_symbol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Currency::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Currency::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& Currency::symbol() const {
  return *symbol_;
}
inline void Currency::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void Currency::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void Currency::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Currency::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* Currency::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Currency::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NameValuePair

// required string name = 10;
inline bool NameValuePair::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameValuePair::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameValuePair::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameValuePair::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameValuePair::name() const {
  return *name_;
}
inline void NameValuePair::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameValuePair::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameValuePair::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameValuePair::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NameValuePair::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameValuePair::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 20;
inline bool NameValuePair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameValuePair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameValuePair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameValuePair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& NameValuePair::value() const {
  return *value_;
}
inline void NameValuePair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameValuePair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameValuePair::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameValuePair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* NameValuePair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameValuePair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace telenav
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
